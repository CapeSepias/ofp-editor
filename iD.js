(function(exports) {

  var bootstrap = (typeof exports.bootstrap === "object") ?
    exports.bootstrap :
    (exports.bootstrap = {});

  bootstrap.tooltip = function() {

    var tooltip = function(selection) {
        selection.each(setup);
      },
      animation = d3.functor(false),
      html = d3.functor(false),
      title = function() {
        var title = this.getAttribute("data-original-title");
        if (title) {
          return title;
        } else {
          title = this.getAttribute("title");
          this.removeAttribute("title");
          this.setAttribute("data-original-title", title);
        }
        return title;
      },
      over = "mouseenter.tooltip",
      out = "mouseleave.tooltip",
      placements = "top left bottom right".split(" "),
      placement = d3.functor("top");

    tooltip.title = function(_) {
      if (arguments.length) {
        title = d3.functor(_);
        return tooltip;
      } else {
        return title;
      }
    };

    tooltip.html = function(_) {
      if (arguments.length) {
        html = d3.functor(_);
        return tooltip;
      } else {
        return html;
      }
    };

    tooltip.placement = function(_) {
      if (arguments.length) {
        placement = d3.functor(_);
        return tooltip;
      } else {
        return placement;
      }
    };

    tooltip.show = function(selection) {
      selection.each(show);
    };

    tooltip.hide = function(selection) {
      selection.each(hide);
    };

    tooltip.toggle = function(selection) {
      selection.each(toggle);
    };

    tooltip.destroy = function(selection) {
      selection
        .on(over, null)
        .on(out, null)
        .attr("title", function() {
          return this.getAttribute("data-original-title") || this.getAttribute("title");
        })
        .attr("data-original-title", null)
        .select(".tooltip")
        .remove();
    };

    function setup() {
      var root = d3.select(this),
          animate = animation.apply(this, arguments),
          tip = root.append("div")
            .attr("class", "tooltip");

      if (animate) {
        tip.classed("fade", true);
      }

      // TODO "inside" checks?

      tip.append("div")
        .attr("class", "tooltip-arrow");
      tip.append("div")
        .attr("class", "tooltip-inner");

      var place = placement.apply(this, arguments);
      tip.classed(place, true);

      root.on(over, show);
      root.on(out, hide);
    }

    function show() {
      var root = d3.select(this),
          content = title.apply(this, arguments),
          tip = root.select(".tooltip")
            .classed("in", true),
          markup = html.apply(this, arguments),
          innercontent = tip.select(".tooltip-inner")[markup ? "html" : "text"](content),
          place = placement.apply(this, arguments),
          outer = getPosition(root.node()),
          inner = getPosition(tip.node()),
          pos;

      switch (place) {
        case "top":
          pos = {x: outer.x + (outer.w - inner.w) / 2, y: outer.y - inner.h};
          break;
        case "right":
          pos = {x: outer.x + outer.w, y: outer.y + (outer.h - inner.h) / 2};
          break;
        case "left":
          pos = {x: outer.x - inner.w, y: outer.y + (outer.h - inner.h) / 2};
          break;
        case "bottom":
          pos = {x: Math.max(0, outer.x + (outer.w - inner.w) / 2), y: outer.y + outer.h};
          break;
      }

      tip.style(pos ?
        {left: ~~pos.x + "px", top: ~~pos.y + "px"} :
        {left: null, top: null});

      this.tooltipVisible = true;
    }

    function hide() {
      d3.select(this).select(".tooltip")
        .classed("in", false);

      this.tooltipVisible = false;
    }

    function toggle() {
      if (this.tooltipVisible) {
        hide.apply(this, arguments);
      } else {
        show.apply(this, arguments);
      }
    }

    return tooltip;
  };

  function getPosition(node) {
    var mode = d3.select(node).style('position');
    if (mode === 'absolute' || mode === 'static') {
      return {
        x: node.offsetLeft,
        y: node.offsetTop,
        w: node.offsetWidth,
        h: node.offsetHeight
      };
    } else {
      return {
        x: 0,
        y: 0,
        w: node.offsetWidth,
        h: node.offsetHeight
      };
    }
  }

})(this);
d3 = function() {
  var π = Math.PI, ε = 1e-6, d3 = {
    version: "3.0.8"
  }, d3_radians = π / 180, d3_degrees = 180 / π, d3_document = document, d3_window = window;
  function d3_target(d) {
    return d.target;
  }
  function d3_source(d) {
    return d.source;
  }
  function d3_acos(x) {
    return Math.acos(Math.max(-1, Math.min(1, x)));
  }
  var d3_format_decimalPoint = ".", d3_format_thousandsSeparator = ",", d3_format_grouping = [ 3, 3 ];
  if (!Date.now) Date.now = function() {
    return +new Date();
  };
  try {
    d3_document.createElement("div").style.setProperty("opacity", 0, "");
  } catch (error) {
    var d3_style_prototype = d3_window.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
    d3_style_prototype.setProperty = function(name, value, priority) {
      d3_style_setProperty.call(this, name, value + "", priority);
    };
  }
  function d3_class(ctor, properties) {
    try {
      for (var key in properties) {
        Object.defineProperty(ctor.prototype, key, {
          value: properties[key],
          enumerable: false
        });
      }
    } catch (e) {
      ctor.prototype = properties;
    }
  }
  var d3_array = d3_arraySlice;
  function d3_arrayCopy(pseudoarray) {
    var i = -1, n = pseudoarray.length, array = [];
    while (++i < n) array.push(pseudoarray[i]);
    return array;
  }
  function d3_arraySlice(pseudoarray) {
    return Array.prototype.slice.call(pseudoarray);
  }
  try {
    d3_array(d3_document.documentElement.childNodes)[0].nodeType;
  } catch (e) {
    d3_array = d3_arrayCopy;
  }
  var d3_arraySubclass = [].__proto__ ? function(array, prototype) {
    array.__proto__ = prototype;
  } : function(array, prototype) {
    for (var property in prototype) array[property] = prototype[property];
  };
  d3.map = function(object) {
    var map = new d3_Map();
    for (var key in object) map.set(key, object[key]);
    return map;
  };
  function d3_Map() {}
  d3_class(d3_Map, {
    has: function(key) {
      return d3_map_prefix + key in this;
    },
    get: function(key) {
      return this[d3_map_prefix + key];
    },
    set: function(key, value) {
      return this[d3_map_prefix + key] = value;
    },
    remove: function(key) {
      key = d3_map_prefix + key;
      return key in this && delete this[key];
    },
    keys: function() {
      var keys = [];
      this.forEach(function(key) {
        keys.push(key);
      });
      return keys;
    },
    values: function() {
      var values = [];
      this.forEach(function(key, value) {
        values.push(value);
      });
      return values;
    },
    entries: function() {
      var entries = [];
      this.forEach(function(key, value) {
        entries.push({
          key: key,
          value: value
        });
      });
      return entries;
    },
    forEach: function(f) {
      for (var key in this) {
        if (key.charCodeAt(0) === d3_map_prefixCode) {
          f.call(this, key.substring(1), this[key]);
        }
      }
    }
  });
  var d3_map_prefix = "\0", d3_map_prefixCode = d3_map_prefix.charCodeAt(0);
  d3.set = function(array) {
    var set = new d3_Set();
    if (array) for (var i = 0; i < array.length; i++) set.add(array[i]);
    return set;
  };
  function d3_Set() {}
  d3_class(d3_Set, {
    has: function(value) {
      return d3_map_prefix + value in this;
    },
    add: function(value) {
      this[d3_map_prefix + value] = true;
      return value;
    },
    remove: function(value) {
      value = d3_map_prefix + value;
      return value in this && delete this[value];
    },
    values: function() {
      var values = [];
      this.forEach(function(value) {
        values.push(value);
      });
      return values;
    },
    forEach: function(f) {
      for (var value in this) {
        if (value.charCodeAt(0) === d3_map_prefixCode) {
          f.call(this, value.substring(1));
        }
      }
    }
  });
  function d3_identity(d) {
    return d;
  }
  function d3_true() {
    return true;
  }
  function d3_functor(v) {
    return typeof v === "function" ? v : function() {
      return v;
    };
  }
  d3.functor = d3_functor;
  d3.rebind = function(target, source) {
    var i = 1, n = arguments.length, method;
    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
    return target;
  };
  function d3_rebind(target, source, method) {
    return function() {
      var value = method.apply(source, arguments);
      return value === source ? target : value;
    };
  }
  d3.ascending = function(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  };
  d3.descending = function(a, b) {
    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
  };
  d3.mean = function(array, f) {
    var n = array.length, a, m = 0, i = -1, j = 0;
    if (arguments.length === 1) {
      while (++i < n) if (d3_number(a = array[i])) m += (a - m) / ++j;
    } else {
      while (++i < n) if (d3_number(a = f.call(array, array[i], i))) m += (a - m) / ++j;
    }
    return j ? m : undefined;
  };
  d3.median = function(array, f) {
    if (arguments.length > 1) array = array.map(f);
    array = array.filter(d3_number);
    return array.length ? d3.quantile(array.sort(d3.ascending), .5) : undefined;
  };
  d3.min = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n && ((a = array[i]) == null || a != a)) a = undefined;
      while (++i < n) if ((b = array[i]) != null && a > b) a = b;
    } else {
      while (++i < n && ((a = f.call(array, array[i], i)) == null || a != a)) a = undefined;
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
    }
    return a;
  };
  d3.max = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n && ((a = array[i]) == null || a != a)) a = undefined;
      while (++i < n) if ((b = array[i]) != null && b > a) a = b;
    } else {
      while (++i < n && ((a = f.call(array, array[i], i)) == null || a != a)) a = undefined;
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
    }
    return a;
  };
  d3.extent = function(array, f) {
    var i = -1, n = array.length, a, b, c;
    if (arguments.length === 1) {
      while (++i < n && ((a = c = array[i]) == null || a != a)) a = c = undefined;
      while (++i < n) if ((b = array[i]) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    } else {
      while (++i < n && ((a = c = f.call(array, array[i], i)) == null || a != a)) a = undefined;
      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    }
    return [ a, c ];
  };
  d3.random = {
    normal: function(µ, σ) {
      var n = arguments.length;
      if (n < 2) σ = 1;
      if (n < 1) µ = 0;
      return function() {
        var x, y, r;
        do {
          x = Math.random() * 2 - 1;
          y = Math.random() * 2 - 1;
          r = x * x + y * y;
        } while (!r || r > 1);
        return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);
      };
    },
    logNormal: function() {
      var random = d3.random.normal.apply(d3, arguments);
      return function() {
        return Math.exp(random());
      };
    },
    irwinHall: function(m) {
      return function() {
        for (var s = 0, j = 0; j < m; j++) s += Math.random();
        return s / m;
      };
    }
  };
  function d3_number(x) {
    return x != null && !isNaN(x);
  }
  d3.sum = function(array, f) {
    var s = 0, n = array.length, a, i = -1;
    if (arguments.length === 1) {
      while (++i < n) if (!isNaN(a = +array[i])) s += a;
    } else {
      while (++i < n) if (!isNaN(a = +f.call(array, array[i], i))) s += a;
    }
    return s;
  };
  d3.quantile = function(values, p) {
    var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
    return e ? v + e * (values[h] - v) : v;
  };
  d3.shuffle = function(array) {
    var m = array.length, t, i;
    while (m) {
      i = Math.random() * m-- | 0;
      t = array[m], array[m] = array[i], array[i] = t;
    }
    return array;
  };
  d3.transpose = function(matrix) {
    return d3.zip.apply(d3, matrix);
  };
  d3.zip = function() {
    if (!(n = arguments.length)) return [];
    for (var i = -1, m = d3.min(arguments, d3_zipLength), zips = new Array(m); ++i < m; ) {
      for (var j = -1, n, zip = zips[i] = new Array(n); ++j < n; ) {
        zip[j] = arguments[j][i];
      }
    }
    return zips;
  };
  function d3_zipLength(d) {
    return d.length;
  }
  d3.bisector = function(f) {
    return {
      left: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (f.call(a, a[mid], mid) < x) lo = mid + 1; else hi = mid;
        }
        return lo;
      },
      right: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (x < f.call(a, a[mid], mid)) hi = mid; else lo = mid + 1;
        }
        return lo;
      }
    };
  };
  var d3_bisector = d3.bisector(function(d) {
    return d;
  });
  d3.bisectLeft = d3_bisector.left;
  d3.bisect = d3.bisectRight = d3_bisector.right;
  d3.nest = function() {
    var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
    function map(mapType, array, depth) {
      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
      var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
      while (++i < n) {
        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
          values.push(object);
        } else {
          valuesByKey.set(keyValue, [ object ]);
        }
      }
      if (mapType) {
        object = mapType();
        setter = function(keyValue, values) {
          object.set(keyValue, map(mapType, values, depth));
        };
      } else {
        object = {};
        setter = function(keyValue, values) {
          object[keyValue] = map(mapType, values, depth);
        };
      }
      valuesByKey.forEach(setter);
      return object;
    }
    function entries(map, depth) {
      if (depth >= keys.length) return map;
      var array = [], sortKey = sortKeys[depth++];
      map.forEach(function(key, keyMap) {
        array.push({
          key: key,
          values: entries(keyMap, depth)
        });
      });
      return sortKey ? array.sort(function(a, b) {
        return sortKey(a.key, b.key);
      }) : array;
    }
    nest.map = function(array, mapType) {
      return map(mapType, array, 0);
    };
    nest.entries = function(array) {
      return entries(map(d3.map, array, 0), 0);
    };
    nest.key = function(d) {
      keys.push(d);
      return nest;
    };
    nest.sortKeys = function(order) {
      sortKeys[keys.length - 1] = order;
      return nest;
    };
    nest.sortValues = function(order) {
      sortValues = order;
      return nest;
    };
    nest.rollup = function(f) {
      rollup = f;
      return nest;
    };
    return nest;
  };
  d3.keys = function(map) {
    var keys = [];
    for (var key in map) keys.push(key);
    return keys;
  };
  d3.values = function(map) {
    var values = [];
    for (var key in map) values.push(map[key]);
    return values;
  };
  d3.entries = function(map) {
    var entries = [];
    for (var key in map) entries.push({
      key: key,
      value: map[key]
    });
    return entries;
  };
  d3.permute = function(array, indexes) {
    var permutes = [], i = -1, n = indexes.length;
    while (++i < n) permutes[i] = array[indexes[i]];
    return permutes;
  };
  d3.merge = function(arrays) {
    return Array.prototype.concat.apply([], arrays);
  };
  function d3_collapse(s) {
    return s.trim().replace(/\s+/g, " ");
  }
  d3.range = function(start, stop, step) {
    if (arguments.length < 3) {
      step = 1;
      if (arguments.length < 2) {
        stop = start;
        start = 0;
      }
    }
    if ((stop - start) / step === Infinity) throw new Error("infinite range");
    var range = [], k = d3_range_integerScale(Math.abs(step)), i = -1, j;
    start *= k, stop *= k, step *= k;
    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);
    return range;
  };
  function d3_range_integerScale(x) {
    var k = 1;
    while (x * k % 1) k *= 10;
    return k;
  }
  d3.requote = function(s) {
    return s.replace(d3_requote_re, "\\$&");
  };
  var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
  d3.round = function(x, n) {
    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
  };
  d3.xhr = function(url, mimeType, callback) {
    var xhr = {}, dispatch = d3.dispatch("progress", "load", "error"), headers = {}, response = d3_identity, request = new (d3_window.XDomainRequest && /^(http(s)?:)?\/\//.test(url) ? XDomainRequest : XMLHttpRequest)();
    "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
      request.readyState > 3 && respond();
    };
    function respond() {
      var s = request.status;
      !s && request.responseText || s >= 200 && s < 300 || s === 304 ? dispatch.load.call(xhr, response.call(xhr, request)) : dispatch.error.call(xhr, request);
    }
    request.onprogress = function(event) {
      var o = d3.event;
      d3.event = event;
      try {
        dispatch.progress.call(xhr, request);
      } finally {
        d3.event = o;
      }
    };
    xhr.header = function(name, value) {
      name = (name + "").toLowerCase();
      if (arguments.length < 2) return headers[name];
      if (value == null) delete headers[name]; else headers[name] = value + "";
      return xhr;
    };
    xhr.mimeType = function(value) {
      if (!arguments.length) return mimeType;
      mimeType = value == null ? null : value + "";
      return xhr;
    };
    xhr.response = function(value) {
      response = value;
      return xhr;
    };
    [ "get", "post" ].forEach(function(method) {
      xhr[method] = function() {
        return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));
      };
    });
    xhr.send = function(method, data, callback) {
      if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
      request.open(method, url, true);
      if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
      if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
      if (callback != null) xhr.on("error", callback).on("load", function(request) {
        callback(null, request);
      });
      request.send(data == null ? null : data);
      return xhr;
    };
    xhr.abort = function() {
      request.abort();
      return xhr;
    };
    d3.rebind(xhr, dispatch, "on");
    if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, 
    mimeType = null;
    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
  };
  function d3_xhr_fixCallback(callback) {
    return callback.length === 1 ? function(error, request) {
      callback(error == null ? request : null);
    } : callback;
  }
  d3.text = function() {
    return d3.xhr.apply(d3, arguments).response(d3_text);
  };
  function d3_text(request) {
    return request.responseText;
  }
  d3.json = function(url, callback) {
    return d3.xhr(url, "application/json", callback).response(d3_json);
  };
  function d3_json(request) {
    return JSON.parse(request.responseText);
  }
  d3.html = function(url, callback) {
    return d3.xhr(url, "text/html", callback).response(d3_html);
  };
  function d3_html(request) {
    var range = d3_document.createRange();
    range.selectNode(d3_document.body);
    return range.createContextualFragment(request.responseText);
  }
  d3.xml = function() {
    return d3.xhr.apply(d3, arguments).response(d3_xml);
  };
  function d3_xml(request) {
    return request.responseXML;
  }
  var d3_nsPrefix = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: "http://www.w3.org/1999/xhtml",
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };
  d3.ns = {
    prefix: d3_nsPrefix,
    qualify: function(name) {
      var i = name.indexOf(":"), prefix = name;
      if (i >= 0) {
        prefix = name.substring(0, i);
        name = name.substring(i + 1);
      }
      return d3_nsPrefix.hasOwnProperty(prefix) ? {
        space: d3_nsPrefix[prefix],
        local: name
      } : name;
    }
  };
  d3.dispatch = function() {
    var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    return dispatch;
  };
  function d3_dispatch() {}
  d3_dispatch.prototype.on = function(type, listener) {
    var i = type.indexOf("."), name = "";
    if (i > 0) {
      name = type.substring(i + 1);
      type = type.substring(0, i);
    }
    return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
  };
  function d3_dispatch_event(dispatch) {
    var listeners = [], listenerByName = new d3_Map();
    function event() {
      var z = listeners, i = -1, n = z.length, l;
      while (++i < n) if (l = z[i].on) l.apply(this, arguments);
      return dispatch;
    }
    event.on = function(name, listener) {
      var l = listenerByName.get(name), i;
      if (arguments.length < 2) return l && l.on;
      if (l) {
        l.on = null;
        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
        listenerByName.remove(name);
      }
      if (listener) listeners.push(listenerByName.set(name, {
        on: listener
      }));
      return dispatch;
    };
    return event;
  }
  d3.format = function(specifier) {
    var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "", basePrefix = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, suffix = "", integer = false;
    if (precision) precision = +precision.substring(1);
    if (zfill || fill === "0" && align === "=") {
      zfill = fill = "0";
      align = "=";
      if (comma) width -= Math.floor((width - 1) / 4);
    }
    switch (type) {
     case "n":
      comma = true;
      type = "g";
      break;

     case "%":
      scale = 100;
      suffix = "%";
      type = "f";
      break;

     case "p":
      scale = 100;
      suffix = "%";
      type = "r";
      break;

     case "b":
     case "o":
     case "x":
     case "X":
      if (basePrefix) basePrefix = "0" + type.toLowerCase();

     case "c":
     case "d":
      integer = true;
      precision = 0;
      break;

     case "s":
      scale = -1;
      type = "r";
      break;
    }
    if (basePrefix === "#") basePrefix = "";
    if (type == "r" && !precision) type = "g";
    type = d3_format_types.get(type) || d3_format_typeDefault;
    var zcomma = zfill && comma;
    return function(value) {
      if (integer && value % 1) return "";
      var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign;
      if (scale < 0) {
        var prefix = d3.formatPrefix(value, precision);
        value = prefix.scale(value);
        suffix = prefix.symbol;
      } else {
        value *= scale;
      }
      value = type(value, precision);
      if (!zfill && comma) value = d3_format_group(value);
      var length = basePrefix.length + value.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
      if (zcomma) value = d3_format_group(padding + value);
      if (d3_format_decimalPoint) value.replace(".", d3_format_decimalPoint);
      negative += basePrefix;
      return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + suffix;
    };
  };
  var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?(#)?(0)?([0-9]+)?(,)?(\.[0-9]+)?([a-zA-Z%])?/;
  var d3_format_types = d3.map({
    b: function(x) {
      return x.toString(2);
    },
    c: function(x) {
      return String.fromCharCode(x);
    },
    o: function(x) {
      return x.toString(8);
    },
    x: function(x) {
      return x.toString(16);
    },
    X: function(x) {
      return x.toString(16).toUpperCase();
    },
    g: function(x, p) {
      return x.toPrecision(p);
    },
    e: function(x, p) {
      return x.toExponential(p);
    },
    f: function(x, p) {
      return x.toFixed(p);
    },
    r: function(x, p) {
      return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
    }
  });
  function d3_format_precision(x, p) {
    return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
  }
  function d3_format_typeDefault(x) {
    return x + "";
  }
  var d3_format_group = d3_identity;
  if (d3_format_grouping) {
    var d3_format_groupingLength = d3_format_grouping.length;
    d3_format_group = function(value) {
      var i = value.lastIndexOf("."), f = i >= 0 ? "." + value.substring(i + 1) : (i = value.length, 
      ""), t = [], j = 0, g = d3_format_grouping[0];
      while (i > 0 && g > 0) {
        t.push(value.substring(i -= g, i + g));
        g = d3_format_grouping[j = (j + 1) % d3_format_groupingLength];
      }
      return t.reverse().join(d3_format_thousandsSeparator || "") + f;
    };
  }
  var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix);
  d3.formatPrefix = function(value, precision) {
    var i = 0;
    if (value) {
      if (value < 0) value *= -1;
      if (precision) value = d3.round(value, d3_format_precision(value, precision));
      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
      i = Math.max(-24, Math.min(24, Math.floor((i <= 0 ? i + 1 : i - 1) / 3) * 3));
    }
    return d3_formatPrefixes[8 + i / 3];
  };
  function d3_formatPrefix(d, i) {
    var k = Math.pow(10, Math.abs(8 - i) * 3);
    return {
      scale: i > 8 ? function(d) {
        return d / k;
      } : function(d) {
        return d * k;
      },
      symbol: d
    };
  }
  var d3_ease_default = function() {
    return d3_identity;
  };
  var d3_ease = d3.map({
    linear: d3_ease_default,
    poly: d3_ease_poly,
    quad: function() {
      return d3_ease_quad;
    },
    cubic: function() {
      return d3_ease_cubic;
    },
    sin: function() {
      return d3_ease_sin;
    },
    exp: function() {
      return d3_ease_exp;
    },
    circle: function() {
      return d3_ease_circle;
    },
    elastic: d3_ease_elastic,
    back: d3_ease_back,
    bounce: function() {
      return d3_ease_bounce;
    }
  });
  var d3_ease_mode = d3.map({
    "in": d3_identity,
    out: d3_ease_reverse,
    "in-out": d3_ease_reflect,
    "out-in": function(f) {
      return d3_ease_reflect(d3_ease_reverse(f));
    }
  });
  d3.ease = function(name) {
    var i = name.indexOf("-"), t = i >= 0 ? name.substring(0, i) : name, m = i >= 0 ? name.substring(i + 1) : "in";
    t = d3_ease.get(t) || d3_ease_default;
    m = d3_ease_mode.get(m) || d3_identity;
    return d3_ease_clamp(m(t.apply(null, Array.prototype.slice.call(arguments, 1))));
  };
  function d3_ease_clamp(f) {
    return function(t) {
      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
    };
  }
  function d3_ease_reverse(f) {
    return function(t) {
      return 1 - f(1 - t);
    };
  }
  function d3_ease_reflect(f) {
    return function(t) {
      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
    };
  }
  function d3_ease_quad(t) {
    return t * t;
  }
  function d3_ease_cubic(t) {
    return t * t * t;
  }
  function d3_ease_cubicInOut(t) {
    if (t <= 0) return 0;
    if (t >= 1) return 1;
    var t2 = t * t, t3 = t2 * t;
    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
  }
  function d3_ease_poly(e) {
    return function(t) {
      return Math.pow(t, e);
    };
  }
  function d3_ease_sin(t) {
    return 1 - Math.cos(t * π / 2);
  }
  function d3_ease_exp(t) {
    return Math.pow(2, 10 * (t - 1));
  }
  function d3_ease_circle(t) {
    return 1 - Math.sqrt(1 - t * t);
  }
  function d3_ease_elastic(a, p) {
    var s;
    if (arguments.length < 2) p = .45;
    if (arguments.length) s = p / (2 * π) * Math.asin(1 / a); else a = 1, s = p / 4;
    return function(t) {
      return 1 + a * Math.pow(2, 10 * -t) * Math.sin((t - s) * 2 * π / p);
    };
  }
  function d3_ease_back(s) {
    if (!s) s = 1.70158;
    return function(t) {
      return t * t * ((s + 1) * t - s);
    };
  }
  function d3_ease_bounce(t) {
    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
  }
  d3.event = null;
  function d3_eventCancel() {
    d3.event.stopPropagation();
    d3.event.preventDefault();
  }
  function d3_eventSource() {
    var e = d3.event, s;
    while (s = e.sourceEvent) e = s;
    return e;
  }
  function d3_eventDispatch(target) {
    var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    dispatch.of = function(thiz, argumentz) {
      return function(e1) {
        try {
          var e0 = e1.sourceEvent = d3.event;
          e1.target = target;
          d3.event = e1;
          dispatch[e1.type].apply(thiz, argumentz);
        } finally {
          d3.event = e0;
        }
      };
    };
    return dispatch;
  }
  d3.transform = function(string) {
    var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
    return (d3.transform = function(string) {
      g.setAttribute("transform", string);
      var t = g.transform.baseVal.consolidate();
      return new d3_transform(t ? t.matrix : d3_transformIdentity);
    })(string);
  };
  function d3_transform(m) {
    var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
    if (r0[0] * r1[1] < r1[0] * r0[1]) {
      r0[0] *= -1;
      r0[1] *= -1;
      kx *= -1;
      kz *= -1;
    }
    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
    this.translate = [ m.e, m.f ];
    this.scale = [ kx, ky ];
    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
  }
  d3_transform.prototype.toString = function() {
    return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
  };
  function d3_transformDot(a, b) {
    return a[0] * b[0] + a[1] * b[1];
  }
  function d3_transformNormalize(a) {
    var k = Math.sqrt(d3_transformDot(a, a));
    if (k) {
      a[0] /= k;
      a[1] /= k;
    }
    return k;
  }
  function d3_transformCombine(a, b, k) {
    a[0] += k * b[0];
    a[1] += k * b[1];
    return a;
  }
  var d3_transformIdentity = {
    a: 1,
    b: 0,
    c: 0,
    d: 1,
    e: 0,
    f: 0
  };
  d3.interpolate = function(a, b) {
    var i = d3.interpolators.length, f;
    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
    return f;
  };
  d3.interpolateNumber = function(a, b) {
    b -= a;
    return function(t) {
      return a + b * t;
    };
  };
  d3.interpolateRound = function(a, b) {
    b -= a;
    return function(t) {
      return Math.round(a + b * t);
    };
  };
  d3.interpolateString = function(a, b) {
    var m, i, j, s0 = 0, s1 = 0, s = [], q = [], n, o;
    d3_interpolate_number.lastIndex = 0;
    for (i = 0; m = d3_interpolate_number.exec(b); ++i) {
      if (m.index) s.push(b.substring(s0, s1 = m.index));
      q.push({
        i: s.length,
        x: m[0]
      });
      s.push(null);
      s0 = d3_interpolate_number.lastIndex;
    }
    if (s0 < b.length) s.push(b.substring(s0));
    for (i = 0, n = q.length; (m = d3_interpolate_number.exec(a)) && i < n; ++i) {
      o = q[i];
      if (o.x == m[0]) {
        if (o.i) {
          if (s[o.i + 1] == null) {
            s[o.i - 1] += o.x;
            s.splice(o.i, 1);
            for (j = i + 1; j < n; ++j) q[j].i--;
          } else {
            s[o.i - 1] += o.x + s[o.i + 1];
            s.splice(o.i, 2);
            for (j = i + 1; j < n; ++j) q[j].i -= 2;
          }
        } else {
          if (s[o.i + 1] == null) {
            s[o.i] = o.x;
          } else {
            s[o.i] = o.x + s[o.i + 1];
            s.splice(o.i + 1, 1);
            for (j = i + 1; j < n; ++j) q[j].i--;
          }
        }
        q.splice(i, 1);
        n--;
        i--;
      } else {
        o.x = d3.interpolateNumber(parseFloat(m[0]), parseFloat(o.x));
      }
    }
    while (i < n) {
      o = q.pop();
      if (s[o.i + 1] == null) {
        s[o.i] = o.x;
      } else {
        s[o.i] = o.x + s[o.i + 1];
        s.splice(o.i + 1, 1);
      }
      n--;
    }
    if (s.length === 1) {
      return s[0] == null ? q[0].x : function() {
        return b;
      };
    }
    return function(t) {
      for (i = 0; i < n; ++i) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
  d3.interpolateTransform = function(a, b) {
    var s = [], q = [], n, A = d3.transform(a), B = d3.transform(b), ta = A.translate, tb = B.translate, ra = A.rotate, rb = B.rotate, wa = A.skew, wb = B.skew, ka = A.scale, kb = B.scale;
    if (ta[0] != tb[0] || ta[1] != tb[1]) {
      s.push("translate(", null, ",", null, ")");
      q.push({
        i: 1,
        x: d3.interpolateNumber(ta[0], tb[0])
      }, {
        i: 3,
        x: d3.interpolateNumber(ta[1], tb[1])
      });
    } else if (tb[0] || tb[1]) {
      s.push("translate(" + tb + ")");
    } else {
      s.push("");
    }
    if (ra != rb) {
      if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;
      q.push({
        i: s.push(s.pop() + "rotate(", null, ")") - 2,
        x: d3.interpolateNumber(ra, rb)
      });
    } else if (rb) {
      s.push(s.pop() + "rotate(" + rb + ")");
    }
    if (wa != wb) {
      q.push({
        i: s.push(s.pop() + "skewX(", null, ")") - 2,
        x: d3.interpolateNumber(wa, wb)
      });
    } else if (wb) {
      s.push(s.pop() + "skewX(" + wb + ")");
    }
    if (ka[0] != kb[0] || ka[1] != kb[1]) {
      n = s.push(s.pop() + "scale(", null, ",", null, ")");
      q.push({
        i: n - 4,
        x: d3.interpolateNumber(ka[0], kb[0])
      }, {
        i: n - 2,
        x: d3.interpolateNumber(ka[1], kb[1])
      });
    } else if (kb[0] != 1 || kb[1] != 1) {
      s.push(s.pop() + "scale(" + kb + ")");
    }
    n = q.length;
    return function(t) {
      var i = -1, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
  d3.interpolateRgb = function(a, b) {
    a = d3.rgb(a);
    b = d3.rgb(b);
    var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
    return function(t) {
      return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
    };
  };
  d3.interpolateHsl = function(a, b) {
    a = d3.hsl(a);
    b = d3.hsl(b);
    var h0 = a.h, s0 = a.s, l0 = a.l, h1 = b.h - h0, s1 = b.s - s0, l1 = b.l - l0;
    if (h1 > 180) h1 -= 360; else if (h1 < -180) h1 += 360;
    return function(t) {
      return d3_hsl_rgb(h0 + h1 * t, s0 + s1 * t, l0 + l1 * t) + "";
    };
  };
  d3.interpolateLab = function(a, b) {
    a = d3.lab(a);
    b = d3.lab(b);
    var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
    return function(t) {
      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
    };
  };
  d3.interpolateHcl = function(a, b) {
    a = d3.hcl(a);
    b = d3.hcl(b);
    var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
    if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
    return function(t) {
      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
    };
  };
  d3.interpolateArray = function(a, b) {
    var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
    for (i = 0; i < n0; ++i) x.push(d3.interpolate(a[i], b[i]));
    for (;i < na; ++i) c[i] = a[i];
    for (;i < nb; ++i) c[i] = b[i];
    return function(t) {
      for (i = 0; i < n0; ++i) c[i] = x[i](t);
      return c;
    };
  };
  d3.interpolateObject = function(a, b) {
    var i = {}, c = {}, k;
    for (k in a) {
      if (k in b) {
        i[k] = d3_interpolateByName(k)(a[k], b[k]);
      } else {
        c[k] = a[k];
      }
    }
    for (k in b) {
      if (!(k in a)) {
        c[k] = b[k];
      }
    }
    return function(t) {
      for (k in i) c[k] = i[k](t);
      return c;
    };
  };
  var d3_interpolate_number = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
  function d3_interpolateByName(name) {
    return name == "transform" ? d3.interpolateTransform : d3.interpolate;
  }
  d3.interpolators = [ d3.interpolateObject, function(a, b) {
    return Array.isArray(b) && d3.interpolateArray(a, b);
  }, function(a, b) {
    return (typeof a === "string" || typeof b === "string") && d3.interpolateString(a + "", b + "");
  }, function(a, b) {
    return (typeof b === "string" ? d3_rgb_names.has(b) || /^(#|rgb\(|hsl\()/.test(b) : b instanceof d3_Color) && d3.interpolateRgb(a, b);
  }, function(a, b) {
    return !isNaN(a = +a) && !isNaN(b = +b) && d3.interpolateNumber(a, b);
  } ];
  function d3_uninterpolateNumber(a, b) {
    b = b - (a = +a) ? 1 / (b - a) : 0;
    return function(x) {
      return (x - a) * b;
    };
  }
  function d3_uninterpolateClamp(a, b) {
    b = b - (a = +a) ? 1 / (b - a) : 0;
    return function(x) {
      return Math.max(0, Math.min(1, (x - a) * b));
    };
  }
  function d3_Color() {}
  d3_Color.prototype.toString = function() {
    return this.rgb() + "";
  };
  d3.rgb = function(r, g, b) {
    return arguments.length === 1 ? r instanceof d3_Rgb ? d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : d3_rgb(~~r, ~~g, ~~b);
  };
  function d3_rgb(r, g, b) {
    return new d3_Rgb(r, g, b);
  }
  function d3_Rgb(r, g, b) {
    this.r = r;
    this.g = g;
    this.b = b;
  }
  var d3_rgbPrototype = d3_Rgb.prototype = new d3_Color();
  d3_rgbPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    var r = this.r, g = this.g, b = this.b, i = 30;
    if (!r && !g && !b) return d3_rgb(i, i, i);
    if (r && r < i) r = i;
    if (g && g < i) g = i;
    if (b && b < i) b = i;
    return d3_rgb(Math.min(255, Math.floor(r / k)), Math.min(255, Math.floor(g / k)), Math.min(255, Math.floor(b / k)));
  };
  d3_rgbPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return d3_rgb(Math.floor(k * this.r), Math.floor(k * this.g), Math.floor(k * this.b));
  };
  d3_rgbPrototype.hsl = function() {
    return d3_rgb_hsl(this.r, this.g, this.b);
  };
  d3_rgbPrototype.toString = function() {
    return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
  };
  function d3_rgb_hex(v) {
    return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
  }
  function d3_rgb_parse(format, rgb, hsl) {
    var r = 0, g = 0, b = 0, m1, m2, name;
    m1 = /([a-z]+)\((.*)\)/i.exec(format);
    if (m1) {
      m2 = m1[2].split(",");
      switch (m1[1]) {
       case "hsl":
        {
          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
        }

       case "rgb":
        {
          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
        }
      }
    }
    if (name = d3_rgb_names.get(format)) return rgb(name.r, name.g, name.b);
    if (format != null && format.charAt(0) === "#") {
      if (format.length === 4) {
        r = format.charAt(1);
        r += r;
        g = format.charAt(2);
        g += g;
        b = format.charAt(3);
        b += b;
      } else if (format.length === 7) {
        r = format.substring(1, 3);
        g = format.substring(3, 5);
        b = format.substring(5, 7);
      }
      r = parseInt(r, 16);
      g = parseInt(g, 16);
      b = parseInt(b, 16);
    }
    return rgb(r, g, b);
  }
  function d3_rgb_hsl(r, g, b) {
    var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
    if (d) {
      s = l < .5 ? d / (max + min) : d / (2 - max - min);
      if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;
      h *= 60;
    } else {
      s = h = 0;
    }
    return d3_hsl(h, s, l);
  }
  function d3_rgb_lab(r, g, b) {
    r = d3_rgb_xyz(r);
    g = d3_rgb_xyz(g);
    b = d3_rgb_xyz(b);
    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
  }
  function d3_rgb_xyz(r) {
    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
  }
  function d3_rgb_parseNumber(c) {
    var f = parseFloat(c);
    return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
  }
  var d3_rgb_names = d3.map({
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    gold: "#ffd700",
    goldenrod: "#daa520",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavender: "#e6e6fa",
    lavenderblush: "#fff0f5",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
  });
  d3_rgb_names.forEach(function(key, value) {
    d3_rgb_names.set(key, d3_rgb_parse(value, d3_rgb, d3_hsl_rgb));
  });
  d3.hsl = function(h, s, l) {
    return arguments.length === 1 ? h instanceof d3_Hsl ? d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : d3_hsl(+h, +s, +l);
  };
  function d3_hsl(h, s, l) {
    return new d3_Hsl(h, s, l);
  }
  function d3_Hsl(h, s, l) {
    this.h = h;
    this.s = s;
    this.l = l;
  }
  var d3_hslPrototype = d3_Hsl.prototype = new d3_Color();
  d3_hslPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return d3_hsl(this.h, this.s, this.l / k);
  };
  d3_hslPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return d3_hsl(this.h, this.s, k * this.l);
  };
  d3_hslPrototype.rgb = function() {
    return d3_hsl_rgb(this.h, this.s, this.l);
  };
  function d3_hsl_rgb(h, s, l) {
    var m1, m2;
    h = h % 360;
    if (h < 0) h += 360;
    s = s < 0 ? 0 : s > 1 ? 1 : s;
    l = l < 0 ? 0 : l > 1 ? 1 : l;
    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
    m1 = 2 * l - m2;
    function v(h) {
      if (h > 360) h -= 360; else if (h < 0) h += 360;
      if (h < 60) return m1 + (m2 - m1) * h / 60;
      if (h < 180) return m2;
      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
      return m1;
    }
    function vv(h) {
      return Math.round(v(h) * 255);
    }
    return d3_rgb(vv(h + 120), vv(h), vv(h - 120));
  }
  d3.hcl = function(h, c, l) {
    return arguments.length === 1 ? h instanceof d3_Hcl ? d3_hcl(h.h, h.c, h.l) : h instanceof d3_Lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : d3_hcl(+h, +c, +l);
  };
  function d3_hcl(h, c, l) {
    return new d3_Hcl(h, c, l);
  }
  function d3_Hcl(h, c, l) {
    this.h = h;
    this.c = c;
    this.l = l;
  }
  var d3_hclPrototype = d3_Hcl.prototype = new d3_Color();
  d3_hclPrototype.brighter = function(k) {
    return d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.darker = function(k) {
    return d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.rgb = function() {
    return d3_hcl_lab(this.h, this.c, this.l).rgb();
  };
  function d3_hcl_lab(h, c, l) {
    return d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
  }
  d3.lab = function(l, a, b) {
    return arguments.length === 1 ? l instanceof d3_Lab ? d3_lab(l.l, l.a, l.b) : l instanceof d3_Hcl ? d3_hcl_lab(l.l, l.c, l.h) : d3_rgb_lab((l = d3.rgb(l)).r, l.g, l.b) : d3_lab(+l, +a, +b);
  };
  function d3_lab(l, a, b) {
    return new d3_Lab(l, a, b);
  }
  function d3_Lab(l, a, b) {
    this.l = l;
    this.a = a;
    this.b = b;
  }
  var d3_lab_K = 18;
  var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
  var d3_labPrototype = d3_Lab.prototype = new d3_Color();
  d3_labPrototype.brighter = function(k) {
    return d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.darker = function(k) {
    return d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.rgb = function() {
    return d3_lab_rgb(this.l, this.a, this.b);
  };
  function d3_lab_rgb(l, a, b) {
    var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
    x = d3_lab_xyz(x) * d3_lab_X;
    y = d3_lab_xyz(y) * d3_lab_Y;
    z = d3_lab_xyz(z) * d3_lab_Z;
    return d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
  }
  function d3_lab_hcl(l, a, b) {
    return d3_hcl(Math.atan2(b, a) / π * 180, Math.sqrt(a * a + b * b), l);
  }
  function d3_lab_xyz(x) {
    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
  }
  function d3_xyz_lab(x) {
    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
  }
  function d3_xyz_rgb(r) {
    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
  }
  function d3_selection(groups) {
    d3_arraySubclass(groups, d3_selectionPrototype);
    return groups;
  }
  var d3_select = function(s, n) {
    return n.querySelector(s);
  }, d3_selectAll = function(s, n) {
    return n.querySelectorAll(s);
  }, d3_selectRoot = d3_document.documentElement, d3_selectMatcher = d3_selectRoot.matchesSelector || d3_selectRoot.webkitMatchesSelector || d3_selectRoot.mozMatchesSelector || d3_selectRoot.msMatchesSelector || d3_selectRoot.oMatchesSelector, d3_selectMatches = function(n, s) {
    return d3_selectMatcher.call(n, s);
  };
  if (typeof Sizzle === "function") {
    d3_select = function(s, n) {
      return Sizzle(s, n)[0] || null;
    };
    d3_selectAll = function(s, n) {
      return Sizzle.uniqueSort(Sizzle(s, n));
    };
    d3_selectMatches = Sizzle.matchesSelector;
  }
  var d3_selectionPrototype = [];
  d3.selection = function() {
    return d3_selectionRoot;
  };
  d3.selection.prototype = d3_selectionPrototype;
  d3_selectionPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, group, node;
    if (typeof selector !== "function") selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(subnode = selector.call(node, node.__data__, i));
          if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selector(selector) {
    return function() {
      return d3_select(selector, this);
    };
  }
  d3_selectionPrototype.selectAll = function(selector) {
    var subgroups = [], subgroup, node;
    if (typeof selector !== "function") selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i)));
          subgroup.parentNode = node;
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selectorAll(selector) {
    return function() {
      return d3_selectAll(selector, this);
    };
  }
  d3_selectionPrototype.attr = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node();
        name = d3.ns.qualify(name);
        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
      }
      for (value in name) this.each(d3_selection_attr(value, name[value]));
      return this;
    }
    return this.each(d3_selection_attr(name, value));
  };
  function d3_selection_attr(name, value) {
    name = d3.ns.qualify(name);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    function attrConstant() {
      this.setAttribute(name, value);
    }
    function attrConstantNS() {
      this.setAttributeNS(name.space, name.local, value);
    }
    function attrFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);
    }
    function attrFunctionNS() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);
    }
    return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
  }
  d3_selectionPrototype.classed = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node(), n = (name = name.trim().split(/^|\s+/g)).length, i = -1;
        if (value = node.classList) {
          while (++i < n) if (!value.contains(name[i])) return false;
        } else {
          value = node.className;
          if (value.baseVal != null) value = value.baseVal;
          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
        }
        return true;
      }
      for (value in name) this.each(d3_selection_classed(value, name[value]));
      return this;
    }
    return this.each(d3_selection_classed(name, value));
  };
  function d3_selection_classedRe(name) {
    return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
  }
  function d3_selection_classed(name, value) {
    name = name.trim().split(/\s+/).map(d3_selection_classedName);
    var n = name.length;
    function classedConstant() {
      var i = -1;
      while (++i < n) name[i](this, value);
    }
    function classedFunction() {
      var i = -1, x = value.apply(this, arguments);
      while (++i < n) name[i](this, x);
    }
    return typeof value === "function" ? classedFunction : classedConstant;
  }
  function d3_selection_classedName(name) {
    var re = d3_selection_classedRe(name);
    return function(node, value) {
      if (c = node.classList) return value ? c.add(name) : c.remove(name);
      var c = node.className, cb = c.baseVal != null, cv = cb ? c.baseVal : c;
      if (value) {
        re.lastIndex = 0;
        if (!re.test(cv)) {
          cv = d3_collapse(cv + " " + name);
          if (cb) c.baseVal = cv; else node.className = cv;
        }
      } else if (cv) {
        cv = d3_collapse(cv.replace(re, " "));
        if (cb) c.baseVal = cv; else node.className = cv;
      }
    };
  }
  d3_selectionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
        return this;
      }
      if (n < 2) return d3_window.getComputedStyle(this.node(), null).getPropertyValue(name);
      priority = "";
    }
    return this.each(d3_selection_style(name, value, priority));
  };
  function d3_selection_style(name, value, priority) {
    function styleNull() {
      this.style.removeProperty(name);
    }
    function styleConstant() {
      this.style.setProperty(name, value, priority);
    }
    function styleFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);
    }
    return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
  }
  d3_selectionPrototype.property = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") return this.node()[name];
      for (value in name) this.each(d3_selection_property(value, name[value]));
      return this;
    }
    return this.each(d3_selection_property(name, value));
  };
  function d3_selection_property(name, value) {
    function propertyNull() {
      delete this[name];
    }
    function propertyConstant() {
      this[name] = value;
    }
    function propertyFunction() {
      var x = value.apply(this, arguments);
      if (x == null) delete this[name]; else this[name] = x;
    }
    return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
  }
  d3_selectionPrototype.text = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    } : value == null ? function() {
      this.textContent = "";
    } : function() {
      this.textContent = value;
    }) : this.node().textContent;
  };
  d3_selectionPrototype.html = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    } : value == null ? function() {
      this.innerHTML = "";
    } : function() {
      this.innerHTML = value;
    }) : this.node().innerHTML;
  };
  d3_selectionPrototype.append = function(name) {
    name = d3.ns.qualify(name);
    function append() {
      return this.appendChild(d3_document.createElementNS(this.namespaceURI, name));
    }
    function appendNS() {
      return this.appendChild(d3_document.createElementNS(name.space, name.local));
    }
    return this.select(name.local ? appendNS : append);
  };
  d3_selectionPrototype.insert = function(name, before) {
    name = d3.ns.qualify(name);
    if (typeof before !== "function") before = d3_selection_selector(before);
    function insert(d, i) {
      return this.insertBefore(d3_document.createElementNS(this.namespaceURI, name), before.call(this, d, i));
    }
    function insertNS(d, i) {
      return this.insertBefore(d3_document.createElementNS(name.space, name.local), before.call(this, d, i));
    }
    return this.select(name.local ? insertNS : insert);
  };
  d3_selectionPrototype.remove = function() {
    return this.each(function() {
      var parent = this.parentNode;
      if (parent) parent.removeChild(this);
    });
  };
  d3_selectionPrototype.data = function(value, key) {
    var i = -1, n = this.length, group, node;
    if (!arguments.length) {
      value = new Array(n = (group = this[0]).length);
      while (++i < n) {
        if (node = group[i]) {
          value[i] = node.__data__;
        }
      }
      return value;
    }
    function bind(group, groupData) {
      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
      if (key) {
        var nodeByKeyValue = new d3_Map(), dataByKeyValue = new d3_Map(), keyValues = [], keyValue;
        for (i = -1; ++i < n; ) {
          keyValue = key.call(node = group[i], node.__data__, i);
          if (nodeByKeyValue.has(keyValue)) {
            exitNodes[i] = node;
          } else {
            nodeByKeyValue.set(keyValue, node);
          }
          keyValues.push(keyValue);
        }
        for (i = -1; ++i < m; ) {
          keyValue = key.call(groupData, nodeData = groupData[i], i);
          if (node = nodeByKeyValue.get(keyValue)) {
            updateNodes[i] = node;
            node.__data__ = nodeData;
          } else if (!dataByKeyValue.has(keyValue)) {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          }
          dataByKeyValue.set(keyValue, nodeData);
          nodeByKeyValue.remove(keyValue);
        }
        for (i = -1; ++i < n; ) {
          if (nodeByKeyValue.has(keyValues[i])) {
            exitNodes[i] = group[i];
          }
        }
      } else {
        for (i = -1; ++i < n0; ) {
          node = group[i];
          nodeData = groupData[i];
          if (node) {
            node.__data__ = nodeData;
            updateNodes[i] = node;
          } else {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          }
        }
        for (;i < m; ++i) {
          enterNodes[i] = d3_selection_dataNode(groupData[i]);
        }
        for (;i < n; ++i) {
          exitNodes[i] = group[i];
        }
      }
      enterNodes.update = updateNodes;
      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
      enter.push(enterNodes);
      update.push(updateNodes);
      exit.push(exitNodes);
    }
    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
    if (typeof value === "function") {
      while (++i < n) {
        bind(group = this[i], value.call(group, group.parentNode.__data__, i));
      }
    } else {
      while (++i < n) {
        bind(group = this[i], value);
      }
    }
    update.enter = function() {
      return enter;
    };
    update.exit = function() {
      return exit;
    };
    return update;
  };
  function d3_selection_dataNode(data) {
    return {
      __data__: data
    };
  }
  d3_selectionPrototype.datum = function(value) {
    return arguments.length ? this.property("__data__", value) : this.property("__data__");
  };
  d3_selectionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i)) {
          subgroup.push(node);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_filter(selector) {
    return function() {
      return d3_selectMatches(this, selector);
    };
  }
  d3_selectionPrototype.order = function() {
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
        if (node = group[i]) {
          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }
    return this;
  };
  d3_selectionPrototype.sort = function(comparator) {
    comparator = d3_selection_sortComparator.apply(this, arguments);
    for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
    return this.order();
  };
  function d3_selection_sortComparator(comparator) {
    if (!arguments.length) comparator = d3.ascending;
    return function(a, b) {
      return !a - !b || comparator(a.__data__, b.__data__);
    };
  }
  d3_selectionPrototype.on = function(type, listener, capture) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof type !== "string") {
        if (n < 2) listener = false;
        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
        return this;
      }
      if (n < 2) return (n = this.node()["__on" + type]) && n._;
      capture = false;
    }
    return this.each(d3_selection_on(type, listener, capture));
  };
  function d3_selection_on(type, listener, capture) {
    var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
    if (i > 0) type = type.substring(0, i);
    var filter = d3_selection_onFilters.get(type);
    if (filter) type = filter, wrap = d3_selection_onFilter;
    function onRemove() {
      var l = this[name];
      if (l) {
        this.removeEventListener(type, l, l.$);
        delete this[name];
      }
    }
    function onAdd() {
      var l = wrap(listener, d3_array(arguments));
      onRemove.call(this);
      this.addEventListener(type, this[name] = l, l.$ = capture);
      l._ = listener;
    }
    return listener ? onAdd : onRemove;
  }
  var d3_selection_onFilters = d3.map({
    mouseenter: "mouseover",
    mouseleave: "mouseout"
  });
  d3_selection_onFilters.forEach(function(k) {
    if ("on" + k in document) d3_selection_onFilters.remove(k);
  });
  function d3_selection_onListener(listener, argumentz) {
    return function(e) {
      var o = d3.event;
      d3.event = e;
      argumentz[0] = this.__data__;
      try {
        listener.apply(this, argumentz);
      } finally {
        d3.event = o;
      }
    };
  }
  function d3_selection_onFilter(listener, argumentz) {
    var l = d3_selection_onListener(listener, argumentz);
    return function(e) {
      var target = this, related = e.relatedTarget;
      if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
        l.call(target, e);
      }
    };
  }
  d3_selectionPrototype.each = function(callback) {
    return d3_selection_each(this, function(node, i, j) {
      callback.call(node, node.__data__, i, j);
    });
  };
  function d3_selection_each(groups, callback) {
    for (var j = 0, m = groups.length; j < m; j++) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
        if (node = group[i]) callback(node, i, j);
      }
    }
    return groups;
  }
  d3_selectionPrototype.call = function(callback) {
    var args = d3_array(arguments);
    callback.apply(args[0] = this, args);
    return this;
  };
  d3_selectionPrototype.empty = function() {
    return !this.node();
  };
  d3_selectionPrototype.node = function() {
    for (var j = 0, m = this.length; j < m; j++) {
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        var node = group[i];
        if (node) return node;
      }
    }
    return null;
  };
  d3_selectionPrototype.transition = function() {
    var id = d3_transitionInheritId || ++d3_transitionId, subgroups = [], subgroup, node, transition = Object.create(d3_transitionInherit);
    transition.time = Date.now();
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) d3_transitionNode(node, i, id, transition);
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, id);
  };
  var d3_selectionRoot = d3_selection([ [ d3_document ] ]);
  d3_selectionRoot[0].parentNode = d3_selectRoot;
  d3.select = function(selector) {
    return typeof selector === "string" ? d3_selectionRoot.select(selector) : d3_selection([ [ selector ] ]);
  };
  d3.selectAll = function(selector) {
    return typeof selector === "string" ? d3_selectionRoot.selectAll(selector) : d3_selection([ d3_array(selector) ]);
  };
  function d3_selection_enter(selection) {
    d3_arraySubclass(selection, d3_selection_enterPrototype);
    return selection;
  }
  var d3_selection_enterPrototype = [];
  d3.selection.enter = d3_selection_enter;
  d3.selection.enter.prototype = d3_selection_enterPrototype;
  d3_selection_enterPrototype.append = d3_selectionPrototype.append;
  d3_selection_enterPrototype.insert = d3_selectionPrototype.insert;
  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
  d3_selection_enterPrototype.node = d3_selectionPrototype.node;
  d3_selection_enterPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, upgroup, group, node;
    for (var j = -1, m = this.length; ++j < m; ) {
      upgroup = (group = this[j]).update;
      subgroups.push(subgroup = []);
      subgroup.parentNode = group.parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i));
          subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_transition(groups, id) {
    d3_arraySubclass(groups, d3_transitionPrototype);
    groups.id = id;
    return groups;
  }
  var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit = {
    ease: d3_ease_cubicInOut,
    delay: 0,
    duration: 250
  };
  d3_transitionPrototype.call = d3_selectionPrototype.call;
  d3_transitionPrototype.empty = d3_selectionPrototype.empty;
  d3_transitionPrototype.node = d3_selectionPrototype.node;
  d3.transition = function(selection) {
    return arguments.length ? d3_transitionInheritId ? selection.transition() : selection : d3_selectionRoot.transition();
  };
  d3.transition.prototype = d3_transitionPrototype;
  function d3_transitionNode(node, i, id, inherit) {
    var lock = node.__transition__ || (node.__transition__ = {
      active: 0,
      count: 0
    }), transition = lock[id];
    if (!transition) {
      var time = inherit.time;
      transition = lock[id] = {
        tween: new d3_Map(),
        event: d3.dispatch("start", "end"),
        time: time,
        ease: inherit.ease,
        delay: inherit.delay,
        duration: inherit.duration
      };
      ++lock.count;
      d3.timer(function(elapsed) {
        var d = node.__data__, ease = transition.ease, event = transition.event, delay = transition.delay, duration = transition.duration, tweened = [];
        return delay <= elapsed ? start(elapsed) : d3.timer(start, delay, time), 1;
        function start(elapsed) {
          if (lock.active > id) return stop();
          lock.active = id;
          event.start.call(node, d, i);
          transition.tween.forEach(function(key, value) {
            if (value = value.call(node, d, i)) {
              tweened.push(value);
            }
          });
          if (!tick(elapsed)) d3.timer(tick, 0, time);
          return 1;
        }
        function tick(elapsed) {
          if (lock.active !== id) return stop();
          var t = (elapsed - delay) / duration, e = ease(t), n = tweened.length;
          while (n > 0) {
            tweened[--n].call(node, e);
          }
          if (t >= 1) {
            stop();
            event.end.call(node, d, i);
            return 1;
          }
        }
        function stop() {
          if (--lock.count) delete lock[id]; else delete node.__transition__;
          return 1;
        }
      }, 0, time);
      return transition;
    }
  }
  d3_transitionPrototype.select = function(selector) {
    var id = this.id, subgroups = [], subgroup, subnode, node;
    if (typeof selector !== "function") selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          d3_transitionNode(subnode, i, id, node.__transition__[id]);
          subgroup.push(subnode);
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_transition(subgroups, id);
  };
  d3_transitionPrototype.selectAll = function(selector) {
    var id = this.id, subgroups = [], subgroup, subnodes, node, subnode, transition;
    if (typeof selector !== "function") selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          transition = node.__transition__[id];
          subnodes = selector.call(node, node.__data__, i);
          subgroups.push(subgroup = []);
          for (var k = -1, o = subnodes.length; ++k < o; ) {
            d3_transitionNode(subnode = subnodes[k], k, id, transition);
            subgroup.push(subnode);
          }
        }
      }
    }
    return d3_transition(subgroups, id);
  };
  d3_transitionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i)) {
          subgroup.push(node);
        }
      }
    }
    return d3_transition(subgroups, this.id, this.time).ease(this.ease());
  };
  d3_transitionPrototype.attr = function(nameNS, value) {
    if (arguments.length < 2) {
      for (value in nameNS) this.attr(value, nameNS[value]);
      return this;
    }
    var interpolate = d3_interpolateByName(nameNS), name = d3.ns.qualify(nameNS);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    return d3_transition_tween(this, "attr." + nameNS, value, function(b) {
      function attrString() {
        var a = this.getAttribute(name), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttribute(name, i(t));
        });
      }
      function attrStringNS() {
        var a = this.getAttributeNS(name.space, name.local), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttributeNS(name.space, name.local, i(t));
        });
      }
      return b == null ? name.local ? attrNullNS : attrNull : (b += "", name.local ? attrStringNS : attrString);
    });
  };
  d3_transitionPrototype.attrTween = function(nameNS, tween) {
    var name = d3.ns.qualify(nameNS);
    function attrTween(d, i) {
      var f = tween.call(this, d, i, this.getAttribute(name));
      return f && function(t) {
        this.setAttribute(name, f(t));
      };
    }
    function attrTweenNS(d, i) {
      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
      return f && function(t) {
        this.setAttributeNS(name.space, name.local, f(t));
      };
    }
    return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
  };
  d3_transitionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.style(priority, name[priority], value);
        return this;
      }
      priority = "";
    }
    var interpolate = d3_interpolateByName(name);
    function styleNull() {
      this.style.removeProperty(name);
    }
    return d3_transition_tween(this, "style." + name, value, function(b) {
      function styleString() {
        var a = d3_window.getComputedStyle(this, null).getPropertyValue(name), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.style.setProperty(name, i(t), priority);
        });
      }
      return b == null ? styleNull : (b += "", styleString);
    });
  };
  d3_transitionPrototype.styleTween = function(name, tween, priority) {
    if (arguments.length < 3) priority = "";
    return this.tween("style." + name, function(d, i) {
      var f = tween.call(this, d, i, d3_window.getComputedStyle(this, null).getPropertyValue(name));
      return f && function(t) {
        this.style.setProperty(name, f(t), priority);
      };
    });
  };
  d3_transitionPrototype.text = function(value) {
    return d3_transition_tween(this, "text", value, d3_transition_text);
  };
  function d3_transition_text(b) {
    if (b == null) b = "";
    return function() {
      this.textContent = b;
    };
  }
  d3_transitionPrototype.remove = function() {
    return this.each("end.transition", function() {
      var p;
      if (!this.__transition__ && (p = this.parentNode)) p.removeChild(this);
    });
  };
  d3_transitionPrototype.ease = function(value) {
    var id = this.id;
    if (arguments.length < 1) return this.node().__transition__[id].ease;
    if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
    return d3_selection_each(this, function(node) {
      node.__transition__[id].ease = value;
    });
  };
  d3_transitionPrototype.delay = function(value) {
    var id = this.id;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node.__transition__[id].delay = value.call(node, node.__data__, i, j) | 0;
    } : (value |= 0, function(node) {
      node.__transition__[id].delay = value;
    }));
  };
  d3_transitionPrototype.duration = function(value) {
    var id = this.id;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node.__transition__[id].duration = Math.max(1, value.call(node, node.__data__, i, j) | 0);
    } : (value = Math.max(1, value | 0), function(node) {
      node.__transition__[id].duration = value;
    }));
  };
  d3_transitionPrototype.each = function(type, listener) {
    var id = this.id;
    if (arguments.length < 2) {
      var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
      d3_transitionInheritId = id;
      d3_selection_each(this, function(node, i, j) {
        d3_transitionInherit = node.__transition__[id];
        type.call(node, node.__data__, i, j);
      });
      d3_transitionInherit = inherit;
      d3_transitionInheritId = inheritId;
    } else {
      d3_selection_each(this, function(node) {
        node.__transition__[id].event.on(type, listener);
      });
    }
    return this;
  };
  d3_transitionPrototype.transition = function() {
    var id0 = this.id, id1 = ++d3_transitionId, subgroups = [], subgroup, group, node, transition;
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if (node = group[i]) {
          transition = Object.create(node.__transition__[id0]);
          transition.delay += transition.duration;
          d3_transitionNode(node, i, id1, transition);
        }
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, id1);
  };
  d3_transitionPrototype.tween = function(name, tween) {
    var id = this.id;
    if (arguments.length < 2) return this.node().__transition__[id].tween.get(name);
    return d3_selection_each(this, tween == null ? function(node) {
      node.__transition__[id].tween.remove(name);
    } : function(node) {
      node.__transition__[id].tween.set(name, tween);
    });
  };
  function d3_transition_tween(groups, name, value, tween) {
    var id = groups.id;
    return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
      node.__transition__[id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
    } : (value = tween(value), function(node) {
      node.__transition__[id].tween.set(name, value);
    }));
  }
  var d3_timer_id = 0, d3_timer_byId = {}, d3_timer_queue = null, d3_timer_interval, d3_timer_timeout;
  d3.timer = function(callback, delay, then) {
    if (arguments.length < 3) {
      if (arguments.length < 2) delay = 0; else if (!isFinite(delay)) return;
      then = Date.now();
    }
    var timer = d3_timer_byId[callback.id];
    if (timer && timer.callback === callback) {
      timer.then = then;
      timer.delay = delay;
    } else d3_timer_byId[callback.id = ++d3_timer_id] = d3_timer_queue = {
      callback: callback,
      then: then,
      delay: delay,
      next: d3_timer_queue
    };
    if (!d3_timer_interval) {
      d3_timer_timeout = clearTimeout(d3_timer_timeout);
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
  };
  function d3_timer_step() {
    var elapsed, now = Date.now(), t1 = d3_timer_queue;
    while (t1) {
      elapsed = now - t1.then;
      if (elapsed >= t1.delay) t1.flush = t1.callback(elapsed);
      t1 = t1.next;
    }
    var delay = d3_timer_flush() - now;
    if (delay > 24) {
      if (isFinite(delay)) {
        clearTimeout(d3_timer_timeout);
        d3_timer_timeout = setTimeout(d3_timer_step, delay);
      }
      d3_timer_interval = 0;
    } else {
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
  }
  d3.timer.flush = function() {
    var elapsed, now = Date.now(), t1 = d3_timer_queue;
    while (t1) {
      elapsed = now - t1.then;
      if (!t1.delay) t1.flush = t1.callback(elapsed);
      t1 = t1.next;
    }
    d3_timer_flush();
  };
  function d3_timer_flush() {
    var t0 = null, t1 = d3_timer_queue, then = Infinity;
    while (t1) {
      if (t1.flush) {
        delete d3_timer_byId[t1.callback.id];
        t1 = t0 ? t0.next = t1.next : d3_timer_queue = t1.next;
      } else {
        then = Math.min(then, t1.then + t1.delay);
        t1 = (t0 = t1).next;
      }
    }
    return then;
  }
  var d3_timer_frame = d3_window.requestAnimationFrame || d3_window.webkitRequestAnimationFrame || d3_window.mozRequestAnimationFrame || d3_window.oRequestAnimationFrame || d3_window.msRequestAnimationFrame || function(callback) {
    setTimeout(callback, 17);
  };
  d3.mouse = function(container) {
    return d3_mousePoint(container, d3_eventSource());
  };
  var d3_mouse_bug44083 = /WebKit/.test(d3_window.navigator.userAgent) ? -1 : 0;
  function d3_mousePoint(container, e) {
    var svg = container.ownerSVGElement || container;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      if (d3_mouse_bug44083 < 0 && (d3_window.scrollX || d3_window.scrollY)) {
        svg = d3.select(d3_document.body).append("svg").style("position", "absolute").style("top", 0).style("left", 0);
        var ctm = svg[0][0].getScreenCTM();
        d3_mouse_bug44083 = !(ctm.f || ctm.e);
        svg.remove();
      }
      if (d3_mouse_bug44083) {
        point.x = e.pageX;
        point.y = e.pageY;
      } else {
        point.x = e.clientX;
        point.y = e.clientY;
      }
      point = point.matrixTransform(container.getScreenCTM().inverse());
      return [ point.x, point.y ];
    }
    var rect = container.getBoundingClientRect();
    return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];
  }
  d3.touches = function(container, touches) {
    if (arguments.length < 2) touches = d3_eventSource().touches;
    return touches ? d3_array(touches).map(function(touch) {
      var point = d3_mousePoint(container, touch);
      point.identifier = touch.identifier;
      return point;
    }) : [];
  };
  function d3_noop() {}
  d3.scale = {};
  function d3_scaleExtent(domain) {
    var start = domain[0], stop = domain[domain.length - 1];
    return start < stop ? [ start, stop ] : [ stop, start ];
  }
  function d3_scaleRange(scale) {
    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
  }
  function d3_scale_nice(domain, nice) {
    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
    if (x1 < x0) {
      dx = i0, i0 = i1, i1 = dx;
      dx = x0, x0 = x1, x1 = dx;
    }
    if (nice = nice(x1 - x0)) {
      domain[i0] = nice.floor(x0);
      domain[i1] = nice.ceil(x1);
    }
    return domain;
  }
  d3.scale.linear = function() {
    return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3.interpolate, false);
  };
  function d3_scale_linear(domain, range, interpolate, clamp) {
    var output, input;
    function rescale() {
      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
      output = linear(domain, range, uninterpolate, interpolate);
      input = linear(range, domain, uninterpolate, d3.interpolate);
      return scale;
    }
    function scale(x) {
      return output(x);
    }
    scale.invert = function(y) {
      return input(y);
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(Number);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.rangeRound = function(x) {
      return scale.range(x).interpolate(d3.interpolateRound);
    };
    scale.clamp = function(x) {
      if (!arguments.length) return clamp;
      clamp = x;
      return rescale();
    };
    scale.interpolate = function(x) {
      if (!arguments.length) return interpolate;
      interpolate = x;
      return rescale();
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    scale.tickFormat = function(m) {
      return d3_scale_linearTickFormat(domain, m);
    };
    scale.nice = function() {
      d3_scale_nice(domain, d3_scale_linearNice);
      return rescale();
    };
    scale.copy = function() {
      return d3_scale_linear(domain, range, interpolate, clamp);
    };
    return rescale();
  }
  function d3_scale_linearRebind(scale, linear) {
    return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
  }
  function d3_scale_linearNice(dx) {
    dx = Math.pow(10, Math.round(Math.log(dx) / Math.LN10) - 1);
    return dx && {
      floor: function(x) {
        return Math.floor(x / dx) * dx;
      },
      ceil: function(x) {
        return Math.ceil(x / dx) * dx;
      }
    };
  }
  function d3_scale_linearTickRange(domain, m) {
    var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
    if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;
    extent[0] = Math.ceil(extent[0] / step) * step;
    extent[1] = Math.floor(extent[1] / step) * step + step * .5;
    extent[2] = step;
    return extent;
  }
  function d3_scale_linearTicks(domain, m) {
    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
  }
  function d3_scale_linearTickFormat(domain, m) {
    return d3.format(",." + Math.max(0, -Math.floor(Math.log(d3_scale_linearTickRange(domain, m)[2]) / Math.LN10 + .01)) + "f");
  }
  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
    var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
    return function(x) {
      return i(u(x));
    };
  }
  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
    var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
    if (domain[k] < domain[0]) {
      domain = domain.slice().reverse();
      range = range.slice().reverse();
    }
    while (++j <= k) {
      u.push(uninterpolate(domain[j - 1], domain[j]));
      i.push(interpolate(range[j - 1], range[j]));
    }
    return function(x) {
      var j = d3.bisect(domain, x, 1, k) - 1;
      return i[j](u[j](x));
    };
  }
  d3.scale.log = function() {
    return d3_scale_log(d3.scale.linear().domain([ 0, Math.LN10 ]), 10, d3_scale_logp, d3_scale_powp);
  };
  function d3_scale_log(linear, base, log, pow) {
    function scale(x) {
      return linear(log(x));
    }
    scale.invert = function(x) {
      return pow(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return linear.domain().map(pow);
      if (x[0] < 0) log = d3_scale_logn, pow = d3_scale_pown; else log = d3_scale_logp, 
      pow = d3_scale_powp;
      linear.domain(x.map(log));
      return scale;
    };
    scale.base = function(_) {
      if (!arguments.length) return base;
      base = +_;
      return scale;
    };
    scale.nice = function() {
      linear.domain(d3_scale_nice(linear.domain(), d3_scale_logNice(base)));
      return scale;
    };
    scale.ticks = function() {
      var extent = d3_scaleExtent(linear.domain()), ticks = [];
      if (extent.every(isFinite)) {
        var b = Math.log(base), i = Math.floor(extent[0] / b), j = Math.ceil(extent[1] / b), u = pow(extent[0]), v = pow(extent[1]), n = base % 1 ? 2 : base;
        if (log === d3_scale_logn) {
          ticks.push(-Math.pow(base, -i));
          for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(-Math.pow(base, -i) * k);
        } else {
          for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(Math.pow(base, i) * k);
          ticks.push(Math.pow(base, i));
        }
        for (i = 0; ticks[i] < u; i++) {}
        for (j = ticks.length; ticks[j - 1] > v; j--) {}
        ticks = ticks.slice(i, j);
      }
      return ticks;
    };
    scale.tickFormat = function(n, format) {
      if (arguments.length < 2) format = d3_scale_logFormat;
      if (!arguments.length) return format;
      var b = Math.log(base), k = Math.max(.1, n / scale.ticks().length), f = log === d3_scale_logn ? (e = -1e-12, 
      Math.floor) : (e = 1e-12, Math.ceil), e;
      return function(d) {
        return d / pow(b * f(log(d) / b + e)) <= k ? format(d) : "";
      };
    };
    scale.copy = function() {
      return d3_scale_log(linear.copy(), base, log, pow);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  var d3_scale_logFormat = d3.format(".0e");
  function d3_scale_logp(x) {
    return Math.log(x < 0 ? 0 : x);
  }
  function d3_scale_powp(x) {
    return Math.exp(x);
  }
  function d3_scale_logn(x) {
    return -Math.log(x > 0 ? 0 : -x);
  }
  function d3_scale_pown(x) {
    return -Math.exp(-x);
  }
  function d3_scale_logNice(base) {
    base = Math.log(base);
    var nice = {
      floor: function(x) {
        return Math.floor(x / base) * base;
      },
      ceil: function(x) {
        return Math.ceil(x / base) * base;
      }
    };
    return function() {
      return nice;
    };
  }
  d3.scale.pow = function() {
    return d3_scale_pow(d3.scale.linear(), 1);
  };
  function d3_scale_pow(linear, exponent) {
    var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
    function scale(x) {
      return linear(powp(x));
    }
    scale.invert = function(x) {
      return powb(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return linear.domain().map(powb);
      linear.domain(x.map(powp));
      return scale;
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(scale.domain(), m);
    };
    scale.tickFormat = function(m) {
      return d3_scale_linearTickFormat(scale.domain(), m);
    };
    scale.nice = function() {
      return scale.domain(d3_scale_nice(scale.domain(), d3_scale_linearNice));
    };
    scale.exponent = function(x) {
      if (!arguments.length) return exponent;
      var domain = scale.domain();
      powp = d3_scale_powPow(exponent = x);
      powb = d3_scale_powPow(1 / exponent);
      return scale.domain(domain);
    };
    scale.copy = function() {
      return d3_scale_pow(linear.copy(), exponent);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  function d3_scale_powPow(e) {
    return function(x) {
      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
    };
  }
  d3.scale.sqrt = function() {
    return d3.scale.pow().exponent(.5);
  };
  d3.scale.ordinal = function() {
    return d3_scale_ordinal([], {
      t: "range",
      a: [ [] ]
    });
  };
  function d3_scale_ordinal(domain, ranger) {
    var index, range, rangeBand;
    function scale(x) {
      return range[((index.get(x) || index.set(x, domain.push(x))) - 1) % range.length];
    }
    function steps(start, step) {
      return d3.range(domain.length).map(function(i) {
        return start + step * i;
      });
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = [];
      index = new d3_Map();
      var i = -1, n = x.length, xi;
      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
      return scale[ranger.t].apply(scale, ranger.a);
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      rangeBand = 0;
      ranger = {
        t: "range",
        a: arguments
      };
      return scale;
    };
    scale.rangePoints = function(x, padding) {
      if (arguments.length < 2) padding = 0;
      var start = x[0], stop = x[1], step = (stop - start) / (Math.max(1, domain.length - 1) + padding);
      range = steps(domain.length < 2 ? (start + stop) / 2 : start + step * padding / 2, step);
      rangeBand = 0;
      ranger = {
        t: "rangePoints",
        a: arguments
      };
      return scale;
    };
    scale.rangeBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
      range = steps(start + step * outerPadding, step);
      if (reverse) range.reverse();
      rangeBand = step * (1 - padding);
      ranger = {
        t: "rangeBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeRoundBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding)), error = stop - start - (domain.length - padding) * step;
      range = steps(start + Math.round(error / 2), step);
      if (reverse) range.reverse();
      rangeBand = Math.round(step * (1 - padding));
      ranger = {
        t: "rangeRoundBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeBand = function() {
      return rangeBand;
    };
    scale.rangeExtent = function() {
      return d3_scaleExtent(ranger.a[0]);
    };
    scale.copy = function() {
      return d3_scale_ordinal(domain, ranger);
    };
    return scale.domain(domain);
  }
  d3.scale.category10 = function() {
    return d3.scale.ordinal().range(d3_category10);
  };
  d3.scale.category20 = function() {
    return d3.scale.ordinal().range(d3_category20);
  };
  d3.scale.category20b = function() {
    return d3.scale.ordinal().range(d3_category20b);
  };
  d3.scale.category20c = function() {
    return d3.scale.ordinal().range(d3_category20c);
  };
  var d3_category10 = [ "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf" ];
  var d3_category20 = [ "#1f77b4", "#aec7e8", "#ff7f0e", "#ffbb78", "#2ca02c", "#98df8a", "#d62728", "#ff9896", "#9467bd", "#c5b0d5", "#8c564b", "#c49c94", "#e377c2", "#f7b6d2", "#7f7f7f", "#c7c7c7", "#bcbd22", "#dbdb8d", "#17becf", "#9edae5" ];
  var d3_category20b = [ "#393b79", "#5254a3", "#6b6ecf", "#9c9ede", "#637939", "#8ca252", "#b5cf6b", "#cedb9c", "#8c6d31", "#bd9e39", "#e7ba52", "#e7cb94", "#843c39", "#ad494a", "#d6616b", "#e7969c", "#7b4173", "#a55194", "#ce6dbd", "#de9ed6" ];
  var d3_category20c = [ "#3182bd", "#6baed6", "#9ecae1", "#c6dbef", "#e6550d", "#fd8d3c", "#fdae6b", "#fdd0a2", "#31a354", "#74c476", "#a1d99b", "#c7e9c0", "#756bb1", "#9e9ac8", "#bcbddc", "#dadaeb", "#636363", "#969696", "#bdbdbd", "#d9d9d9" ];
  d3.scale.quantile = function() {
    return d3_scale_quantile([], []);
  };
  function d3_scale_quantile(domain, range) {
    var thresholds;
    function rescale() {
      var k = 0, q = range.length;
      thresholds = [];
      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
      return scale;
    }
    function scale(x) {
      if (isNaN(x = +x)) return NaN;
      return range[d3.bisect(thresholds, x)];
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.filter(function(d) {
        return !isNaN(d);
      }).sort(d3.ascending);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.quantiles = function() {
      return thresholds;
    };
    scale.copy = function() {
      return d3_scale_quantile(domain, range);
    };
    return rescale();
  }
  d3.scale.quantize = function() {
    return d3_scale_quantize(0, 1, [ 0, 1 ]);
  };
  function d3_scale_quantize(x0, x1, range) {
    var kx, i;
    function scale(x) {
      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
    }
    function rescale() {
      kx = range.length / (x1 - x0);
      i = range.length - 1;
      return scale;
    }
    scale.domain = function(x) {
      if (!arguments.length) return [ x0, x1 ];
      x0 = +x[0];
      x1 = +x[x.length - 1];
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.copy = function() {
      return d3_scale_quantize(x0, x1, range);
    };
    return rescale();
  }
  d3.scale.threshold = function() {
    return d3_scale_threshold([ .5 ], [ 0, 1 ]);
  };
  function d3_scale_threshold(domain, range) {
    function scale(x) {
      return range[d3.bisect(domain, x)];
    }
    scale.domain = function(_) {
      if (!arguments.length) return domain;
      domain = _;
      return scale;
    };
    scale.range = function(_) {
      if (!arguments.length) return range;
      range = _;
      return scale;
    };
    scale.copy = function() {
      return d3_scale_threshold(domain, range);
    };
    return scale;
  }
  d3.scale.identity = function() {
    return d3_scale_identity([ 0, 1 ]);
  };
  function d3_scale_identity(domain) {
    function identity(x) {
      return +x;
    }
    identity.invert = identity;
    identity.domain = identity.range = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(identity);
      return identity;
    };
    identity.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    identity.tickFormat = function(m) {
      return d3_scale_linearTickFormat(domain, m);
    };
    identity.copy = function() {
      return d3_scale_identity(domain);
    };
    return identity;
  }
  d3.svg = {};
  d3.svg.arc = function() {
    var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
    function arc() {
      var r0 = innerRadius.apply(this, arguments), r1 = outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) + d3_svg_arcOffset, a1 = endAngle.apply(this, arguments) + d3_svg_arcOffset, da = (a1 < a0 && (da = a0, 
      a0 = a1, a1 = da), a1 - a0), df = da < π ? "0" : "1", c0 = Math.cos(a0), s0 = Math.sin(a0), c1 = Math.cos(a1), s1 = Math.sin(a1);
      return da >= d3_svg_arcMax ? r0 ? "M0," + r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + -r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + r1 + "M0," + r0 + "A" + r0 + "," + r0 + " 0 1,0 0," + -r0 + "A" + r0 + "," + r0 + " 0 1,0 0," + r0 + "Z" : "M0," + r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + -r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + r1 + "Z" : r0 ? "M" + r1 * c0 + "," + r1 * s0 + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1 + "L" + r0 * c1 + "," + r0 * s1 + "A" + r0 + "," + r0 + " 0 " + df + ",0 " + r0 * c0 + "," + r0 * s0 + "Z" : "M" + r1 * c0 + "," + r1 * s0 + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1 + "L0,0" + "Z";
    }
    arc.innerRadius = function(v) {
      if (!arguments.length) return innerRadius;
      innerRadius = d3_functor(v);
      return arc;
    };
    arc.outerRadius = function(v) {
      if (!arguments.length) return outerRadius;
      outerRadius = d3_functor(v);
      return arc;
    };
    arc.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return arc;
    };
    arc.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return arc;
    };
    arc.centroid = function() {
      var r = (innerRadius.apply(this, arguments) + outerRadius.apply(this, arguments)) / 2, a = (startAngle.apply(this, arguments) + endAngle.apply(this, arguments)) / 2 + d3_svg_arcOffset;
      return [ Math.cos(a) * r, Math.sin(a) * r ];
    };
    return arc;
  };
  var d3_svg_arcOffset = -π / 2, d3_svg_arcMax = 2 * π - 1e-6;
  function d3_svg_arcInnerRadius(d) {
    return d.innerRadius;
  }
  function d3_svg_arcOuterRadius(d) {
    return d.outerRadius;
  }
  function d3_svg_arcStartAngle(d) {
    return d.startAngle;
  }
  function d3_svg_arcEndAngle(d) {
    return d.endAngle;
  }
  function d3_svg_line(projection) {
    var x = d3_svg_lineX, y = d3_svg_lineY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
    function line(data) {
      var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
      function segment() {
        segments.push("M", interpolate(projection(points), tension));
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
        } else if (points.length) {
          segment();
          points = [];
        }
      }
      if (points.length) segment();
      return segments.length ? segments.join("") : null;
    }
    line.x = function(_) {
      if (!arguments.length) return x;
      x = _;
      return line;
    };
    line.y = function(_) {
      if (!arguments.length) return y;
      y = _;
      return line;
    };
    line.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return line;
    };
    line.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      return line;
    };
    line.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return line;
    };
    return line;
  }
  d3.svg.line = function() {
    return d3_svg_line(d3_identity);
  };
  function d3_svg_lineX(d) {
    return d[0];
  }
  function d3_svg_lineY(d) {
    return d[1];
  }
  var d3_svg_lineInterpolators = d3.map({
    linear: d3_svg_lineLinear,
    "linear-closed": d3_svg_lineLinearClosed,
    "step-before": d3_svg_lineStepBefore,
    "step-after": d3_svg_lineStepAfter,
    basis: d3_svg_lineBasis,
    "basis-open": d3_svg_lineBasisOpen,
    "basis-closed": d3_svg_lineBasisClosed,
    bundle: d3_svg_lineBundle,
    cardinal: d3_svg_lineCardinal,
    "cardinal-open": d3_svg_lineCardinalOpen,
    "cardinal-closed": d3_svg_lineCardinalClosed,
    monotone: d3_svg_lineMonotone
  });
  d3_svg_lineInterpolators.forEach(function(key, value) {
    value.key = key;
    value.closed = /-closed$/.test(key);
  });
  function d3_svg_lineLinear(points) {
    return points.join("L");
  }
  function d3_svg_lineLinearClosed(points) {
    return d3_svg_lineLinear(points) + "Z";
  }
  function d3_svg_lineStepBefore(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
    return path.join("");
  }
  function d3_svg_lineStepAfter(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
    return path.join("");
  }
  function d3_svg_lineCardinalOpen(points, tension) {
    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, points.length - 1), d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineCardinalClosed(points, tension) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), 
    points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
  }
  function d3_svg_lineCardinal(points, tension) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineHermite(points, tangents) {
    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
      return d3_svg_lineLinear(points);
    }
    var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
    if (quad) {
      path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
      p0 = points[1];
      pi = 2;
    }
    if (tangents.length > 1) {
      t = tangents[1];
      p = points[pi];
      pi++;
      path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      for (var i = 2; i < tangents.length; i++, pi++) {
        p = points[pi];
        t = tangents[i];
        path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      }
    }
    if (quad) {
      var lp = points[pi];
      path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
    }
    return path;
  }
  function d3_svg_lineCardinalTangents(points, tension) {
    var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
    while (++i < n) {
      p0 = p1;
      p1 = p2;
      p2 = points[i];
      tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
    }
    return tangents;
  }
  function d3_svg_lineBasis(points) {
    if (points.length < 3) return d3_svg_lineLinear(points);
    var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0 ];
    d3_svg_lineBasisBezier(path, px, py);
    while (++i < n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    i = -1;
    while (++i < 2) {
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBasisOpen(points) {
    if (points.length < 4) return d3_svg_lineLinear(points);
    var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
    while (++i < 3) {
      pi = points[i];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
    --i;
    while (++i < n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBasisClosed(points) {
    var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
    while (++i < 4) {
      pi = points[i % n];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
    --i;
    while (++i < m) {
      pi = points[i % n];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBundle(points, tension) {
    var n = points.length - 1;
    if (n) {
      var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
      while (++i <= n) {
        p = points[i];
        t = i / n;
        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
      }
    }
    return d3_svg_lineBasis(points);
  }
  function d3_svg_lineDot4(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
  }
  var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
  function d3_svg_lineBasisBezier(path, x, y) {
    path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
  }
  function d3_svg_lineSlope(p0, p1) {
    return (p1[1] - p0[1]) / (p1[0] - p0[0]);
  }
  function d3_svg_lineFiniteDifferences(points) {
    var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
    while (++i < j) {
      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
    }
    m[i] = d;
    return m;
  }
  function d3_svg_lineMonotoneTangents(points) {
    var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
    while (++i < j) {
      d = d3_svg_lineSlope(points[i], points[i + 1]);
      if (Math.abs(d) < 1e-6) {
        m[i] = m[i + 1] = 0;
      } else {
        a = m[i] / d;
        b = m[i + 1] / d;
        s = a * a + b * b;
        if (s > 9) {
          s = d * 3 / Math.sqrt(s);
          m[i] = s * a;
          m[i + 1] = s * b;
        }
      }
    }
    i = -1;
    while (++i <= j) {
      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
      tangents.push([ s || 0, m[i] * s || 0 ]);
    }
    return tangents;
  }
  function d3_svg_lineMonotone(points) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
  }
  d3.svg.line.radial = function() {
    var line = d3_svg_line(d3_svg_lineRadial);
    line.radius = line.x, delete line.x;
    line.angle = line.y, delete line.y;
    return line;
  };
  function d3_svg_lineRadial(points) {
    var point, i = -1, n = points.length, r, a;
    while (++i < n) {
      point = points[i];
      r = point[0];
      a = point[1] + d3_svg_arcOffset;
      point[0] = r * Math.cos(a);
      point[1] = r * Math.sin(a);
    }
    return points;
  }
  function d3_svg_area(projection) {
    var x0 = d3_svg_lineX, x1 = d3_svg_lineX, y0 = 0, y1 = d3_svg_lineY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
    function area(data) {
      var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
        return x;
      } : d3_functor(x1), fy1 = y0 === y1 ? function() {
        return y;
      } : d3_functor(y1), x, y;
      function segment() {
        segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
          points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
        } else if (points0.length) {
          segment();
          points0 = [];
          points1 = [];
        }
      }
      if (points0.length) segment();
      return segments.length ? segments.join("") : null;
    }
    area.x = function(_) {
      if (!arguments.length) return x1;
      x0 = x1 = _;
      return area;
    };
    area.x0 = function(_) {
      if (!arguments.length) return x0;
      x0 = _;
      return area;
    };
    area.x1 = function(_) {
      if (!arguments.length) return x1;
      x1 = _;
      return area;
    };
    area.y = function(_) {
      if (!arguments.length) return y1;
      y0 = y1 = _;
      return area;
    };
    area.y0 = function(_) {
      if (!arguments.length) return y0;
      y0 = _;
      return area;
    };
    area.y1 = function(_) {
      if (!arguments.length) return y1;
      y1 = _;
      return area;
    };
    area.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return area;
    };
    area.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      interpolateReverse = interpolate.reverse || interpolate;
      L = interpolate.closed ? "M" : "L";
      return area;
    };
    area.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return area;
    };
    return area;
  }
  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
  d3.svg.area = function() {
    return d3_svg_area(d3_identity);
  };
  d3.svg.area.radial = function() {
    var area = d3_svg_area(d3_svg_lineRadial);
    area.radius = area.x, delete area.x;
    area.innerRadius = area.x0, delete area.x0;
    area.outerRadius = area.x1, delete area.x1;
    area.angle = area.y, delete area.y;
    area.startAngle = area.y0, delete area.y0;
    area.endAngle = area.y1, delete area.y1;
    return area;
  };
  d3.svg.chord = function() {
    var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
    function chord(d, i) {
      var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
      return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
    }
    function subgroup(self, f, d, i) {
      var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) + d3_svg_arcOffset, a1 = endAngle.call(self, subgroup, i) + d3_svg_arcOffset;
      return {
        r: r,
        a0: a0,
        a1: a1,
        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],
        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]
      };
    }
    function equals(a, b) {
      return a.a0 == b.a0 && a.a1 == b.a1;
    }
    function arc(r, p, a) {
      return "A" + r + "," + r + " 0 " + +(a > π) + ",1 " + p;
    }
    function curve(r0, p0, r1, p1) {
      return "Q 0,0 " + p1;
    }
    chord.radius = function(v) {
      if (!arguments.length) return radius;
      radius = d3_functor(v);
      return chord;
    };
    chord.source = function(v) {
      if (!arguments.length) return source;
      source = d3_functor(v);
      return chord;
    };
    chord.target = function(v) {
      if (!arguments.length) return target;
      target = d3_functor(v);
      return chord;
    };
    chord.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return chord;
    };
    chord.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return chord;
    };
    return chord;
  };
  function d3_svg_chordRadius(d) {
    return d.radius;
  }
  d3.svg.diagonal = function() {
    var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
    function diagonal(d, i) {
      var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
        x: p0.x,
        y: m
      }, {
        x: p3.x,
        y: m
      }, p3 ];
      p = p.map(projection);
      return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
    }
    diagonal.source = function(x) {
      if (!arguments.length) return source;
      source = d3_functor(x);
      return diagonal;
    };
    diagonal.target = function(x) {
      if (!arguments.length) return target;
      target = d3_functor(x);
      return diagonal;
    };
    diagonal.projection = function(x) {
      if (!arguments.length) return projection;
      projection = x;
      return diagonal;
    };
    return diagonal;
  };
  function d3_svg_diagonalProjection(d) {
    return [ d.x, d.y ];
  }
  d3.svg.diagonal.radial = function() {
    var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
    diagonal.projection = function(x) {
      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
    };
    return diagonal;
  };
  function d3_svg_diagonalRadialProjection(projection) {
    return function() {
      var d = projection.apply(this, arguments), r = d[0], a = d[1] + d3_svg_arcOffset;
      return [ r * Math.cos(a), r * Math.sin(a) ];
    };
  }
  d3.svg.symbol = function() {
    var type = d3_svg_symbolType, size = d3_svg_symbolSize;
    function symbol(d, i) {
      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
    }
    symbol.type = function(x) {
      if (!arguments.length) return type;
      type = d3_functor(x);
      return symbol;
    };
    symbol.size = function(x) {
      if (!arguments.length) return size;
      size = d3_functor(x);
      return symbol;
    };
    return symbol;
  };
  function d3_svg_symbolSize() {
    return 64;
  }
  function d3_svg_symbolType() {
    return "circle";
  }
  function d3_svg_symbolCircle(size) {
    var r = Math.sqrt(size / π);
    return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
  }
  var d3_svg_symbols = d3.map({
    circle: d3_svg_symbolCircle,
    cross: function(size) {
      var r = Math.sqrt(size / 5) / 2;
      return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
    },
    diamond: function(size) {
      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
      return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
    },
    square: function(size) {
      var r = Math.sqrt(size) / 2;
      return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
    },
    "triangle-down": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
    },
    "triangle-up": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
    }
  });
  d3.svg.symbolTypes = d3_svg_symbols.keys();
  var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
  d3.svg.axis = function() {
    var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, tickMajorSize = 6, tickMinorSize = 6, tickEndSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_, tickSubdivide = 0;
    function axis(g) {
      g.each(function() {
        var g = d3.select(this);
        var ticks = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments_) : scale.domain() : tickValues, tickFormat = tickFormat_ == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments_) : String : tickFormat_;
        var subticks = d3_svg_axisSubdivide(scale, ticks, tickSubdivide), subtick = g.selectAll(".tick.minor").data(subticks, String), subtickEnter = subtick.enter().insert("line", ".tick").attr("class", "tick minor").style("opacity", 1e-6), subtickExit = d3.transition(subtick.exit()).style("opacity", 1e-6).remove(), subtickUpdate = d3.transition(subtick).style("opacity", 1);
        var tick = g.selectAll(".tick.major").data(ticks, String), tickEnter = tick.enter().insert("g", "path").attr("class", "tick major").style("opacity", 1e-6), tickExit = d3.transition(tick.exit()).style("opacity", 1e-6).remove(), tickUpdate = d3.transition(tick).style("opacity", 1), tickTransform;
        var range = d3_scaleRange(scale), path = g.selectAll(".domain").data([ 0 ]), pathUpdate = (path.enter().append("path").attr("class", "domain"), 
        d3.transition(path));
        var scale1 = scale.copy(), scale0 = this.__chart__ || scale1;
        this.__chart__ = scale1;
        tickEnter.append("line");
        tickEnter.append("text");
        var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text");
        switch (orient) {
         case "bottom":
          {
            tickTransform = d3_svg_axisX;
            subtickEnter.attr("y2", tickMinorSize);
            subtickUpdate.attr("x2", 0).attr("y2", tickMinorSize);
            lineEnter.attr("y2", tickMajorSize);
            textEnter.attr("y", Math.max(tickMajorSize, 0) + tickPadding);
            lineUpdate.attr("x2", 0).attr("y2", tickMajorSize);
            textUpdate.attr("x", 0).attr("y", Math.max(tickMajorSize, 0) + tickPadding);
            text.attr("dy", ".71em").style("text-anchor", "middle");
            pathUpdate.attr("d", "M" + range[0] + "," + tickEndSize + "V0H" + range[1] + "V" + tickEndSize);
            break;
          }

         case "top":
          {
            tickTransform = d3_svg_axisX;
            subtickEnter.attr("y2", -tickMinorSize);
            subtickUpdate.attr("x2", 0).attr("y2", -tickMinorSize);
            lineEnter.attr("y2", -tickMajorSize);
            textEnter.attr("y", -(Math.max(tickMajorSize, 0) + tickPadding));
            lineUpdate.attr("x2", 0).attr("y2", -tickMajorSize);
            textUpdate.attr("x", 0).attr("y", -(Math.max(tickMajorSize, 0) + tickPadding));
            text.attr("dy", "0em").style("text-anchor", "middle");
            pathUpdate.attr("d", "M" + range[0] + "," + -tickEndSize + "V0H" + range[1] + "V" + -tickEndSize);
            break;
          }

         case "left":
          {
            tickTransform = d3_svg_axisY;
            subtickEnter.attr("x2", -tickMinorSize);
            subtickUpdate.attr("x2", -tickMinorSize).attr("y2", 0);
            lineEnter.attr("x2", -tickMajorSize);
            textEnter.attr("x", -(Math.max(tickMajorSize, 0) + tickPadding));
            lineUpdate.attr("x2", -tickMajorSize).attr("y2", 0);
            textUpdate.attr("x", -(Math.max(tickMajorSize, 0) + tickPadding)).attr("y", 0);
            text.attr("dy", ".32em").style("text-anchor", "end");
            pathUpdate.attr("d", "M" + -tickEndSize + "," + range[0] + "H0V" + range[1] + "H" + -tickEndSize);
            break;
          }

         case "right":
          {
            tickTransform = d3_svg_axisY;
            subtickEnter.attr("x2", tickMinorSize);
            subtickUpdate.attr("x2", tickMinorSize).attr("y2", 0);
            lineEnter.attr("x2", tickMajorSize);
            textEnter.attr("x", Math.max(tickMajorSize, 0) + tickPadding);
            lineUpdate.attr("x2", tickMajorSize).attr("y2", 0);
            textUpdate.attr("x", Math.max(tickMajorSize, 0) + tickPadding).attr("y", 0);
            text.attr("dy", ".32em").style("text-anchor", "start");
            pathUpdate.attr("d", "M" + tickEndSize + "," + range[0] + "H0V" + range[1] + "H" + tickEndSize);
            break;
          }
        }
        if (scale.ticks) {
          tickEnter.call(tickTransform, scale0);
          tickUpdate.call(tickTransform, scale1);
          tickExit.call(tickTransform, scale1);
          subtickEnter.call(tickTransform, scale0);
          subtickUpdate.call(tickTransform, scale1);
          subtickExit.call(tickTransform, scale1);
        } else {
          var dx = scale1.rangeBand() / 2, x = function(d) {
            return scale1(d) + dx;
          };
          tickEnter.call(tickTransform, x);
          tickUpdate.call(tickTransform, x);
        }
      });
    }
    axis.scale = function(x) {
      if (!arguments.length) return scale;
      scale = x;
      return axis;
    };
    axis.orient = function(x) {
      if (!arguments.length) return orient;
      orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
      return axis;
    };
    axis.ticks = function() {
      if (!arguments.length) return tickArguments_;
      tickArguments_ = arguments;
      return axis;
    };
    axis.tickValues = function(x) {
      if (!arguments.length) return tickValues;
      tickValues = x;
      return axis;
    };
    axis.tickFormat = function(x) {
      if (!arguments.length) return tickFormat_;
      tickFormat_ = x;
      return axis;
    };
    axis.tickSize = function(x, y) {
      if (!arguments.length) return tickMajorSize;
      var n = arguments.length - 1;
      tickMajorSize = +x;
      tickMinorSize = n > 1 ? +y : tickMajorSize;
      tickEndSize = n > 0 ? +arguments[n] : tickMajorSize;
      return axis;
    };
    axis.tickPadding = function(x) {
      if (!arguments.length) return tickPadding;
      tickPadding = +x;
      return axis;
    };
    axis.tickSubdivide = function(x) {
      if (!arguments.length) return tickSubdivide;
      tickSubdivide = +x;
      return axis;
    };
    return axis;
  };
  var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
    top: 1,
    right: 1,
    bottom: 1,
    left: 1
  };
  function d3_svg_axisX(selection, x) {
    selection.attr("transform", function(d) {
      return "translate(" + x(d) + ",0)";
    });
  }
  function d3_svg_axisY(selection, y) {
    selection.attr("transform", function(d) {
      return "translate(0," + y(d) + ")";
    });
  }
  function d3_svg_axisSubdivide(scale, ticks, m) {
    subticks = [];
    if (m && ticks.length > 1) {
      var extent = d3_scaleExtent(scale.domain()), subticks, i = -1, n = ticks.length, d = (ticks[1] - ticks[0]) / ++m, j, v;
      while (++i < n) {
        for (j = m; --j > 0; ) {
          if ((v = +ticks[i] - j * d) >= extent[0]) {
            subticks.push(v);
          }
        }
      }
      for (--i, j = 0; ++j < m && (v = +ticks[i] + j * d) < extent[1]; ) {
        subticks.push(v);
      }
    }
    return subticks;
  }
  d3.svg.brush = function() {
    var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, resizes = d3_svg_brushResizes[0], extent = [ [ 0, 0 ], [ 0, 0 ] ], extentDomain;
    function brush(g) {
      g.each(function() {
        var g = d3.select(this), bg = g.selectAll(".background").data([ 0 ]), fg = g.selectAll(".extent").data([ 0 ]), tz = g.selectAll(".resize").data(resizes, String), e;
        g.style("pointer-events", "all").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
        bg.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
        fg.enter().append("rect").attr("class", "extent").style("cursor", "move");
        tz.enter().append("g").attr("class", function(d) {
          return "resize " + d;
        }).style("cursor", function(d) {
          return d3_svg_brushCursor[d];
        }).append("rect").attr("x", function(d) {
          return /[ew]$/.test(d) ? -3 : null;
        }).attr("y", function(d) {
          return /^[ns]/.test(d) ? -3 : null;
        }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
        tz.style("display", brush.empty() ? "none" : null);
        tz.exit().remove();
        if (x) {
          e = d3_scaleRange(x);
          bg.attr("x", e[0]).attr("width", e[1] - e[0]);
          redrawX(g);
        }
        if (y) {
          e = d3_scaleRange(y);
          bg.attr("y", e[0]).attr("height", e[1] - e[0]);
          redrawY(g);
        }
        redraw(g);
      });
    }
    function redraw(g) {
      g.selectAll(".resize").attr("transform", function(d) {
        return "translate(" + extent[+/e$/.test(d)][0] + "," + extent[+/^s/.test(d)][1] + ")";
      });
    }
    function redrawX(g) {
      g.select(".extent").attr("x", extent[0][0]);
      g.selectAll(".extent,.n>rect,.s>rect").attr("width", extent[1][0] - extent[0][0]);
    }
    function redrawY(g) {
      g.select(".extent").attr("y", extent[0][1]);
      g.selectAll(".extent,.e>rect,.w>rect").attr("height", extent[1][1] - extent[0][1]);
    }
    function brushstart() {
      var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), center, origin = mouse(), offset;
      var w = d3.select(d3_window).on("mousemove.brush", brushmove).on("mouseup.brush", brushend).on("touchmove.brush", brushmove).on("touchend.brush", brushend).on("keydown.brush", keydown).on("keyup.brush", keyup);
      if (dragging) {
        origin[0] = extent[0][0] - origin[0];
        origin[1] = extent[0][1] - origin[1];
      } else if (resizing) {
        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
        offset = [ extent[1 - ex][0] - origin[0], extent[1 - ey][1] - origin[1] ];
        origin[0] = extent[ex][0];
        origin[1] = extent[ey][1];
      } else if (d3.event.altKey) center = origin.slice();
      g.style("pointer-events", "none").selectAll(".resize").style("display", null);
      d3.select("body").style("cursor", eventTarget.style("cursor"));
      event_({
        type: "brushstart"
      });
      brushmove();
      d3_eventCancel();
      function mouse() {
        var touches = d3.event.changedTouches;
        return touches ? d3.touches(target, touches)[0] : d3.mouse(target);
      }
      function keydown() {
        if (d3.event.keyCode == 32) {
          if (!dragging) {
            center = null;
            origin[0] -= extent[1][0];
            origin[1] -= extent[1][1];
            dragging = 2;
          }
          d3_eventCancel();
        }
      }
      function keyup() {
        if (d3.event.keyCode == 32 && dragging == 2) {
          origin[0] += extent[1][0];
          origin[1] += extent[1][1];
          dragging = 0;
          d3_eventCancel();
        }
      }
      function brushmove() {
        var point = mouse(), moved = false;
        if (offset) {
          point[0] += offset[0];
          point[1] += offset[1];
        }
        if (!dragging) {
          if (d3.event.altKey) {
            if (!center) center = [ (extent[0][0] + extent[1][0]) / 2, (extent[0][1] + extent[1][1]) / 2 ];
            origin[0] = extent[+(point[0] < center[0])][0];
            origin[1] = extent[+(point[1] < center[1])][1];
          } else center = null;
        }
        if (resizingX && move1(point, x, 0)) {
          redrawX(g);
          moved = true;
        }
        if (resizingY && move1(point, y, 1)) {
          redrawY(g);
          moved = true;
        }
        if (moved) {
          redraw(g);
          event_({
            type: "brush",
            mode: dragging ? "move" : "resize"
          });
        }
      }
      function move1(point, scale, i) {
        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], size = extent[1][i] - extent[0][i], min, max;
        if (dragging) {
          r0 -= position;
          r1 -= size + position;
        }
        min = Math.max(r0, Math.min(r1, point[i]));
        if (dragging) {
          max = (min += position) + size;
        } else {
          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
          if (position < min) {
            max = min;
            min = position;
          } else {
            max = position;
          }
        }
        if (extent[0][i] !== min || extent[1][i] !== max) {
          extentDomain = null;
          extent[0][i] = min;
          extent[1][i] = max;
          return true;
        }
      }
      function brushend() {
        brushmove();
        g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
        d3.select("body").style("cursor", null);
        w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
        event_({
          type: "brushend"
        });
        d3_eventCancel();
      }
    }
    brush.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.extent = function(z) {
      var x0, x1, y0, y1, t;
      if (!arguments.length) {
        z = extentDomain || extent;
        if (x) {
          x0 = z[0][0], x1 = z[1][0];
          if (!extentDomain) {
            x0 = extent[0][0], x1 = extent[1][0];
            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
            if (x1 < x0) t = x0, x0 = x1, x1 = t;
          }
        }
        if (y) {
          y0 = z[0][1], y1 = z[1][1];
          if (!extentDomain) {
            y0 = extent[0][1], y1 = extent[1][1];
            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
            if (y1 < y0) t = y0, y0 = y1, y1 = t;
          }
        }
        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];
      }
      extentDomain = [ [ 0, 0 ], [ 0, 0 ] ];
      if (x) {
        x0 = z[0], x1 = z[1];
        if (y) x0 = x0[0], x1 = x1[0];
        extentDomain[0][0] = x0, extentDomain[1][0] = x1;
        if (x.invert) x0 = x(x0), x1 = x(x1);
        if (x1 < x0) t = x0, x0 = x1, x1 = t;
        extent[0][0] = x0 | 0, extent[1][0] = x1 | 0;
      }
      if (y) {
        y0 = z[0], y1 = z[1];
        if (x) y0 = y0[1], y1 = y1[1];
        extentDomain[0][1] = y0, extentDomain[1][1] = y1;
        if (y.invert) y0 = y(y0), y1 = y(y1);
        if (y1 < y0) t = y0, y0 = y1, y1 = t;
        extent[0][1] = y0 | 0, extent[1][1] = y1 | 0;
      }
      return brush;
    };
    brush.clear = function() {
      extentDomain = null;
      extent[0][0] = extent[0][1] = extent[1][0] = extent[1][1] = 0;
      return brush;
    };
    brush.empty = function() {
      return x && extent[0][0] === extent[1][0] || y && extent[0][1] === extent[1][1];
    };
    return d3.rebind(brush, event, "on");
  };
  var d3_svg_brushCursor = {
    n: "ns-resize",
    e: "ew-resize",
    s: "ns-resize",
    w: "ew-resize",
    nw: "nwse-resize",
    ne: "nesw-resize",
    se: "nwse-resize",
    sw: "nesw-resize"
  };
  var d3_svg_brushResizes = [ [ "n", "e", "s", "w", "nw", "ne", "se", "sw" ], [ "e", "w" ], [ "n", "s" ], [] ];
  d3.behavior = {};
  d3.behavior.drag = function() {
    var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null;
    function drag() {
      this.on("mousedown.drag", mousedown).on("touchstart.drag", mousedown);
    }
    function mousedown() {
      var target = this, event_ = event.of(target, arguments), eventTarget = d3.event.target, touchId = d3.event.touches ? d3.event.changedTouches[0].identifier : null, offset, origin_ = point(), moved = 0;
      var w = d3.select(d3_window).on(touchId != null ? "touchmove.drag-" + touchId : "mousemove.drag", dragmove).on(touchId != null ? "touchend.drag-" + touchId : "mouseup.drag", dragend, true);
      if (origin) {
        offset = origin.apply(target, arguments);
        offset = [ offset.x - origin_[0], offset.y - origin_[1] ];
      } else {
        offset = [ 0, 0 ];
      }
      if (touchId == null) d3_eventCancel();
      event_({
        type: "dragstart"
      });
      function point() {
        var p = target.parentNode;
        return touchId != null ? d3.touches(p).filter(function(p) {
          return p.identifier === touchId;
        })[0] : d3.mouse(p);
      }
      function dragmove() {
        if (!target.parentNode) return dragend();
        var p = point(), dx = p[0] - origin_[0], dy = p[1] - origin_[1];
        moved |= dx | dy;
        origin_ = p;
        d3_eventCancel();
        event_({
          type: "drag",
          x: p[0] + offset[0],
          y: p[1] + offset[1],
          dx: dx,
          dy: dy
        });
      }
      function dragend() {
        event_({
          type: "dragend"
        });
        if (moved) {
          d3_eventCancel();
          if (d3.event.target === eventTarget) w.on("click.drag", click, true);
        }
        w.on(touchId != null ? "touchmove.drag-" + touchId : "mousemove.drag", null).on(touchId != null ? "touchend.drag-" + touchId : "mouseup.drag", null);
      }
      function click() {
        d3_eventCancel();
        w.on("click.drag", null);
      }
    }
    drag.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return drag;
    };
    return d3.rebind(drag, event, "on");
  };
  d3.behavior.zoom = function() {
    var translate = [ 0, 0 ], translate0, scale = 1, scale0, scaleExtent = d3_behavior_zoomInfinity, event = d3_eventDispatch(zoom, "zoom"), x0, x1, y0, y1, touchtime;
    function zoom() {
      this.on("mousedown.zoom", mousedown).on("mousemove.zoom", mousemove).on(d3_behavior_zoomWheel + ".zoom", mousewheel).on("dblclick.zoom", dblclick).on("touchstart.zoom", touchstart).on("touchmove.zoom", touchmove).on("touchend.zoom", touchstart);
    }
    zoom.translate = function(x) {
      if (!arguments.length) return translate;
      translate = x.map(Number);
      rescale();
      return zoom;
    };
    zoom.scale = function(x) {
      if (!arguments.length) return scale;
      scale = +x;
      rescale();
      return zoom;
    };
    zoom.scaleExtent = function(x) {
      if (!arguments.length) return scaleExtent;
      scaleExtent = x == null ? d3_behavior_zoomInfinity : x.map(Number);
      return zoom;
    };
    zoom.x = function(z) {
      if (!arguments.length) return x1;
      x1 = z;
      x0 = z.copy();
      translate = [ 0, 0 ];
      scale = 1;
      return zoom;
    };
    zoom.y = function(z) {
      if (!arguments.length) return y1;
      y1 = z;
      y0 = z.copy();
      translate = [ 0, 0 ];
      scale = 1;
      return zoom;
    };
    function location(p) {
      return [ (p[0] - translate[0]) / scale, (p[1] - translate[1]) / scale ];
    }
    function point(l) {
      return [ l[0] * scale + translate[0], l[1] * scale + translate[1] ];
    }
    function scaleTo(s) {
      scale = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
    }
    function translateTo(p, l) {
      l = point(l);
      translate[0] += p[0] - l[0];
      translate[1] += p[1] - l[1];
    }
    function rescale() {
      if (x1) x1.domain(x0.range().map(function(x) {
        return (x - translate[0]) / scale;
      }).map(x0.invert));
      if (y1) y1.domain(y0.range().map(function(y) {
        return (y - translate[1]) / scale;
      }).map(y0.invert));
    }
    function dispatch(event) {
      rescale();
      d3.event.preventDefault();
      event({
        type: "zoom",
        scale: scale,
        translate: translate
      });
    }
    function mousedown() {
      var target = this, event_ = event.of(target, arguments), eventTarget = d3.event.target, moved = 0, w = d3.select(d3_window).on("mousemove.zoom", mousemove).on("mouseup.zoom", mouseup), l = location(d3.mouse(target));
      d3_window.focus();
      d3_eventCancel();
      function mousemove() {
        moved = 1;
        translateTo(d3.mouse(target), l);
        dispatch(event_);
      }
      function mouseup() {
        if (moved) d3_eventCancel();
        w.on("mousemove.zoom", null).on("mouseup.zoom", null);
        if (moved && d3.event.target === eventTarget) w.on("click.zoom", click, true);
      }
      function click() {
        d3_eventCancel();
        w.on("click.zoom", null);
      }
    }
    function mousewheel() {
      if (!translate0) translate0 = location(d3.mouse(this));
      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * scale);
      translateTo(d3.mouse(this), translate0);
      dispatch(event.of(this, arguments));
    }
    function mousemove() {
      translate0 = null;
    }
    function dblclick() {
      var p = d3.mouse(this), l = location(p), k = Math.log(scale) / Math.LN2;
      scaleTo(Math.pow(2, d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1));
      translateTo(p, l);
      dispatch(event.of(this, arguments));
    }
    function touchstart() {
      var touches = d3.touches(this), now = Date.now();
      scale0 = scale;
      translate0 = {};
      touches.forEach(function(t) {
        translate0[t.identifier] = location(t);
      });
      d3_eventCancel();
      if (touches.length === 1) {
        if (now - touchtime < 500) {
          var p = touches[0], l = location(touches[0]);
          scaleTo(scale * 2);
          translateTo(p, l);
          dispatch(event.of(this, arguments));
        }
        touchtime = now;
      }
    }
    function touchmove() {
      var touches = d3.touches(this), p0 = touches[0], l0 = translate0[p0.identifier];
      if (p1 = touches[1]) {
        var p1, l1 = translate0[p1.identifier];
        p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];
        l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];
        scaleTo(d3.event.scale * scale0);
      }
      translateTo(p0, l0);
      touchtime = null;
      dispatch(event.of(this, arguments));
    }
    return d3.rebind(zoom, event, "on");
  };
  var d3_behavior_zoomInfinity = [ 0, Infinity ];
  var d3_behavior_zoomDelta, d3_behavior_zoomWheel = "onwheel" in document ? (d3_behavior_zoomDelta = function() {
    return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
  }, "wheel") : "onmousewheel" in document ? (d3_behavior_zoomDelta = function() {
    return d3.event.wheelDelta;
  }, "mousewheel") : (d3_behavior_zoomDelta = function() {
    return -d3.event.detail;
  }, "MozMousePixelScroll");
  d3.layout = {};
  d3.layout.bundle = function() {
    return function(links) {
      var paths = [], i = -1, n = links.length;
      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
      return paths;
    };
  };
  function d3_layout_bundlePath(link) {
    var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];
    while (start !== lca) {
      start = start.parent;
      points.push(start);
    }
    var k = points.length;
    while (end !== lca) {
      points.splice(k, 0, end);
      end = end.parent;
    }
    return points;
  }
  function d3_layout_bundleAncestors(node) {
    var ancestors = [], parent = node.parent;
    while (parent != null) {
      ancestors.push(node);
      node = parent;
      parent = parent.parent;
    }
    ancestors.push(node);
    return ancestors;
  }
  function d3_layout_bundleLeastCommonAncestor(a, b) {
    if (a === b) return a;
    var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
    while (aNode === bNode) {
      sharedNode = aNode;
      aNode = aNodes.pop();
      bNode = bNodes.pop();
    }
    return sharedNode;
  }
  d3.layout.chord = function() {
    var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
    function relayout() {
      var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
      chords = [];
      groups = [];
      k = 0, i = -1;
      while (++i < n) {
        x = 0, j = -1;
        while (++j < n) {
          x += matrix[i][j];
        }
        groupSums.push(x);
        subgroupIndex.push(d3.range(n));
        k += x;
      }
      if (sortGroups) {
        groupIndex.sort(function(a, b) {
          return sortGroups(groupSums[a], groupSums[b]);
        });
      }
      if (sortSubgroups) {
        subgroupIndex.forEach(function(d, i) {
          d.sort(function(a, b) {
            return sortSubgroups(matrix[i][a], matrix[i][b]);
          });
        });
      }
      k = (2 * π - padding * n) / k;
      x = 0, i = -1;
      while (++i < n) {
        x0 = x, j = -1;
        while (++j < n) {
          var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
          subgroups[di + "-" + dj] = {
            index: di,
            subindex: dj,
            startAngle: a0,
            endAngle: a1,
            value: v
          };
        }
        groups[di] = {
          index: di,
          startAngle: x0,
          endAngle: x,
          value: (x - x0) / k
        };
        x += padding;
      }
      i = -1;
      while (++i < n) {
        j = i - 1;
        while (++j < n) {
          var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
          if (source.value || target.value) {
            chords.push(source.value < target.value ? {
              source: target,
              target: source
            } : {
              source: source,
              target: target
            });
          }
        }
      }
      if (sortChords) resort();
    }
    function resort() {
      chords.sort(function(a, b) {
        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
      });
    }
    chord.matrix = function(x) {
      if (!arguments.length) return matrix;
      n = (matrix = x) && matrix.length;
      chords = groups = null;
      return chord;
    };
    chord.padding = function(x) {
      if (!arguments.length) return padding;
      padding = x;
      chords = groups = null;
      return chord;
    };
    chord.sortGroups = function(x) {
      if (!arguments.length) return sortGroups;
      sortGroups = x;
      chords = groups = null;
      return chord;
    };
    chord.sortSubgroups = function(x) {
      if (!arguments.length) return sortSubgroups;
      sortSubgroups = x;
      chords = null;
      return chord;
    };
    chord.sortChords = function(x) {
      if (!arguments.length) return sortChords;
      sortChords = x;
      if (chords) resort();
      return chord;
    };
    chord.chords = function() {
      if (!chords) relayout();
      return chords;
    };
    chord.groups = function() {
      if (!groups) relayout();
      return groups;
    };
    return chord;
  };
  d3.layout.force = function() {
    var force = {}, event = d3.dispatch("start", "tick", "end"), size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, gravity = .1, theta = .8, nodes = [], links = [], distances, strengths, charges;
    function repulse(node) {
      return function(quad, x1, _, x2) {
        if (quad.point !== node) {
          var dx = quad.cx - node.x, dy = quad.cy - node.y, dn = 1 / Math.sqrt(dx * dx + dy * dy);
          if ((x2 - x1) * dn < theta) {
            var k = quad.charge * dn * dn;
            node.px -= dx * k;
            node.py -= dy * k;
            return true;
          }
          if (quad.point && isFinite(dn)) {
            var k = quad.pointCharge * dn * dn;
            node.px -= dx * k;
            node.py -= dy * k;
          }
        }
        return !quad.charge;
      };
    }
    force.tick = function() {
      if ((alpha *= .99) < .005) {
        event.end({
          type: "end",
          alpha: alpha = 0
        });
        return true;
      }
      var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
      for (i = 0; i < m; ++i) {
        o = links[i];
        s = o.source;
        t = o.target;
        x = t.x - s.x;
        y = t.y - s.y;
        if (l = x * x + y * y) {
          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
          x *= l;
          y *= l;
          t.x -= x * (k = s.weight / (t.weight + s.weight));
          t.y -= y * k;
          s.x += x * (k = 1 - k);
          s.y += y * k;
        }
      }
      if (k = alpha * gravity) {
        x = size[0] / 2;
        y = size[1] / 2;
        i = -1;
        if (k) while (++i < n) {
          o = nodes[i];
          o.x += (x - o.x) * k;
          o.y += (y - o.y) * k;
        }
      }
      if (charge) {
        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
        i = -1;
        while (++i < n) {
          if (!(o = nodes[i]).fixed) {
            q.visit(repulse(o));
          }
        }
      }
      i = -1;
      while (++i < n) {
        o = nodes[i];
        if (o.fixed) {
          o.x = o.px;
          o.y = o.py;
        } else {
          o.x -= (o.px - (o.px = o.x)) * friction;
          o.y -= (o.py - (o.py = o.y)) * friction;
        }
      }
      event.tick({
        type: "tick",
        alpha: alpha
      });
    };
    force.nodes = function(x) {
      if (!arguments.length) return nodes;
      nodes = x;
      return force;
    };
    force.links = function(x) {
      if (!arguments.length) return links;
      links = x;
      return force;
    };
    force.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return force;
    };
    force.linkDistance = function(x) {
      if (!arguments.length) return linkDistance;
      linkDistance = typeof x === "function" ? x : +x;
      return force;
    };
    force.distance = force.linkDistance;
    force.linkStrength = function(x) {
      if (!arguments.length) return linkStrength;
      linkStrength = typeof x === "function" ? x : +x;
      return force;
    };
    force.friction = function(x) {
      if (!arguments.length) return friction;
      friction = +x;
      return force;
    };
    force.charge = function(x) {
      if (!arguments.length) return charge;
      charge = typeof x === "function" ? x : +x;
      return force;
    };
    force.gravity = function(x) {
      if (!arguments.length) return gravity;
      gravity = +x;
      return force;
    };
    force.theta = function(x) {
      if (!arguments.length) return theta;
      theta = +x;
      return force;
    };
    force.alpha = function(x) {
      if (!arguments.length) return alpha;
      x = +x;
      if (alpha) {
        if (x > 0) alpha = x; else alpha = 0;
      } else if (x > 0) {
        event.start({
          type: "start",
          alpha: alpha = x
        });
        d3.timer(force.tick);
      }
      return force;
    };
    force.start = function() {
      var i, j, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
      for (i = 0; i < n; ++i) {
        (o = nodes[i]).index = i;
        o.weight = 0;
      }
      for (i = 0; i < m; ++i) {
        o = links[i];
        if (typeof o.source == "number") o.source = nodes[o.source];
        if (typeof o.target == "number") o.target = nodes[o.target];
        ++o.source.weight;
        ++o.target.weight;
      }
      for (i = 0; i < n; ++i) {
        o = nodes[i];
        if (isNaN(o.x)) o.x = position("x", w);
        if (isNaN(o.y)) o.y = position("y", h);
        if (isNaN(o.px)) o.px = o.x;
        if (isNaN(o.py)) o.py = o.y;
      }
      distances = [];
      if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;
      strengths = [];
      if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
      charges = [];
      if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;
      function position(dimension, size) {
        var neighbors = neighbor(i), j = -1, m = neighbors.length, x;
        while (++j < m) if (!isNaN(x = neighbors[j][dimension])) return x;
        return Math.random() * size;
      }
      function neighbor() {
        if (!neighbors) {
          neighbors = [];
          for (j = 0; j < n; ++j) {
            neighbors[j] = [];
          }
          for (j = 0; j < m; ++j) {
            var o = links[j];
            neighbors[o.source.index].push(o.target);
            neighbors[o.target.index].push(o.source);
          }
        }
        return neighbors[i];
      }
      return force.resume();
    };
    force.resume = function() {
      return force.alpha(.1);
    };
    force.stop = function() {
      return force.alpha(0);
    };
    force.drag = function() {
      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
      if (!arguments.length) return drag;
      this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
    };
    function dragmove(d) {
      d.px = d3.event.x, d.py = d3.event.y;
      force.resume();
    }
    return d3.rebind(force, event, "on");
  };
  function d3_layout_forceDragstart(d) {
    d.fixed |= 2;
  }
  function d3_layout_forceDragend(d) {
    d.fixed &= ~6;
  }
  function d3_layout_forceMouseover(d) {
    d.fixed |= 4;
    d.px = d.x, d.py = d.y;
  }
  function d3_layout_forceMouseout(d) {
    d.fixed &= ~4;
  }
  function d3_layout_forceAccumulate(quad, alpha, charges) {
    var cx = 0, cy = 0;
    quad.charge = 0;
    if (!quad.leaf) {
      var nodes = quad.nodes, n = nodes.length, i = -1, c;
      while (++i < n) {
        c = nodes[i];
        if (c == null) continue;
        d3_layout_forceAccumulate(c, alpha, charges);
        quad.charge += c.charge;
        cx += c.charge * c.cx;
        cy += c.charge * c.cy;
      }
    }
    if (quad.point) {
      if (!quad.leaf) {
        quad.point.x += Math.random() - .5;
        quad.point.y += Math.random() - .5;
      }
      var k = alpha * charges[quad.point.index];
      quad.charge += quad.pointCharge = k;
      cx += k * quad.point.x;
      cy += k * quad.point.y;
    }
    quad.cx = cx / quad.charge;
    quad.cy = cy / quad.charge;
  }
  var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1;
  d3.layout.partition = function() {
    var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];
    function position(node, x, dx, dy) {
      var children = node.children;
      node.x = x;
      node.y = node.depth * dy;
      node.dx = dx;
      node.dy = dy;
      if (children && (n = children.length)) {
        var i = -1, n, c, d;
        dx = node.value ? dx / node.value : 0;
        while (++i < n) {
          position(c = children[i], x, d = c.value * dx, dy);
          x += d;
        }
      }
    }
    function depth(node) {
      var children = node.children, d = 0;
      if (children && (n = children.length)) {
        var i = -1, n;
        while (++i < n) d = Math.max(d, depth(children[i]));
      }
      return 1 + d;
    }
    function partition(d, i) {
      var nodes = hierarchy.call(this, d, i);
      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
      return nodes;
    }
    partition.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return partition;
    };
    return d3_layout_hierarchyRebind(partition, hierarchy);
  };
  d3.layout.pie = function() {
    var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = 2 * π;
    function pie(data) {
      var values = data.map(function(d, i) {
        return +value.call(pie, d, i);
      });
      var a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle);
      var k = ((typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - startAngle) / d3.sum(values);
      var index = d3.range(data.length);
      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
        return values[j] - values[i];
      } : function(i, j) {
        return sort(data[i], data[j]);
      });
      var arcs = [];
      index.forEach(function(i) {
        var d;
        arcs[i] = {
          data: data[i],
          value: d = values[i],
          startAngle: a,
          endAngle: a += d * k
        };
      });
      return arcs;
    }
    pie.value = function(x) {
      if (!arguments.length) return value;
      value = x;
      return pie;
    };
    pie.sort = function(x) {
      if (!arguments.length) return sort;
      sort = x;
      return pie;
    };
    pie.startAngle = function(x) {
      if (!arguments.length) return startAngle;
      startAngle = x;
      return pie;
    };
    pie.endAngle = function(x) {
      if (!arguments.length) return endAngle;
      endAngle = x;
      return pie;
    };
    return pie;
  };
  var d3_layout_pieSortByValue = {};
  d3.layout.stack = function() {
    var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
    function stack(data, index) {
      var series = data.map(function(d, i) {
        return values.call(stack, d, i);
      });
      var points = series.map(function(d) {
        return d.map(function(v, i) {
          return [ x.call(stack, v, i), y.call(stack, v, i) ];
        });
      });
      var orders = order.call(stack, points, index);
      series = d3.permute(series, orders);
      points = d3.permute(points, orders);
      var offsets = offset.call(stack, points, index);
      var n = series.length, m = series[0].length, i, j, o;
      for (j = 0; j < m; ++j) {
        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
        for (i = 1; i < n; ++i) {
          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
        }
      }
      return data;
    }
    stack.values = function(x) {
      if (!arguments.length) return values;
      values = x;
      return stack;
    };
    stack.order = function(x) {
      if (!arguments.length) return order;
      order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
      return stack;
    };
    stack.offset = function(x) {
      if (!arguments.length) return offset;
      offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
      return stack;
    };
    stack.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      return stack;
    };
    stack.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      return stack;
    };
    stack.out = function(z) {
      if (!arguments.length) return out;
      out = z;
      return stack;
    };
    return stack;
  };
  function d3_layout_stackX(d) {
    return d.x;
  }
  function d3_layout_stackY(d) {
    return d.y;
  }
  function d3_layout_stackOut(d, y0, y) {
    d.y0 = y0;
    d.y = y;
  }
  var d3_layout_stackOrders = d3.map({
    "inside-out": function(data) {
      var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
        return max[a] - max[b];
      }), top = 0, bottom = 0, tops = [], bottoms = [];
      for (i = 0; i < n; ++i) {
        j = index[i];
        if (top < bottom) {
          top += sums[j];
          tops.push(j);
        } else {
          bottom += sums[j];
          bottoms.push(j);
        }
      }
      return bottoms.reverse().concat(tops);
    },
    reverse: function(data) {
      return d3.range(data.length).reverse();
    },
    "default": d3_layout_stackOrderDefault
  });
  var d3_layout_stackOffsets = d3.map({
    silhouette: function(data) {
      var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o > max) max = o;
        sums.push(o);
      }
      for (j = 0; j < m; ++j) {
        y0[j] = (max - sums[j]) / 2;
      }
      return y0;
    },
    wiggle: function(data) {
      var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
      y0[0] = o = o0 = 0;
      for (j = 1; j < m; ++j) {
        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
          }
          s2 += s3 * data[i][j][1];
        }
        y0[j] = o -= s1 ? s2 / s1 * dx : 0;
        if (o < o0) o0 = o;
      }
      for (j = 0; j < m; ++j) y0[j] -= o0;
      return y0;
    },
    expand: function(data) {
      var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;
      }
      for (j = 0; j < m; ++j) y0[j] = 0;
      return y0;
    },
    zero: d3_layout_stackOffsetZero
  });
  function d3_layout_stackOrderDefault(data) {
    return d3.range(data.length);
  }
  function d3_layout_stackOffsetZero(data) {
    var j = -1, m = data[0].length, y0 = [];
    while (++j < m) y0[j] = 0;
    return y0;
  }
  function d3_layout_stackMaxIndex(array) {
    var i = 1, j = 0, v = array[0][1], k, n = array.length;
    for (;i < n; ++i) {
      if ((k = array[i][1]) > v) {
        j = i;
        v = k;
      }
    }
    return j;
  }
  function d3_layout_stackReduceSum(d) {
    return d.reduce(d3_layout_stackSum, 0);
  }
  function d3_layout_stackSum(p, d) {
    return p + d[1];
  }
  d3.layout.histogram = function() {
    var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
    function histogram(data, i) {
      var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
      while (++i < m) {
        bin = bins[i] = [];
        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
        bin.y = 0;
      }
      if (m > 0) {
        i = -1;
        while (++i < n) {
          x = values[i];
          if (x >= range[0] && x <= range[1]) {
            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
            bin.y += k;
            bin.push(data[i]);
          }
        }
      }
      return bins;
    }
    histogram.value = function(x) {
      if (!arguments.length) return valuer;
      valuer = x;
      return histogram;
    };
    histogram.range = function(x) {
      if (!arguments.length) return ranger;
      ranger = d3_functor(x);
      return histogram;
    };
    histogram.bins = function(x) {
      if (!arguments.length) return binner;
      binner = typeof x === "number" ? function(range) {
        return d3_layout_histogramBinFixed(range, x);
      } : d3_functor(x);
      return histogram;
    };
    histogram.frequency = function(x) {
      if (!arguments.length) return frequency;
      frequency = !!x;
      return histogram;
    };
    return histogram;
  };
  function d3_layout_histogramBinSturges(range, values) {
    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
  }
  function d3_layout_histogramBinFixed(range, n) {
    var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
    while (++x <= n) f[x] = m * x + b;
    return f;
  }
  function d3_layout_histogramRange(values) {
    return [ d3.min(values), d3.max(values) ];
  }
  d3.layout.hierarchy = function() {
    var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
    function recurse(node, depth, nodes) {
      var childs = children.call(hierarchy, node, depth);
      node.depth = depth;
      nodes.push(node);
      if (childs && (n = childs.length)) {
        var i = -1, n, c = node.children = [], v = 0, j = depth + 1, d;
        while (++i < n) {
          d = recurse(childs[i], j, nodes);
          d.parent = node;
          c.push(d);
          v += d.value;
        }
        if (sort) c.sort(sort);
        if (value) node.value = v;
      } else if (value) {
        node.value = +value.call(hierarchy, node, depth) || 0;
      }
      return node;
    }
    function revalue(node, depth) {
      var children = node.children, v = 0;
      if (children && (n = children.length)) {
        var i = -1, n, j = depth + 1;
        while (++i < n) v += revalue(children[i], j);
      } else if (value) {
        v = +value.call(hierarchy, node, depth) || 0;
      }
      if (value) node.value = v;
      return v;
    }
    function hierarchy(d) {
      var nodes = [];
      recurse(d, 0, nodes);
      return nodes;
    }
    hierarchy.sort = function(x) {
      if (!arguments.length) return sort;
      sort = x;
      return hierarchy;
    };
    hierarchy.children = function(x) {
      if (!arguments.length) return children;
      children = x;
      return hierarchy;
    };
    hierarchy.value = function(x) {
      if (!arguments.length) return value;
      value = x;
      return hierarchy;
    };
    hierarchy.revalue = function(root) {
      revalue(root, 0);
      return root;
    };
    return hierarchy;
  };
  function d3_layout_hierarchyRebind(object, hierarchy) {
    d3.rebind(object, hierarchy, "sort", "children", "value");
    object.nodes = object;
    object.links = d3_layout_hierarchyLinks;
    return object;
  }
  function d3_layout_hierarchyChildren(d) {
    return d.children;
  }
  function d3_layout_hierarchyValue(d) {
    return d.value;
  }
  function d3_layout_hierarchySort(a, b) {
    return b.value - a.value;
  }
  function d3_layout_hierarchyLinks(nodes) {
    return d3.merge(nodes.map(function(parent) {
      return (parent.children || []).map(function(child) {
        return {
          source: parent,
          target: child
        };
      });
    }));
  }
  d3.layout.pack = function() {
    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ];
    function pack(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0];
      root.x = 0;
      root.y = 0;
      d3_layout_treeVisitAfter(root, function(d) {
        d.r = Math.sqrt(d.value);
      });
      d3_layout_treeVisitAfter(root, d3_layout_packSiblings);
      var w = size[0], h = size[1], k = Math.max(2 * root.r / w, 2 * root.r / h);
      if (padding > 0) {
        var dr = padding * k / 2;
        d3_layout_treeVisitAfter(root, function(d) {
          d.r += dr;
        });
        d3_layout_treeVisitAfter(root, d3_layout_packSiblings);
        d3_layout_treeVisitAfter(root, function(d) {
          d.r -= dr;
        });
        k = Math.max(2 * root.r / w, 2 * root.r / h);
      }
      d3_layout_packTransform(root, w / 2, h / 2, 1 / k);
      return nodes;
    }
    pack.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return pack;
    };
    pack.padding = function(_) {
      if (!arguments.length) return padding;
      padding = +_;
      return pack;
    };
    return d3_layout_hierarchyRebind(pack, hierarchy);
  };
  function d3_layout_packSort(a, b) {
    return a.value - b.value;
  }
  function d3_layout_packInsert(a, b) {
    var c = a._pack_next;
    a._pack_next = b;
    b._pack_prev = a;
    b._pack_next = c;
    c._pack_prev = b;
  }
  function d3_layout_packSplice(a, b) {
    a._pack_next = b;
    b._pack_prev = a;
  }
  function d3_layout_packIntersects(a, b) {
    var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
    return dr * dr - dx * dx - dy * dy > .001;
  }
  function d3_layout_packSiblings(node) {
    if (!(nodes = node.children) || !(n = nodes.length)) return;
    var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
    function bound(node) {
      xMin = Math.min(node.x - node.r, xMin);
      xMax = Math.max(node.x + node.r, xMax);
      yMin = Math.min(node.y - node.r, yMin);
      yMax = Math.max(node.y + node.r, yMax);
    }
    nodes.forEach(d3_layout_packLink);
    a = nodes[0];
    a.x = -a.r;
    a.y = 0;
    bound(a);
    if (n > 1) {
      b = nodes[1];
      b.x = b.r;
      b.y = 0;
      bound(b);
      if (n > 2) {
        c = nodes[2];
        d3_layout_packPlace(a, b, c);
        bound(c);
        d3_layout_packInsert(a, c);
        a._pack_prev = c;
        d3_layout_packInsert(c, b);
        b = a._pack_next;
        for (i = 3; i < n; i++) {
          d3_layout_packPlace(a, b, c = nodes[i]);
          var isect = 0, s1 = 1, s2 = 1;
          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
            if (d3_layout_packIntersects(j, c)) {
              isect = 1;
              break;
            }
          }
          if (isect == 1) {
            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
              if (d3_layout_packIntersects(k, c)) {
                break;
              }
            }
          }
          if (isect) {
            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);
            i--;
          } else {
            d3_layout_packInsert(a, c);
            b = c;
            bound(c);
          }
        }
      }
    }
    var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
    for (i = 0; i < n; i++) {
      c = nodes[i];
      c.x -= cx;
      c.y -= cy;
      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
    }
    node.r = cr;
    nodes.forEach(d3_layout_packUnlink);
  }
  function d3_layout_packLink(node) {
    node._pack_next = node._pack_prev = node;
  }
  function d3_layout_packUnlink(node) {
    delete node._pack_next;
    delete node._pack_prev;
  }
  function d3_layout_packTransform(node, x, y, k) {
    var children = node.children;
    node.x = x += k * node.x;
    node.y = y += k * node.y;
    node.r *= k;
    if (children) {
      var i = -1, n = children.length;
      while (++i < n) d3_layout_packTransform(children[i], x, y, k);
    }
  }
  function d3_layout_packPlace(a, b, c) {
    var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
    if (db && (dx || dy)) {
      var da = b.r + c.r, dc = dx * dx + dy * dy;
      da *= da;
      db *= db;
      var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
      c.x = a.x + x * dx + y * dy;
      c.y = a.y + x * dy - y * dx;
    } else {
      c.x = a.x + db;
      c.y = a.y;
    }
  }
  d3.layout.cluster = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ];
    function cluster(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
      d3_layout_treeVisitAfter(root, function(node) {
        var children = node.children;
        if (children && children.length) {
          node.x = d3_layout_clusterX(children);
          node.y = d3_layout_clusterY(children);
        } else {
          node.x = previousNode ? x += separation(node, previousNode) : 0;
          node.y = 0;
          previousNode = node;
        }
      });
      var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
      d3_layout_treeVisitAfter(root, function(node) {
        node.x = (node.x - x0) / (x1 - x0) * size[0];
        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
      });
      return nodes;
    }
    cluster.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return cluster;
    };
    cluster.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return cluster;
    };
    return d3_layout_hierarchyRebind(cluster, hierarchy);
  };
  function d3_layout_clusterY(children) {
    return 1 + d3.max(children, function(child) {
      return child.y;
    });
  }
  function d3_layout_clusterX(children) {
    return children.reduce(function(x, child) {
      return x + child.x;
    }, 0) / children.length;
  }
  function d3_layout_clusterLeft(node) {
    var children = node.children;
    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
  }
  function d3_layout_clusterRight(node) {
    var children = node.children, n;
    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
  }
  d3.layout.tree = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ];
    function tree(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0];
      function firstWalk(node, previousSibling) {
        var children = node.children, layout = node._tree;
        if (children && (n = children.length)) {
          var n, firstChild = children[0], previousChild, ancestor = firstChild, child, i = -1;
          while (++i < n) {
            child = children[i];
            firstWalk(child, previousChild);
            ancestor = apportion(child, previousChild, ancestor);
            previousChild = child;
          }
          d3_layout_treeShift(node);
          var midpoint = .5 * (firstChild._tree.prelim + child._tree.prelim);
          if (previousSibling) {
            layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling);
            layout.mod = layout.prelim - midpoint;
          } else {
            layout.prelim = midpoint;
          }
        } else {
          if (previousSibling) {
            layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling);
          }
        }
      }
      function secondWalk(node, x) {
        node.x = node._tree.prelim + x;
        var children = node.children;
        if (children && (n = children.length)) {
          var i = -1, n;
          x += node._tree.mod;
          while (++i < n) {
            secondWalk(children[i], x);
          }
        }
      }
      function apportion(node, previousSibling, ancestor) {
        if (previousSibling) {
          var vip = node, vop = node, vim = previousSibling, vom = node.parent.children[0], sip = vip._tree.mod, sop = vop._tree.mod, sim = vim._tree.mod, som = vom._tree.mod, shift;
          while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
            vom = d3_layout_treeLeft(vom);
            vop = d3_layout_treeRight(vop);
            vop._tree.ancestor = node;
            shift = vim._tree.prelim + sim - vip._tree.prelim - sip + separation(vim, vip);
            if (shift > 0) {
              d3_layout_treeMove(d3_layout_treeAncestor(vim, node, ancestor), node, shift);
              sip += shift;
              sop += shift;
            }
            sim += vim._tree.mod;
            sip += vip._tree.mod;
            som += vom._tree.mod;
            sop += vop._tree.mod;
          }
          if (vim && !d3_layout_treeRight(vop)) {
            vop._tree.thread = vim;
            vop._tree.mod += sim - sop;
          }
          if (vip && !d3_layout_treeLeft(vom)) {
            vom._tree.thread = vip;
            vom._tree.mod += sip - som;
            ancestor = node;
          }
        }
        return ancestor;
      }
      d3_layout_treeVisitAfter(root, function(node, previousSibling) {
        node._tree = {
          ancestor: node,
          prelim: 0,
          mod: 0,
          change: 0,
          shift: 0,
          number: previousSibling ? previousSibling._tree.number + 1 : 0
        };
      });
      firstWalk(root);
      secondWalk(root, -root._tree.prelim);
      var left = d3_layout_treeSearch(root, d3_layout_treeLeftmost), right = d3_layout_treeSearch(root, d3_layout_treeRightmost), deep = d3_layout_treeSearch(root, d3_layout_treeDeepest), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2, y1 = deep.depth || 1;
      d3_layout_treeVisitAfter(root, function(node) {
        node.x = (node.x - x0) / (x1 - x0) * size[0];
        node.y = node.depth / y1 * size[1];
        delete node._tree;
      });
      return nodes;
    }
    tree.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return tree;
    };
    tree.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return tree;
    };
    return d3_layout_hierarchyRebind(tree, hierarchy);
  };
  function d3_layout_treeSeparation(a, b) {
    return a.parent == b.parent ? 1 : 2;
  }
  function d3_layout_treeLeft(node) {
    var children = node.children;
    return children && children.length ? children[0] : node._tree.thread;
  }
  function d3_layout_treeRight(node) {
    var children = node.children, n;
    return children && (n = children.length) ? children[n - 1] : node._tree.thread;
  }
  function d3_layout_treeSearch(node, compare) {
    var children = node.children;
    if (children && (n = children.length)) {
      var child, n, i = -1;
      while (++i < n) {
        if (compare(child = d3_layout_treeSearch(children[i], compare), node) > 0) {
          node = child;
        }
      }
    }
    return node;
  }
  function d3_layout_treeRightmost(a, b) {
    return a.x - b.x;
  }
  function d3_layout_treeLeftmost(a, b) {
    return b.x - a.x;
  }
  function d3_layout_treeDeepest(a, b) {
    return a.depth - b.depth;
  }
  function d3_layout_treeVisitAfter(node, callback) {
    function visit(node, previousSibling) {
      var children = node.children;
      if (children && (n = children.length)) {
        var child, previousChild = null, i = -1, n;
        while (++i < n) {
          child = children[i];
          visit(child, previousChild);
          previousChild = child;
        }
      }
      callback(node, previousSibling);
    }
    visit(node, null);
  }
  function d3_layout_treeShift(node) {
    var shift = 0, change = 0, children = node.children, i = children.length, child;
    while (--i >= 0) {
      child = children[i]._tree;
      child.prelim += shift;
      child.mod += shift;
      shift += child.shift + (change += child.change);
    }
  }
  function d3_layout_treeMove(ancestor, node, shift) {
    ancestor = ancestor._tree;
    node = node._tree;
    var change = shift / (node.number - ancestor.number);
    ancestor.change += change;
    node.change -= change;
    node.shift += shift;
    node.prelim += shift;
    node.mod += shift;
  }
  function d3_layout_treeAncestor(vim, node, ancestor) {
    return vim._tree.ancestor.parent == node.parent ? vim._tree.ancestor : ancestor;
  }
  d3.layout.treemap = function() {
    var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
    function scale(children, k) {
      var i = -1, n = children.length, child, area;
      while (++i < n) {
        area = (child = children[i]).value * (k < 0 ? 0 : k);
        child.area = isNaN(area) || area <= 0 ? 0 : area;
      }
    }
    function squarify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while ((n = remaining.length) > 0) {
          row.push(child = remaining[n - 1]);
          row.area += child.area;
          if (mode !== "squarify" || (score = worst(row, u)) <= best) {
            remaining.pop();
            best = score;
          } else {
            row.area -= row.pop().area;
            position(row, u, rect, false);
            u = Math.min(rect.dx, rect.dy);
            row.length = row.area = 0;
            best = Infinity;
          }
        }
        if (row.length) {
          position(row, u, rect, true);
          row.length = row.area = 0;
        }
        children.forEach(squarify);
      }
    }
    function stickify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), remaining = children.slice(), child, row = [];
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while (child = remaining.pop()) {
          row.push(child);
          row.area += child.area;
          if (child.z != null) {
            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
            row.length = row.area = 0;
          }
        }
        children.forEach(stickify);
      }
    }
    function worst(row, u) {
      var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
      while (++i < n) {
        if (!(r = row[i].area)) continue;
        if (r < rmin) rmin = r;
        if (r > rmax) rmax = r;
      }
      s *= s;
      u *= u;
      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
    }
    function position(row, u, rect, flush) {
      var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
      if (u == rect.dx) {
        if (flush || v > rect.dy) v = rect.dy;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dy = v;
          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
        }
        o.z = true;
        o.dx += rect.x + rect.dx - x;
        rect.y += v;
        rect.dy -= v;
      } else {
        if (flush || v > rect.dx) v = rect.dx;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dx = v;
          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
        }
        o.z = false;
        o.dy += rect.y + rect.dy - y;
        rect.x += v;
        rect.dx -= v;
      }
    }
    function treemap(d) {
      var nodes = stickies || hierarchy(d), root = nodes[0];
      root.x = 0;
      root.y = 0;
      root.dx = size[0];
      root.dy = size[1];
      if (stickies) hierarchy.revalue(root);
      scale([ root ], root.dx * root.dy / root.value);
      (stickies ? stickify : squarify)(root);
      if (sticky) stickies = nodes;
      return nodes;
    }
    treemap.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return treemap;
    };
    treemap.padding = function(x) {
      if (!arguments.length) return padding;
      function padFunction(node) {
        var p = x.call(treemap, node, node.depth);
        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
      }
      function padConstant(node) {
        return d3_layout_treemapPad(node, x);
      }
      var type;
      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ], 
      padConstant) : padConstant;
      return treemap;
    };
    treemap.round = function(x) {
      if (!arguments.length) return round != Number;
      round = x ? Math.round : Number;
      return treemap;
    };
    treemap.sticky = function(x) {
      if (!arguments.length) return sticky;
      sticky = x;
      stickies = null;
      return treemap;
    };
    treemap.ratio = function(x) {
      if (!arguments.length) return ratio;
      ratio = x;
      return treemap;
    };
    treemap.mode = function(x) {
      if (!arguments.length) return mode;
      mode = x + "";
      return treemap;
    };
    return d3_layout_hierarchyRebind(treemap, hierarchy);
  };
  function d3_layout_treemapPadNull(node) {
    return {
      x: node.x,
      y: node.y,
      dx: node.dx,
      dy: node.dy
    };
  }
  function d3_layout_treemapPad(node, padding) {
    var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
    if (dx < 0) {
      x += dx / 2;
      dx = 0;
    }
    if (dy < 0) {
      y += dy / 2;
      dy = 0;
    }
    return {
      x: x,
      y: y,
      dx: dx,
      dy: dy
    };
  }
  d3.layout.voronoi = function() {
    var size = null, x = d3_svg_lineX, y = d3_svg_lineY, clip;
    function voronoi(data) {
      var points = [], cells, fx = d3_functor(x), fy = d3_functor(y), d, i, n = data.length;
      for (i = 0; i < n; ++i) points.push([ +fx.call(this, d = data[i], i), +fy.call(this, d, i) ]);
      cells = d3.geom.voronoi(points);
      for (i = 0; i < n; ++i) cells[i].data = data[i];
      if (clip) for (i = 0; i < n; ++i) clip(cells[i]);
      return cells;
    }
    voronoi.x = function(_) {
      return arguments.length ? (x = _, voronoi) : x;
    };
    voronoi.y = function(_) {
      return arguments.length ? (y = _, voronoi) : y;
    };
    voronoi.size = function(_) {
      if (!arguments.length) return size;
      if (_ == null) {
        clip = null;
      } else {
        var w = +_[0], h = +_[1];
        clip = d3.geom.polygon([ [ 0, 0 ], [ 0, h ], [ w, h ], [ w, 0 ] ]).clip;
      }
      return voronoi;
    };
    return voronoi;
  };
  function d3_dsv(delimiter, mimeType) {
    var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
    function dsv(url, row, callback) {
      if (arguments.length < 3) callback = row, row = null;
      var xhr = d3.xhr(url, mimeType, callback);
      xhr.row = function(_) {
        return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
      };
      return xhr.row(row);
    }
    function response(request) {
      return dsv.parse(request.responseText);
    }
    function typedResponse(f) {
      return function(request) {
        return dsv.parse(request.responseText, f);
      };
    }
    dsv.parse = function(text, f) {
      var o;
      return dsv.parseRows(text, function(row, i) {
        if (o) return o(row, i - 1);
        var a = new Function("d", "return {" + row.map(function(name, i) {
          return JSON.stringify(name) + ": d[" + i + "]";
        }).join(",") + "}");
        o = f ? function(row, i) {
          return f(a(row), i);
        } : a;
      });
    };
    dsv.parseRows = function(text, f) {
      var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
      function token() {
        if (I >= N) return EOF;
        if (eol) return eol = false, EOL;
        var j = I;
        if (text.charCodeAt(j) === 34) {
          var i = j;
          while (i++ < N) {
            if (text.charCodeAt(i) === 34) {
              if (text.charCodeAt(i + 1) !== 34) break;
              ++i;
            }
          }
          I = i + 2;
          var c = text.charCodeAt(i + 1);
          if (c === 13) {
            eol = true;
            if (text.charCodeAt(i + 2) === 10) ++I;
          } else if (c === 10) {
            eol = true;
          }
          return text.substring(j + 1, i).replace(/""/g, '"');
        }
        while (I < N) {
          var c = text.charCodeAt(I++), k = 1;
          if (c === 10) eol = true; else if (c === 13) {
            eol = true;
            if (text.charCodeAt(I) === 10) ++I, ++k;
          } else if (c !== delimiterCode) continue;
          return text.substring(j, I - k);
        }
        return text.substring(j);
      }
      while ((t = token()) !== EOF) {
        var a = [];
        while (t !== EOL && t !== EOF) {
          a.push(t);
          t = token();
        }
        if (f && !(a = f(a, n++))) continue;
        rows.push(a);
      }
      return rows;
    };
    dsv.format = function(rows) {
      if (Array.isArray(rows[0])) return dsv.formatRows(rows);
      var fieldSet = new d3_Set(), fields = [];
      rows.forEach(function(row) {
        for (var field in row) {
          if (!fieldSet.has(field)) {
            fields.push(fieldSet.add(field));
          }
        }
      });
      return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {
        return fields.map(function(field) {
          return formatValue(row[field]);
        }).join(delimiter);
      })).join("\n");
    };
    dsv.formatRows = function(rows) {
      return rows.map(formatRow).join("\n");
    };
    function formatRow(row) {
      return row.map(formatValue).join(delimiter);
    }
    function formatValue(text) {
      return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
    }
    return dsv;
  }
  d3.csv = d3_dsv(",", "text/csv");
  d3.tsv = d3_dsv("	", "text/tab-separated-values");
  d3.geo = {};
  d3.geo.stream = function(object, listener) {
    if (d3_geo_streamObjectType.hasOwnProperty(object.type)) {
      d3_geo_streamObjectType[object.type](object, listener);
    } else {
      d3_geo_streamGeometry(object, listener);
    }
  };
  function d3_geo_streamGeometry(geometry, listener) {
    if (d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
      d3_geo_streamGeometryType[geometry.type](geometry, listener);
    }
  }
  var d3_geo_streamObjectType = {
    Feature: function(feature, listener) {
      d3_geo_streamGeometry(feature.geometry, listener);
    },
    FeatureCollection: function(object, listener) {
      var features = object.features, i = -1, n = features.length;
      while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);
    }
  };
  var d3_geo_streamGeometryType = {
    Sphere: function(object, listener) {
      listener.sphere();
    },
    Point: function(object, listener) {
      var coordinate = object.coordinates;
      listener.point(coordinate[0], coordinate[1]);
    },
    MultiPoint: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length, coordinate;
      while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1]);
    },
    LineString: function(object, listener) {
      d3_geo_streamLine(object.coordinates, listener, 0);
    },
    MultiLineString: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);
    },
    Polygon: function(object, listener) {
      d3_geo_streamPolygon(object.coordinates, listener);
    },
    MultiPolygon: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);
    },
    GeometryCollection: function(object, listener) {
      var geometries = object.geometries, i = -1, n = geometries.length;
      while (++i < n) d3_geo_streamGeometry(geometries[i], listener);
    }
  };
  function d3_geo_streamLine(coordinates, listener, closed) {
    var i = -1, n = coordinates.length - closed, coordinate;
    listener.lineStart();
    while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1]);
    listener.lineEnd();
  }
  function d3_geo_streamPolygon(coordinates, listener) {
    var i = -1, n = coordinates.length;
    listener.polygonStart();
    while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);
    listener.polygonEnd();
  }
  function d3_geo_spherical(cartesian) {
    return [ Math.atan2(cartesian[1], cartesian[0]), Math.asin(Math.max(-1, Math.min(1, cartesian[2]))) ];
  }
  function d3_geo_sphericalEqual(a, b) {
    return Math.abs(a[0] - b[0]) < ε && Math.abs(a[1] - b[1]) < ε;
  }
  function d3_geo_cartesian(spherical) {
    var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ);
    return [ cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ) ];
  }
  function d3_geo_cartesianDot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  function d3_geo_cartesianCross(a, b) {
    return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
  }
  function d3_geo_cartesianAdd(a, b) {
    a[0] += b[0];
    a[1] += b[1];
    a[2] += b[2];
  }
  function d3_geo_cartesianScale(vector, k) {
    return [ vector[0] * k, vector[1] * k, vector[2] * k ];
  }
  function d3_geo_cartesianNormalize(d) {
    var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
    d[0] /= l;
    d[1] /= l;
    d[2] /= l;
  }
  d3.geo.distance = function(a, b) {
    var Δλ = (b[0] - a[0]) * d3_radians, φ0 = a[1] * d3_radians, φ1 = b[1] * d3_radians, sinΔλ = Math.sin(Δλ), cosΔλ = Math.cos(Δλ), sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1), t;
    return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);
  };
  function d3_geo_resample(project) {
    var δ2 = .5, maxDepth = 16;
    function resample(stream) {
      var λ0, x0, y0, a0, b0, c0;
      var resample = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          stream.polygonStart();
          resample.lineStart = polygonLineStart;
        },
        polygonEnd: function() {
          stream.polygonEnd();
          resample.lineStart = lineStart;
        }
      };
      function point(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      }
      function lineStart() {
        x0 = NaN;
        resample.point = linePoint;
        stream.lineStart();
      }
      function linePoint(λ, φ) {
        var c = d3_geo_cartesian([ λ, φ ]), p = project(λ, φ);
        resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
        stream.point(x0, y0);
      }
      function lineEnd() {
        resample.point = point;
        stream.lineEnd();
      }
      function polygonLineStart() {
        var λ00, φ00, x00, y00, a00, b00, c00;
        lineStart();
        resample.point = function(λ, φ) {
          linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
          resample.point = linePoint;
        };
        resample.lineEnd = function() {
          resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);
          resample.lineEnd = lineEnd;
          lineEnd();
        };
      }
      return resample;
    }
    function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {
      var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
      if (d2 > 4 * δ2 && depth--) {
        var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), φ2 = Math.asin(c /= m), λ2 = Math.abs(Math.abs(c) - 1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a), p = project(λ2, φ2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
        if (dz * dz / d2 > δ2 || Math.abs((dx * dx2 + dy * dy2) / d2 - .5) > .3) {
          resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);
          stream.point(x2, y2);
          resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);
        }
      }
    }
    resample.precision = function(_) {
      if (!arguments.length) return Math.sqrt(δ2);
      maxDepth = (δ2 = _ * _) > 0 && 16;
      return resample;
    };
    return resample;
  }
  d3.geo.albersUsa = function() {
    var lower48 = d3.geo.albers();
    var alaska = d3.geo.albers().rotate([ 160, 0 ]).center([ 0, 60 ]).parallels([ 55, 65 ]);
    var hawaii = d3.geo.albers().rotate([ 160, 0 ]).center([ 0, 20 ]).parallels([ 8, 18 ]);
    var puertoRico = d3.geo.albers().rotate([ 60, 0 ]).center([ 0, 10 ]).parallels([ 8, 18 ]);
    var alaskaInvert, hawaiiInvert, puertoRicoInvert;
    function albersUsa(coordinates) {
      return projection(coordinates)(coordinates);
    }
    function projection(point) {
      var lon = point[0], lat = point[1];
      return lat > 50 ? alaska : lon < -140 ? hawaii : lat < 21 ? puertoRico : lower48;
    }
    albersUsa.invert = function(coordinates) {
      return alaskaInvert(coordinates) || hawaiiInvert(coordinates) || puertoRicoInvert(coordinates) || lower48.invert(coordinates);
    };
    albersUsa.scale = function(x) {
      if (!arguments.length) return lower48.scale();
      lower48.scale(x);
      alaska.scale(x * .6);
      hawaii.scale(x);
      puertoRico.scale(x * 1.5);
      return albersUsa.translate(lower48.translate());
    };
    albersUsa.translate = function(x) {
      if (!arguments.length) return lower48.translate();
      var dz = lower48.scale(), dx = x[0], dy = x[1];
      lower48.translate(x);
      alaska.translate([ dx - .4 * dz, dy + .17 * dz ]);
      hawaii.translate([ dx - .19 * dz, dy + .2 * dz ]);
      puertoRico.translate([ dx + .58 * dz, dy + .43 * dz ]);
      alaskaInvert = d3_geo_albersUsaInvert(alaska, [ [ -180, 50 ], [ -130, 72 ] ]);
      hawaiiInvert = d3_geo_albersUsaInvert(hawaii, [ [ -164, 18 ], [ -154, 24 ] ]);
      puertoRicoInvert = d3_geo_albersUsaInvert(puertoRico, [ [ -67.5, 17.5 ], [ -65, 19 ] ]);
      return albersUsa;
    };
    return albersUsa.scale(lower48.scale());
  };
  function d3_geo_albersUsaInvert(projection, extent) {
    var a = projection(extent[0]), b = projection([ .5 * (extent[0][0] + extent[1][0]), extent[0][1] ]), c = projection([ extent[1][0], extent[0][1] ]), d = projection(extent[1]);
    var dya = b[1] - a[1], dxa = b[0] - a[0], dyb = c[1] - b[1], dxb = c[0] - b[0];
    var ma = dya / dxa, mb = dyb / dxb;
    var cx = .5 * (ma * mb * (a[1] - c[1]) + mb * (a[0] + b[0]) - ma * (b[0] + c[0])) / (mb - ma), cy = (.5 * (a[0] + b[0]) - cx) / ma + .5 * (a[1] + b[1]);
    var dx0 = d[0] - cx, dy0 = d[1] - cy, dx1 = a[0] - cx, dy1 = a[1] - cy, r0 = dx0 * dx0 + dy0 * dy0, r1 = dx1 * dx1 + dy1 * dy1;
    var a0 = Math.atan2(dy0, dx0), a1 = Math.atan2(dy1, dx1);
    return function(coordinates) {
      var dx = coordinates[0] - cx, dy = coordinates[1] - cy, r = dx * dx + dy * dy, a = Math.atan2(dy, dx);
      if (r0 < r && r < r1 && a0 < a && a < a1) return projection.invert(coordinates);
    };
  }
  function d3_geo_albers(φ0, φ1) {
    var sinφ0 = Math.sin(φ0), n = (sinφ0 + Math.sin(φ1)) / 2, C = 1 + sinφ0 * (2 * n - sinφ0), ρ0 = Math.sqrt(C) / n;
    function albers(λ, φ) {
      var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;
      return [ ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ) ];
    }
    albers.invert = function(x, y) {
      var ρ0_y = ρ0 - y;
      return [ Math.atan2(x, ρ0_y) / n, Math.asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n)) ];
    };
    return albers;
  }
  (d3.geo.albers = function() {
    var φ0 = 29.5 * d3_radians, φ1 = 45.5 * d3_radians, m = d3_geo_projectionMutator(d3_geo_albers), p = m(φ0, φ1);
    p.parallels = function(_) {
      if (!arguments.length) return [ φ0 * d3_degrees, φ1 * d3_degrees ];
      return m(φ0 = _[0] * d3_radians, φ1 = _[1] * d3_radians);
    };
    return p.rotate([ 98, 0 ]).center([ 0, 38 ]).scale(1e3);
  }).raw = d3_geo_albers;
  var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {
    return Math.sqrt(2 / (1 + cosλcosφ));
  }, function(ρ) {
    return 2 * Math.asin(ρ / 2);
  });
  (d3.geo.azimuthalEqualArea = function() {
    return d3_geo_projection(d3_geo_azimuthalEqualArea);
  }).raw = d3_geo_azimuthalEqualArea;
  var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {
    var c = Math.acos(cosλcosφ);
    return c && c / Math.sin(c);
  }, d3_identity);
  (d3.geo.azimuthalEquidistant = function() {
    return d3_geo_projection(d3_geo_azimuthalEquidistant);
  }).raw = d3_geo_azimuthalEquidistant;
  d3.geo.bounds = d3_geo_bounds(d3_identity);
  function d3_geo_bounds(projectStream) {
    var x0, y0, x1, y1;
    var bound = {
      point: boundPoint,
      lineStart: d3_noop,
      lineEnd: d3_noop,
      polygonStart: function() {
        bound.lineEnd = boundPolygonLineEnd;
      },
      polygonEnd: function() {
        bound.point = boundPoint;
      }
    };
    function boundPoint(x, y) {
      if (x < x0) x0 = x;
      if (x > x1) x1 = x;
      if (y < y0) y0 = y;
      if (y > y1) y1 = y;
    }
    function boundPolygonLineEnd() {
      bound.point = bound.lineEnd = d3_noop;
    }
    return function(feature) {
      y1 = x1 = -(x0 = y0 = Infinity);
      d3.geo.stream(feature, projectStream(bound));
      return [ [ x0, y0 ], [ x1, y1 ] ];
    };
  }
  d3.geo.centroid = function(object) {
    d3_geo_centroidDimension = d3_geo_centroidW = d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;
    d3.geo.stream(object, d3_geo_centroid);
    var m;
    if (d3_geo_centroidW && Math.abs(m = Math.sqrt(d3_geo_centroidX * d3_geo_centroidX + d3_geo_centroidY * d3_geo_centroidY + d3_geo_centroidZ * d3_geo_centroidZ)) > ε) {
      return [ Math.atan2(d3_geo_centroidY, d3_geo_centroidX) * d3_degrees, Math.asin(Math.max(-1, Math.min(1, d3_geo_centroidZ / m))) * d3_degrees ];
    }
  };
  var d3_geo_centroidDimension, d3_geo_centroidW, d3_geo_centroidX, d3_geo_centroidY, d3_geo_centroidZ;
  var d3_geo_centroid = {
    sphere: function() {
      if (d3_geo_centroidDimension < 2) {
        d3_geo_centroidDimension = 2;
        d3_geo_centroidW = d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;
      }
    },
    point: d3_geo_centroidPoint,
    lineStart: d3_geo_centroidLineStart,
    lineEnd: d3_geo_centroidLineEnd,
    polygonStart: function() {
      if (d3_geo_centroidDimension < 2) {
        d3_geo_centroidDimension = 2;
        d3_geo_centroidW = d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;
      }
      d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
    }
  };
  function d3_geo_centroidPoint(λ, φ) {
    if (d3_geo_centroidDimension) return;
    ++d3_geo_centroidW;
    λ *= d3_radians;
    var cosφ = Math.cos(φ *= d3_radians);
    d3_geo_centroidX += (cosφ * Math.cos(λ) - d3_geo_centroidX) / d3_geo_centroidW;
    d3_geo_centroidY += (cosφ * Math.sin(λ) - d3_geo_centroidY) / d3_geo_centroidW;
    d3_geo_centroidZ += (Math.sin(φ) - d3_geo_centroidZ) / d3_geo_centroidW;
  }
  function d3_geo_centroidRingStart() {
    var λ00, φ00;
    d3_geo_centroidDimension = 1;
    d3_geo_centroidLineStart();
    d3_geo_centroidDimension = 2;
    var linePoint = d3_geo_centroid.point;
    d3_geo_centroid.point = function(λ, φ) {
      linePoint(λ00 = λ, φ00 = φ);
    };
    d3_geo_centroid.lineEnd = function() {
      d3_geo_centroid.point(λ00, φ00);
      d3_geo_centroidLineEnd();
      d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
    };
  }
  function d3_geo_centroidLineStart() {
    var x0, y0, z0;
    if (d3_geo_centroidDimension > 1) return;
    if (d3_geo_centroidDimension < 1) {
      d3_geo_centroidDimension = 1;
      d3_geo_centroidW = d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;
    }
    d3_geo_centroid.point = function(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians);
      x0 = cosφ * Math.cos(λ);
      y0 = cosφ * Math.sin(λ);
      z0 = Math.sin(φ);
      d3_geo_centroid.point = nextPoint;
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
      d3_geo_centroidW += w;
      d3_geo_centroidX += w * (x0 + (x0 = x));
      d3_geo_centroidY += w * (y0 + (y0 = y));
      d3_geo_centroidZ += w * (z0 + (z0 = z));
    }
  }
  function d3_geo_centroidLineEnd() {
    d3_geo_centroid.point = d3_geo_centroidPoint;
  }
  d3.geo.circle = function() {
    var origin = [ 0, 0 ], angle, precision = 6, interpolate;
    function circle() {
      var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
      interpolate(null, null, 1, {
        point: function(x, y) {
          ring.push(x = rotate(x, y));
          x[0] *= d3_degrees, x[1] *= d3_degrees;
        }
      });
      return {
        type: "Polygon",
        coordinates: [ ring ]
      };
    }
    circle.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return circle;
    };
    circle.angle = function(x) {
      if (!arguments.length) return angle;
      interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
      return circle;
    };
    circle.precision = function(_) {
      if (!arguments.length) return precision;
      interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
      return circle;
    };
    return circle.angle(90);
  };
  function d3_geo_circleInterpolate(radians, precision) {
    var cr = Math.cos(radians), sr = Math.sin(radians);
    return function(from, to, direction, listener) {
      if (from != null) {
        from = d3_geo_circleAngle(cr, from);
        to = d3_geo_circleAngle(cr, to);
        if (direction > 0 ? from < to : from > to) from += direction * 2 * π;
      } else {
        from = radians + direction * 2 * π;
        to = radians;
      }
      var point;
      for (var step = direction * precision, t = from; direction > 0 ? t > to : t < to; t -= step) {
        listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);
      }
    };
  }
  function d3_geo_circleAngle(cr, point) {
    var a = d3_geo_cartesian(point);
    a[0] -= cr;
    d3_geo_cartesianNormalize(a);
    var angle = d3_acos(-a[1]);
    return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);
  }
  function d3_geo_clip(pointVisible, clipLine, interpolate) {
    return function(listener) {
      var line = clipLine(listener);
      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          clip.point = pointRing;
          clip.lineStart = ringStart;
          clip.lineEnd = ringEnd;
          invisible = false;
          invisibleArea = visibleArea = 0;
          segments = [];
          listener.polygonStart();
        },
        polygonEnd: function() {
          clip.point = point;
          clip.lineStart = lineStart;
          clip.lineEnd = lineEnd;
          segments = d3.merge(segments);
          if (segments.length) {
            d3_geo_clipPolygon(segments, d3_geo_clipSort, null, interpolate, listener);
          } else if (visibleArea < -ε || invisible && invisibleArea < -ε) {
            listener.lineStart();
            interpolate(null, null, 1, listener);
            listener.lineEnd();
          }
          listener.polygonEnd();
          segments = null;
        },
        sphere: function() {
          listener.polygonStart();
          listener.lineStart();
          interpolate(null, null, 1, listener);
          listener.lineEnd();
          listener.polygonEnd();
        }
      };
      function point(λ, φ) {
        if (pointVisible(λ, φ)) listener.point(λ, φ);
      }
      function pointLine(λ, φ) {
        line.point(λ, φ);
      }
      function lineStart() {
        clip.point = pointLine;
        line.lineStart();
      }
      function lineEnd() {
        clip.point = point;
        line.lineEnd();
      }
      var segments, visibleArea, invisibleArea, invisible;
      var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), ring;
      function pointRing(λ, φ) {
        ringListener.point(λ, φ);
        ring.push([ λ, φ ]);
      }
      function ringStart() {
        ringListener.lineStart();
        ring = [];
      }
      function ringEnd() {
        pointRing(ring[0][0], ring[0][1]);
        ringListener.lineEnd();
        var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
        if (!n) {
          invisible = true;
          invisibleArea += d3_geo_clipAreaRing(ring, -1);
          ring = null;
          return;
        }
        ring = null;
        if (clean & 1) {
          segment = ringSegments[0];
          visibleArea += d3_geo_clipAreaRing(segment, 1);
          var n = segment.length - 1, i = -1, point;
          listener.lineStart();
          while (++i < n) listener.point((point = segment[i])[0], point[1]);
          listener.lineEnd();
          return;
        }
        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
      }
      return clip;
    };
  }
  function d3_geo_clipSegmentLength1(segment) {
    return segment.length > 1;
  }
  function d3_geo_clipBufferListener() {
    var lines = [], line;
    return {
      lineStart: function() {
        lines.push(line = []);
      },
      point: function(λ, φ) {
        line.push([ λ, φ ]);
      },
      lineEnd: d3_noop,
      buffer: function() {
        var buffer = lines;
        lines = [];
        line = null;
        return buffer;
      },
      rejoin: function() {
        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
      }
    };
  }
  function d3_geo_clipAreaRing(ring, invisible) {
    if (!(n = ring.length)) return 0;
    var n, i = 0, area = 0, p = ring[0], λ = p[0], φ = p[1], cosφ = Math.cos(φ), x0 = Math.atan2(invisible * Math.sin(λ) * cosφ, Math.sin(φ)), y0 = 1 - invisible * Math.cos(λ) * cosφ, x1 = x0, x, y;
    while (++i < n) {
      p = ring[i];
      cosφ = Math.cos(φ = p[1]);
      x = Math.atan2(invisible * Math.sin(λ = p[0]) * cosφ, Math.sin(φ));
      y = 1 - invisible * Math.cos(λ) * cosφ;
      if (Math.abs(y0 - 2) < ε && Math.abs(y - 2) < ε) continue;
      if (Math.abs(y) < ε || Math.abs(y0) < ε) {} else if (Math.abs(Math.abs(x - x0) - π) < ε) {
        if (y + y0 > 2) area += 4 * (x - x0);
      } else if (Math.abs(y0 - 2) < ε) area += 4 * (x - x1); else area += ((3 * π + x - x0) % (2 * π) - π) * (y0 + y);
      x1 = x0, x0 = x, y0 = y;
    }
    return area;
  }
  function d3_geo_clipSort(a, b) {
    return ((a = a.point)[0] < 0 ? a[1] - π / 2 - ε : π / 2 - a[1]) - ((b = b.point)[0] < 0 ? b[1] - π / 2 - ε : π / 2 - b[1]);
  }
  var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate);
  function d3_geo_clipAntimeridianLine(listener) {
    var λ0 = NaN, φ0 = NaN, sλ0 = NaN, clean;
    return {
      lineStart: function() {
        listener.lineStart();
        clean = 1;
      },
      point: function(λ1, φ1) {
        var sλ1 = λ1 > 0 ? π : -π, dλ = Math.abs(λ1 - λ0);
        if (Math.abs(dλ - π) < ε) {
          listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? π / 2 : -π / 2);
          listener.point(sλ0, φ0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(sλ1, φ0);
          listener.point(λ1, φ0);
          clean = 0;
        } else if (sλ0 !== sλ1 && dλ >= π) {
          if (Math.abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;
          if (Math.abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;
          φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);
          listener.point(sλ0, φ0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(sλ1, φ0);
          clean = 0;
        }
        listener.point(λ0 = λ1, φ0 = φ1);
        sλ0 = sλ1;
      },
      lineEnd: function() {
        listener.lineEnd();
        λ0 = φ0 = NaN;
      },
      clean: function() {
        return 2 - clean;
      }
    };
  }
  function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {
    var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1);
    return Math.abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;
  }
  function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
    var φ;
    if (from == null) {
      φ = direction * π / 2;
      listener.point(-π, φ);
      listener.point(0, φ);
      listener.point(π, φ);
      listener.point(π, 0);
      listener.point(π, -φ);
      listener.point(0, -φ);
      listener.point(-π, -φ);
      listener.point(-π, 0);
      listener.point(-π, φ);
    } else if (Math.abs(from[0] - to[0]) > ε) {
      var s = (from[0] < to[0] ? 1 : -1) * π;
      φ = direction * s / 2;
      listener.point(-s, φ);
      listener.point(0, φ);
      listener.point(s, φ);
    } else {
      listener.point(to[0], to[1]);
    }
  }
  function d3_geo_clipCircle(degrees) {
    var radians = degrees * d3_radians, cr = Math.cos(radians), interpolate = d3_geo_circleInterpolate(radians, 6 * d3_radians);
    return d3_geo_clip(visible, clipLine, interpolate);
    function visible(λ, φ) {
      return Math.cos(λ) * Math.cos(φ) > cr;
    }
    function clipLine(listener) {
      var point0, v0, v00, clean;
      return {
        lineStart: function() {
          v00 = v0 = false;
          clean = 1;
        },
        point: function(λ, φ) {
          var point1 = [ λ, φ ], point2, v = visible(λ, φ);
          if (!point0 && (v00 = v0 = v)) listener.lineStart();
          if (v !== v0) {
            point2 = intersect(point0, point1);
            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
              point1[0] += ε;
              point1[1] += ε;
              v = visible(point1[0], point1[1]);
            }
          }
          if (v !== v0) {
            clean = 0;
            if (v0 = v) {
              listener.lineStart();
              point2 = intersect(point1, point0);
              listener.point(point2[0], point2[1]);
            } else {
              point2 = intersect(point0, point1);
              listener.point(point2[0], point2[1]);
              listener.lineEnd();
            }
            point0 = point2;
          }
          if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) listener.point(point1[0], point1[1]);
          point0 = point1;
        },
        lineEnd: function() {
          if (v0) listener.lineEnd();
          point0 = null;
        },
        clean: function() {
          return clean | (v00 && v0) << 1;
        }
      };
    }
    function intersect(a, b) {
      var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);
      var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
      if (!determinant) return a;
      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
      d3_geo_cartesianAdd(A, B);
      var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t = Math.sqrt(w * w - uu * (d3_geo_cartesianDot(A, A) - 1)), q = d3_geo_cartesianScale(u, (-w - t) / uu);
      d3_geo_cartesianAdd(q, A);
      return d3_geo_spherical(q);
    }
  }
  function d3_geo_clipPolygon(segments, compare, inside, interpolate, listener) {
    var subject = [], clip = [];
    segments.forEach(function(segment) {
      if ((n = segment.length) <= 1) return;
      var n, p0 = segment[0], p1 = segment[n - 1];
      if (d3_geo_sphericalEqual(p0, p1)) {
        listener.lineStart();
        for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);
        listener.lineEnd();
        return;
      }
      var a = {
        point: p0,
        points: segment,
        other: null,
        visited: false,
        entry: true,
        subject: true
      }, b = {
        point: p0,
        points: [ p0 ],
        other: a,
        visited: false,
        entry: false,
        subject: false
      };
      a.other = b;
      subject.push(a);
      clip.push(b);
      a = {
        point: p1,
        points: [ p1 ],
        other: null,
        visited: false,
        entry: false,
        subject: true
      };
      b = {
        point: p1,
        points: [ p1 ],
        other: a,
        visited: false,
        entry: true,
        subject: false
      };
      a.other = b;
      subject.push(a);
      clip.push(b);
    });
    clip.sort(compare);
    d3_geo_clipPolygonLinkCircular(subject);
    d3_geo_clipPolygonLinkCircular(clip);
    if (!subject.length) return;
    if (inside) for (var i = 1, e = inside(clip[0].point), n = clip.length; i < n; ++i) {
      clip[i].entry = e = !e;
    }
    var start = subject[0], current, points, point;
    while (1) {
      current = start;
      while (current.visited) if ((current = current.next) === start) return;
      points = current.points;
      listener.lineStart();
      do {
        current.visited = current.other.visited = true;
        if (current.entry) {
          if (current.subject) {
            for (var i = 0; i < points.length; i++) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.point, current.next.point, 1, listener);
          }
          current = current.next;
        } else {
          if (current.subject) {
            points = current.prev.points;
            for (var i = points.length; --i >= 0; ) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.point, current.prev.point, -1, listener);
          }
          current = current.prev;
        }
        current = current.other;
        points = current.points;
      } while (!current.visited);
      listener.lineEnd();
    }
  }
  function d3_geo_clipPolygonLinkCircular(array) {
    if (!(n = array.length)) return;
    var n, i = 0, a = array[0], b;
    while (++i < n) {
      a.next = b = array[i];
      b.prev = a;
      a = b;
    }
    a.next = b = array[0];
    b.prev = a;
  }
  function d3_geo_clipView(x0, y0, x1, y1) {
    return function(listener) {
      var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), segments, polygon, ring;
      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          listener = bufferListener;
          segments = [];
          polygon = [];
        },
        polygonEnd: function() {
          listener = listener_;
          if (segments.length) {
            listener.polygonStart();
            d3_geo_clipPolygon(d3.merge(segments), compare, inside, interpolate, listener);
            listener.polygonEnd();
          }
          segments = polygon = ring = null;
        }
      };
      function inside(point) {
        var a = corner(point, -1), i = !insidePolygon([ a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0 ]);
        return i;
      }
      function insidePolygon(p) {
        var wn = 0, n = polygon.length, y = p[1];
        for (var i = 0; i < n; ++i) {
          for (var j = 1, v = polygon[i], m = v.length, a = v[0]; j < m; ++j) {
            b = v[j];
            if (a[1] <= y) {
              if (b[1] > y && isLeft(a, b, p) > 0) ++wn;
            } else {
              if (b[1] <= y && isLeft(a, b, p) < 0) --wn;
            }
            a = b;
          }
        }
        return wn !== 0;
      }
      function isLeft(a, b, c) {
        return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);
      }
      function interpolate(from, to, direction, listener) {
        var a = corner(from, direction), a1 = corner(to, direction);
        if (a !== a1) {
          do {
            listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
          } while ((a = (a + direction + 4) % 4) !== a1);
        } else {
          listener.point(to[0], to[1]);
        }
      }
      function visible(x, y) {
        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
      }
      function point(x, y) {
        if (visible(x, y)) listener.point(x, y);
      }
      var x__, y__, v__, x_, y_, v_, first;
      function lineStart() {
        clip.point = linePoint;
        if (polygon) polygon.push(ring = []);
        first = true;
        v_ = false;
        x_ = y_ = NaN;
      }
      function lineEnd() {
        if (segments) {
          linePoint(x__, y__);
          if (v__ && v_) bufferListener.rejoin();
          segments.push(bufferListener.buffer());
        }
        clip.point = point;
        if (v_) listener.lineEnd();
      }
      function linePoint(x, y) {
        var v = visible(x, y);
        if (polygon) ring.push([ x, y ]);
        if (first) {
          x__ = x, y__ = y, v__ = v;
          first = false;
          if (v) {
            listener.lineStart();
            listener.point(x, y);
          }
        } else {
          if (v && v_) listener.point(x, y); else {
            var a = [ x_, y_ ], b = [ x, y ];
            if (clipLine(a, b)) {
              if (!v_) {
                listener.lineStart();
                listener.point(a[0], a[1]);
              }
              listener.point(b[0], b[1]);
              if (!v) listener.lineEnd();
            }
          }
        }
        x_ = x, y_ = y, v_ = v;
      }
      return clip;
    };
    function corner(p, direction) {
      return Math.abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : Math.abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : Math.abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
    }
    function compare(a, b) {
      a = a.point, b = b.point;
      var ca = corner(a, 1), cb = corner(b, 1);
      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
    }
    function clipLine(a, b) {
      var dx = b[0] - a[0], dy = b[1] - a[1], t = [ 0, 1 ];
      if (Math.abs(dx) < ε && Math.abs(dy) < ε) return x0 <= a[0] && a[0] <= x1 && y0 <= a[1] && a[1] <= y1;
      if (d3_geo_clipViewT(x0 - a[0], dx, t) && d3_geo_clipViewT(a[0] - x1, -dx, t) && d3_geo_clipViewT(y0 - a[1], dy, t) && d3_geo_clipViewT(a[1] - y1, -dy, t)) {
        if (t[1] < 1) {
          b[0] = a[0] + t[1] * dx;
          b[1] = a[1] + t[1] * dy;
        }
        if (t[0] > 0) {
          a[0] += t[0] * dx;
          a[1] += t[0] * dy;
        }
        return true;
      }
      return false;
    }
  }
  function d3_geo_clipViewT(num, denominator, t) {
    if (Math.abs(denominator) < ε) return num < 0;
    var u = num / denominator;
    if (denominator > 0) {
      if (u > t[1]) return false;
      if (u > t[0]) t[0] = u;
    } else {
      if (u < t[0]) return false;
      if (u < t[1]) t[1] = u;
    }
    return true;
  }
  function d3_geo_compose(a, b) {
    function compose(x, y) {
      return x = a(x, y), b(x[0], x[1]);
    }
    if (a.invert && b.invert) compose.invert = function(x, y) {
      return x = b.invert(x, y), x && a.invert(x[0], x[1]);
    };
    return compose;
  }
  function d3_geo_equirectangular(λ, φ) {
    return [ λ, φ ];
  }
  (d3.geo.equirectangular = function() {
    return d3_geo_projection(d3_geo_equirectangular).scale(250 / π);
  }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
  var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {
    return 1 / cosλcosφ;
  }, Math.atan);
  (d3.geo.gnomonic = function() {
    return d3_geo_projection(d3_geo_gnomonic);
  }).raw = d3_geo_gnomonic;
  d3.geo.graticule = function() {
    var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
    function graticule() {
      return {
        type: "MultiLineString",
        coordinates: lines()
      };
    }
    function lines() {
      return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
        return Math.abs(x % DX) > ε;
      }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
        return Math.abs(y % DY) > ε;
      }).map(y));
    }
    graticule.lines = function() {
      return lines().map(function(coordinates) {
        return {
          type: "LineString",
          coordinates: coordinates
        };
      });
    };
    graticule.outline = function() {
      return {
        type: "Polygon",
        coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]
      };
    };
    graticule.extent = function(_) {
      if (!arguments.length) return graticule.minorExtent();
      return graticule.majorExtent(_).minorExtent(_);
    };
    graticule.majorExtent = function(_) {
      if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];
      X0 = +_[0][0], X1 = +_[1][0];
      Y0 = +_[0][1], Y1 = +_[1][1];
      if (X0 > X1) _ = X0, X0 = X1, X1 = _;
      if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
      return graticule.precision(precision);
    };
    graticule.minorExtent = function(_) {
      if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
      x0 = +_[0][0], x1 = +_[1][0];
      y0 = +_[0][1], y1 = +_[1][1];
      if (x0 > x1) _ = x0, x0 = x1, x1 = _;
      if (y0 > y1) _ = y0, y0 = y1, y1 = _;
      return graticule.precision(precision);
    };
    graticule.step = function(_) {
      if (!arguments.length) return graticule.minorStep();
      return graticule.majorStep(_).minorStep(_);
    };
    graticule.majorStep = function(_) {
      if (!arguments.length) return [ DX, DY ];
      DX = +_[0], DY = +_[1];
      return graticule;
    };
    graticule.minorStep = function(_) {
      if (!arguments.length) return [ dx, dy ];
      dx = +_[0], dy = +_[1];
      return graticule;
    };
    graticule.precision = function(_) {
      if (!arguments.length) return precision;
      precision = +_;
      x = d3_geo_graticuleX(y0, y1, 90);
      y = d3_geo_graticuleY(x0, x1, precision);
      X = d3_geo_graticuleX(Y0, Y1, 90);
      Y = d3_geo_graticuleY(X0, X1, precision);
      return graticule;
    };
    return graticule.majorExtent([ [ -180, -90 + ε ], [ 180, 90 - ε ] ]).minorExtent([ [ -180, -80 - ε ], [ 180, 80 + ε ] ]);
  };
  function d3_geo_graticuleX(y0, y1, dy) {
    var y = d3.range(y0, y1 - ε, dy).concat(y1);
    return function(x) {
      return y.map(function(y) {
        return [ x, y ];
      });
    };
  }
  function d3_geo_graticuleY(x0, x1, dx) {
    var x = d3.range(x0, x1 - ε, dx).concat(x1);
    return function(y) {
      return x.map(function(x) {
        return [ x, y ];
      });
    };
  }
  function d3_geo_haversin(x) {
    return (x = Math.sin(x / 2)) * x;
  }
  d3.geo.interpolate = function(source, target) {
    return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
  };
  function d3_geo_interpolate(x0, y0, x1, y1) {
    var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_geo_haversin(y1 - y0) + cy0 * cy1 * d3_geo_haversin(x1 - x0))), k = 1 / Math.sin(d);
    var interpolate = d ? function(t) {
      var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
      return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];
    } : function() {
      return [ x0 * d3_degrees, y0 * d3_degrees ];
    };
    interpolate.distance = d;
    return interpolate;
  }
  d3.geo.greatArc = function() {
    var source = d3_source, source_, target = d3_target, target_;
    function greatArc() {
      return {
        type: "LineString",
        coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]
      };
    }
    greatArc.distance = function() {
      return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
    };
    greatArc.source = function(_) {
      if (!arguments.length) return source;
      source = _, source_ = typeof _ === "function" ? null : _;
      return greatArc;
    };
    greatArc.target = function(_) {
      if (!arguments.length) return target;
      target = _, target_ = typeof _ === "function" ? null : _;
      return greatArc;
    };
    greatArc.precision = function() {
      return arguments.length ? greatArc : 0;
    };
    return greatArc;
  };
  function d3_geo_mercator(λ, φ) {
    return [ λ / (2 * π), Math.max(-.5, Math.min(+.5, Math.log(Math.tan(π / 4 + φ / 2)) / (2 * π))) ];
  }
  d3_geo_mercator.invert = function(x, y) {
    return [ 2 * π * x, 2 * Math.atan(Math.exp(2 * π * y)) - π / 2 ];
  };
  (d3.geo.mercator = function() {
    return d3_geo_projection(d3_geo_mercator).scale(500);
  }).raw = d3_geo_mercator;
  var d3_geo_orthographic = d3_geo_azimuthal(function() {
    return 1;
  }, Math.asin);
  (d3.geo.orthographic = function() {
    return d3_geo_projection(d3_geo_orthographic);
  }).raw = d3_geo_orthographic;
  d3.geo.path = function() {
    var pointRadius = 4.5, projection, context, projectStream, contextStream;
    function path(object) {
      if (object) d3.geo.stream(object, projectStream(contextStream.pointRadius(typeof pointRadius === "function" ? +pointRadius.apply(this, arguments) : pointRadius)));
      return contextStream.result();
    }
    path.area = function(object) {
      d3_geo_pathAreaSum = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathArea));
      return d3_geo_pathAreaSum;
    };
    path.centroid = function(object) {
      d3_geo_centroidDimension = d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
      return d3_geo_centroidZ ? [ d3_geo_centroidX / d3_geo_centroidZ, d3_geo_centroidY / d3_geo_centroidZ ] : undefined;
    };
    path.bounds = function(object) {
      return d3_geo_bounds(projectStream)(object);
    };
    path.projection = function(_) {
      if (!arguments.length) return projection;
      projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
      return path;
    };
    path.context = function(_) {
      if (!arguments.length) return context;
      contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
      return path;
    };
    path.pointRadius = function(_) {
      if (!arguments.length) return pointRadius;
      pointRadius = typeof _ === "function" ? _ : +_;
      return path;
    };
    return path.projection(d3.geo.albersUsa()).context(null);
  };
  function d3_geo_pathCircle(radius) {
    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + +2 * radius + "z";
  }
  function d3_geo_pathProjectStream(project) {
    var resample = d3_geo_resample(function(λ, φ) {
      return project([ λ * d3_degrees, φ * d3_degrees ]);
    });
    return function(stream) {
      stream = resample(stream);
      return {
        point: function(λ, φ) {
          stream.point(λ * d3_radians, φ * d3_radians);
        },
        sphere: function() {
          stream.sphere();
        },
        lineStart: function() {
          stream.lineStart();
        },
        lineEnd: function() {
          stream.lineEnd();
        },
        polygonStart: function() {
          stream.polygonStart();
        },
        polygonEnd: function() {
          stream.polygonEnd();
        }
      };
    };
  }
  function d3_geo_pathBuffer() {
    var pointCircle = d3_geo_pathCircle(4.5), buffer = [];
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointCircle = d3_geo_pathCircle(_);
        return stream;
      },
      result: function() {
        if (buffer.length) {
          var result = buffer.join("");
          buffer = [];
          return result;
        }
      }
    };
    function point(x, y) {
      buffer.push("M", x, ",", y, pointCircle);
    }
    function pointLineStart(x, y) {
      buffer.push("M", x, ",", y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      buffer.push("L", x, ",", y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      buffer.push("Z");
    }
    return stream;
  }
  function d3_geo_pathContext(context) {
    var pointRadius = 4.5;
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointRadius = _;
        return stream;
      },
      result: d3_noop
    };
    function point(x, y) {
      context.moveTo(x, y);
      context.arc(x, y, pointRadius, 0, 2 * π);
    }
    function pointLineStart(x, y) {
      context.moveTo(x, y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      context.lineTo(x, y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      context.closePath();
    }
    return stream;
  }
  var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_pathAreaPolygon = 0;
      d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
      d3_geo_pathAreaSum += Math.abs(d3_geo_pathAreaPolygon / 2);
    }
  };
  function d3_geo_pathAreaRingStart() {
    var x00, y00, x0, y0;
    d3_geo_pathArea.point = function(x, y) {
      d3_geo_pathArea.point = nextPoint;
      x00 = x0 = x, y00 = y0 = y;
    };
    function nextPoint(x, y) {
      d3_geo_pathAreaPolygon += y0 * x - x0 * y;
      x0 = x, y0 = y;
    }
    d3_geo_pathArea.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  var d3_geo_pathCentroid = {
    point: d3_geo_pathCentroidPoint,
    lineStart: d3_geo_pathCentroidLineStart,
    lineEnd: d3_geo_pathCentroidLineEnd,
    polygonStart: function() {
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
      d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
    }
  };
  function d3_geo_pathCentroidPoint(x, y) {
    if (d3_geo_centroidDimension) return;
    d3_geo_centroidX += x;
    d3_geo_centroidY += y;
    ++d3_geo_centroidZ;
  }
  function d3_geo_pathCentroidLineStart() {
    var x0, y0;
    if (d3_geo_centroidDimension !== 1) {
      if (d3_geo_centroidDimension < 1) {
        d3_geo_centroidDimension = 1;
        d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;
      } else return;
    }
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      x0 = x, y0 = y;
    };
    function nextPoint(x, y) {
      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
      d3_geo_centroidX += z * (x0 + x) / 2;
      d3_geo_centroidY += z * (y0 + y) / 2;
      d3_geo_centroidZ += z;
      x0 = x, y0 = y;
    }
  }
  function d3_geo_pathCentroidLineEnd() {
    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
  }
  function d3_geo_pathCentroidRingStart() {
    var x00, y00, x0, y0;
    if (d3_geo_centroidDimension < 2) {
      d3_geo_centroidDimension = 2;
      d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;
    }
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      x00 = x0 = x, y00 = y0 = y;
    };
    function nextPoint(x, y) {
      var z = y0 * x - x0 * y;
      d3_geo_centroidX += z * (x0 + x);
      d3_geo_centroidY += z * (y0 + y);
      d3_geo_centroidZ += z * 3;
      x0 = x, y0 = y;
    }
    d3_geo_pathCentroid.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  d3.geo.area = function(object) {
    d3_geo_areaSum = 0;
    d3.geo.stream(object, d3_geo_area);
    return d3_geo_areaSum;
  };
  var d3_geo_areaSum, d3_geo_areaRingU, d3_geo_areaRingV;
  var d3_geo_area = {
    sphere: function() {
      d3_geo_areaSum += 4 * π;
    },
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_areaRingU = 1, d3_geo_areaRingV = 0;
      d3_geo_area.lineStart = d3_geo_areaRingStart;
    },
    polygonEnd: function() {
      var area = 2 * Math.atan2(d3_geo_areaRingV, d3_geo_areaRingU);
      d3_geo_areaSum += area < 0 ? 4 * π + area : area;
      d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
    }
  };
  function d3_geo_areaRingStart() {
    var λ00, φ00, λ0, cosφ0, sinφ0;
    d3_geo_area.point = function(λ, φ) {
      d3_geo_area.point = nextPoint;
      λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), 
      sinφ0 = Math.sin(φ);
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      φ = φ * d3_radians / 2 + π / 4;
      var dλ = λ - λ0, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 * sinφ, u0 = d3_geo_areaRingU, v0 = d3_geo_areaRingV, u = cosφ0 * cosφ + k * Math.cos(dλ), v = k * Math.sin(dλ);
      d3_geo_areaRingU = u0 * u - v0 * v;
      d3_geo_areaRingV = v0 * u + u0 * v;
      λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;
    }
    d3_geo_area.lineEnd = function() {
      nextPoint(λ00, φ00);
    };
  }
  d3.geo.length = function(object) {
    d3_geo_lengthSum = 0;
    d3.geo.stream(object, d3_geo_length);
    return d3_geo_lengthSum;
  };
  var d3_geo_lengthSum;
  var d3_geo_length = {
    sphere: d3_noop,
    point: d3_noop,
    lineStart: d3_geo_lengthLineStart,
    lineEnd: d3_noop,
    polygonStart: d3_noop,
    polygonEnd: d3_noop
  };
  function d3_geo_lengthLineStart() {
    var λ0, sinφ0, cosφ0;
    d3_geo_length.point = function(λ, φ) {
      λ0 = λ * d3_radians, sinφ0 = Math.sin(φ *= d3_radians), cosφ0 = Math.cos(φ);
      d3_geo_length.point = nextPoint;
    };
    d3_geo_length.lineEnd = function() {
      d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
    };
    function nextPoint(λ, φ) {
      var sinφ = Math.sin(φ *= d3_radians), cosφ = Math.cos(φ), t = Math.abs((λ *= d3_radians) - λ0), cosΔλ = Math.cos(t);
      d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);
      λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ;
    }
  }
  d3.geo.projection = d3_geo_projection;
  d3.geo.projectionMutator = d3_geo_projectionMutator;
  function d3_geo_projection(project) {
    return d3_geo_projectionMutator(function() {
      return project;
    })();
  }
  function d3_geo_projectionMutator(projectAt) {
    var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {
      x = project(x, y);
      return [ x[0] * k + δx, δy - x[1] * k ];
    }), k = 150, x = 480, y = 250, λ = 0, φ = 0, δλ = 0, δφ = 0, δγ = 0, δx, δy, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null;
    function projection(point) {
      point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
      return [ point[0] * k + δx, δy - point[1] * k ];
    }
    function invert(point) {
      point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);
      return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];
    }
    projection.stream = function(stream) {
      return d3_geo_projectionRadiansRotate(rotate, preclip(projectResample(postclip(stream))));
    };
    projection.clipAngle = function(_) {
      if (!arguments.length) return clipAngle;
      preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle(clipAngle = +_);
      return projection;
    };
    projection.clipExtent = function(_) {
      if (!arguments.length) return clipExtent;
      clipExtent = _;
      postclip = _ == null ? d3_identity : d3_geo_clipView(_[0][0], _[0][1], _[1][0], _[1][1]);
      return projection;
    };
    projection.scale = function(_) {
      if (!arguments.length) return k;
      k = +_;
      return reset();
    };
    projection.translate = function(_) {
      if (!arguments.length) return [ x, y ];
      x = +_[0];
      y = +_[1];
      return reset();
    };
    projection.center = function(_) {
      if (!arguments.length) return [ λ * d3_degrees, φ * d3_degrees ];
      λ = _[0] % 360 * d3_radians;
      φ = _[1] % 360 * d3_radians;
      return reset();
    };
    projection.rotate = function(_) {
      if (!arguments.length) return [ δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees ];
      δλ = _[0] % 360 * d3_radians;
      δφ = _[1] % 360 * d3_radians;
      δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;
      return reset();
    };
    d3.rebind(projection, projectResample, "precision");
    function reset() {
      projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);
      var center = project(λ, φ);
      δx = x - center[0] * k;
      δy = y + center[1] * k;
      return projection;
    }
    return function() {
      project = projectAt.apply(this, arguments);
      projection.invert = project.invert && invert;
      return reset();
    };
  }
  function d3_geo_projectionRadiansRotate(rotate, stream) {
    return {
      point: function(x, y) {
        y = rotate(x * d3_radians, y * d3_radians), x = y[0];
        stream.point(x > π ? x - 2 * π : x < -π ? x + 2 * π : x, y[1]);
      },
      sphere: function() {
        stream.sphere();
      },
      lineStart: function() {
        stream.lineStart();
      },
      lineEnd: function() {
        stream.lineEnd();
      },
      polygonStart: function() {
        stream.polygonStart();
      },
      polygonEnd: function() {
        stream.polygonEnd();
      }
    };
  }
  d3.geo.rotation = function(rotate) {
    rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
    return function(coordinates) {
      coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
    };
  };
  function d3_geo_rotation(δλ, δφ, δγ) {
    return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_equirectangular;
  }
  function d3_geo_forwardRotationλ(δλ) {
    return function(λ, φ) {
      return λ += δλ, [ λ > π ? λ - 2 * π : λ < -π ? λ + 2 * π : λ, φ ];
    };
  }
  function d3_geo_rotationλ(δλ) {
    var rotation = d3_geo_forwardRotationλ(δλ);
    rotation.invert = d3_geo_forwardRotationλ(-δλ);
    return rotation;
  }
  function d3_geo_rotationφγ(δφ, δγ) {
    var cosδφ = Math.cos(δφ), sinδφ = Math.sin(δφ), cosδγ = Math.cos(δγ), sinδγ = Math.sin(δγ);
    function rotation(λ, φ) {
      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδφ + x * sinδφ;
      return [ Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), Math.asin(Math.max(-1, Math.min(1, k * cosδγ + y * sinδγ))) ];
    }
    rotation.invert = function(λ, φ) {
      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδγ - y * sinδγ;
      return [ Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), Math.asin(Math.max(-1, Math.min(1, k * cosδφ - x * sinδφ))) ];
    };
    return rotation;
  }
  var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {
    return 1 / (1 + cosλcosφ);
  }, function(ρ) {
    return 2 * Math.atan(ρ);
  });
  (d3.geo.stereographic = function() {
    return d3_geo_projection(d3_geo_stereographic);
  }).raw = d3_geo_stereographic;
  function d3_geo_azimuthal(scale, angle) {
    function azimuthal(λ, φ) {
      var cosλ = Math.cos(λ), cosφ = Math.cos(φ), k = scale(cosλ * cosφ);
      return [ k * cosφ * Math.sin(λ), k * Math.sin(φ) ];
    }
    azimuthal.invert = function(x, y) {
      var ρ = Math.sqrt(x * x + y * y), c = angle(ρ), sinc = Math.sin(c), cosc = Math.cos(c);
      return [ Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ) ];
    };
    return azimuthal;
  }
  d3.geom = {};
  d3.geom.hull = function(vertices) {
    if (vertices.length < 3) return [];
    var len = vertices.length, plen = len - 1, points = [], stack = [], i, j, h = 0, x1, y1, x2, y2, u, v, a, sp;
    for (i = 1; i < len; ++i) {
      if (vertices[i][1] < vertices[h][1]) {
        h = i;
      } else if (vertices[i][1] == vertices[h][1]) {
        h = vertices[i][0] < vertices[h][0] ? i : h;
      }
    }
    for (i = 0; i < len; ++i) {
      if (i === h) continue;
      y1 = vertices[i][1] - vertices[h][1];
      x1 = vertices[i][0] - vertices[h][0];
      points.push({
        angle: Math.atan2(y1, x1),
        index: i
      });
    }
    points.sort(function(a, b) {
      return a.angle - b.angle;
    });
    a = points[0].angle;
    v = points[0].index;
    u = 0;
    for (i = 1; i < plen; ++i) {
      j = points[i].index;
      if (a == points[i].angle) {
        x1 = vertices[v][0] - vertices[h][0];
        y1 = vertices[v][1] - vertices[h][1];
        x2 = vertices[j][0] - vertices[h][0];
        y2 = vertices[j][1] - vertices[h][1];
        if (x1 * x1 + y1 * y1 >= x2 * x2 + y2 * y2) {
          points[i].index = -1;
        } else {
          points[u].index = -1;
          a = points[i].angle;
          u = i;
          v = j;
        }
      } else {
        a = points[i].angle;
        u = i;
        v = j;
      }
    }
    stack.push(h);
    for (i = 0, j = 0; i < 2; ++j) {
      if (points[j].index !== -1) {
        stack.push(points[j].index);
        i++;
      }
    }
    sp = stack.length;
    for (;j < plen; ++j) {
      if (points[j].index === -1) continue;
      while (!d3_geom_hullCCW(stack[sp - 2], stack[sp - 1], points[j].index, vertices)) {
        --sp;
      }
      stack[sp++] = points[j].index;
    }
    var poly = [];
    for (i = 0; i < sp; ++i) {
      poly.push(vertices[stack[i]]);
    }
    return poly;
  };
  function d3_geom_hullCCW(i1, i2, i3, v) {
    var t, a, b, c, d, e, f;
    t = v[i1];
    a = t[0];
    b = t[1];
    t = v[i2];
    c = t[0];
    d = t[1];
    t = v[i3];
    e = t[0];
    f = t[1];
    return (f - b) * (c - a) - (d - b) * (e - a) > 0;
  }
  d3.geom.polygon = function(coordinates) {
    coordinates.area = function() {
      var i = 0, n = coordinates.length, area = coordinates[n - 1][1] * coordinates[0][0] - coordinates[n - 1][0] * coordinates[0][1];
      while (++i < n) {
        area += coordinates[i - 1][1] * coordinates[i][0] - coordinates[i - 1][0] * coordinates[i][1];
      }
      return area * .5;
    };
    coordinates.centroid = function(k) {
      var i = -1, n = coordinates.length, x = 0, y = 0, a, b = coordinates[n - 1], c;
      if (!arguments.length) k = -1 / (6 * coordinates.area());
      while (++i < n) {
        a = b;
        b = coordinates[i];
        c = a[0] * b[1] - b[0] * a[1];
        x += (a[0] + b[0]) * c;
        y += (a[1] + b[1]) * c;
      }
      return [ x * k, y * k ];
    };
    coordinates.clip = function(subject) {
      var input, i = -1, n = coordinates.length, j, m, a = coordinates[n - 1], b, c, d;
      while (++i < n) {
        input = subject.slice();
        subject.length = 0;
        b = coordinates[i];
        c = input[(m = input.length) - 1];
        j = -1;
        while (++j < m) {
          d = input[j];
          if (d3_geom_polygonInside(d, a, b)) {
            if (!d3_geom_polygonInside(c, a, b)) {
              subject.push(d3_geom_polygonIntersect(c, d, a, b));
            }
            subject.push(d);
          } else if (d3_geom_polygonInside(c, a, b)) {
            subject.push(d3_geom_polygonIntersect(c, d, a, b));
          }
          c = d;
        }
        a = b;
      }
      return subject;
    };
    return coordinates;
  };
  function d3_geom_polygonInside(p, a, b) {
    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
  }
  function d3_geom_polygonIntersect(c, d, a, b) {
    var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
    return [ x1 + ua * x21, y1 + ua * y21 ];
  }
  d3.geom.voronoi = function(vertices) {
    var polygons = vertices.map(function() {
      return [];
    }), Z = 1e6;
    d3_voronoi_tessellate(vertices, function(e) {
      var s1, s2, x1, x2, y1, y2;
      if (e.a === 1 && e.b >= 0) {
        s1 = e.ep.r;
        s2 = e.ep.l;
      } else {
        s1 = e.ep.l;
        s2 = e.ep.r;
      }
      if (e.a === 1) {
        y1 = s1 ? s1.y : -Z;
        x1 = e.c - e.b * y1;
        y2 = s2 ? s2.y : Z;
        x2 = e.c - e.b * y2;
      } else {
        x1 = s1 ? s1.x : -Z;
        y1 = e.c - e.a * x1;
        x2 = s2 ? s2.x : Z;
        y2 = e.c - e.a * x2;
      }
      var v1 = [ x1, y1 ], v2 = [ x2, y2 ];
      polygons[e.region.l.index].push(v1, v2);
      polygons[e.region.r.index].push(v1, v2);
    });
    polygons = polygons.map(function(polygon, i) {
      var cx = vertices[i][0], cy = vertices[i][1], angle = polygon.map(function(v) {
        return Math.atan2(v[0] - cx, v[1] - cy);
      }), order = d3.range(polygon.length).sort(function(a, b) {
        return angle[a] - angle[b];
      });
      return order.filter(function(d, i) {
        return !i || angle[d] - angle[order[i - 1]] > ε;
      }).map(function(d) {
        return polygon[d];
      });
    });
    polygons.forEach(function(polygon, i) {
      var n = polygon.length;
      if (!n) return polygon.push([ -Z, -Z ], [ -Z, Z ], [ Z, Z ], [ Z, -Z ]);
      if (n > 2) return;
      var p0 = vertices[i], p1 = polygon[0], p2 = polygon[1], x0 = p0[0], y0 = p0[1], x1 = p1[0], y1 = p1[1], x2 = p2[0], y2 = p2[1], dx = Math.abs(x2 - x1), dy = y2 - y1;
      if (Math.abs(dy) < ε) {
        var y = y0 < y1 ? -Z : Z;
        polygon.push([ -Z, y ], [ Z, y ]);
      } else if (dx < ε) {
        var x = x0 < x1 ? -Z : Z;
        polygon.push([ x, -Z ], [ x, Z ]);
      } else {
        var y = (x2 - x1) * (y1 - y0) < (x1 - x0) * (y2 - y1) ? Z : -Z, z = Math.abs(dy) - dx;
        if (Math.abs(z) < ε) {
          polygon.push([ dy < 0 ? y : -y, y ]);
        } else {
          if (z > 0) y *= -1;
          polygon.push([ -Z, y ], [ Z, y ]);
        }
      }
    });
    return polygons;
  };
  var d3_voronoi_opposite = {
    l: "r",
    r: "l"
  };
  function d3_voronoi_tessellate(vertices, callback) {
    var Sites = {
      list: vertices.map(function(v, i) {
        return {
          index: i,
          x: v[0],
          y: v[1]
        };
      }).sort(function(a, b) {
        return a.y < b.y ? -1 : a.y > b.y ? 1 : a.x < b.x ? -1 : a.x > b.x ? 1 : 0;
      }),
      bottomSite: null
    };
    var EdgeList = {
      list: [],
      leftEnd: null,
      rightEnd: null,
      init: function() {
        EdgeList.leftEnd = EdgeList.createHalfEdge(null, "l");
        EdgeList.rightEnd = EdgeList.createHalfEdge(null, "l");
        EdgeList.leftEnd.r = EdgeList.rightEnd;
        EdgeList.rightEnd.l = EdgeList.leftEnd;
        EdgeList.list.unshift(EdgeList.leftEnd, EdgeList.rightEnd);
      },
      createHalfEdge: function(edge, side) {
        return {
          edge: edge,
          side: side,
          vertex: null,
          l: null,
          r: null
        };
      },
      insert: function(lb, he) {
        he.l = lb;
        he.r = lb.r;
        lb.r.l = he;
        lb.r = he;
      },
      leftBound: function(p) {
        var he = EdgeList.leftEnd;
        do {
          he = he.r;
        } while (he != EdgeList.rightEnd && Geom.rightOf(he, p));
        he = he.l;
        return he;
      },
      del: function(he) {
        he.l.r = he.r;
        he.r.l = he.l;
        he.edge = null;
      },
      right: function(he) {
        return he.r;
      },
      left: function(he) {
        return he.l;
      },
      leftRegion: function(he) {
        return he.edge == null ? Sites.bottomSite : he.edge.region[he.side];
      },
      rightRegion: function(he) {
        return he.edge == null ? Sites.bottomSite : he.edge.region[d3_voronoi_opposite[he.side]];
      }
    };
    var Geom = {
      bisect: function(s1, s2) {
        var newEdge = {
          region: {
            l: s1,
            r: s2
          },
          ep: {
            l: null,
            r: null
          }
        };
        var dx = s2.x - s1.x, dy = s2.y - s1.y, adx = dx > 0 ? dx : -dx, ady = dy > 0 ? dy : -dy;
        newEdge.c = s1.x * dx + s1.y * dy + (dx * dx + dy * dy) * .5;
        if (adx > ady) {
          newEdge.a = 1;
          newEdge.b = dy / dx;
          newEdge.c /= dx;
        } else {
          newEdge.b = 1;
          newEdge.a = dx / dy;
          newEdge.c /= dy;
        }
        return newEdge;
      },
      intersect: function(el1, el2) {
        var e1 = el1.edge, e2 = el2.edge;
        if (!e1 || !e2 || e1.region.r == e2.region.r) {
          return null;
        }
        var d = e1.a * e2.b - e1.b * e2.a;
        if (Math.abs(d) < 1e-10) {
          return null;
        }
        var xint = (e1.c * e2.b - e2.c * e1.b) / d, yint = (e2.c * e1.a - e1.c * e2.a) / d, e1r = e1.region.r, e2r = e2.region.r, el, e;
        if (e1r.y < e2r.y || e1r.y == e2r.y && e1r.x < e2r.x) {
          el = el1;
          e = e1;
        } else {
          el = el2;
          e = e2;
        }
        var rightOfSite = xint >= e.region.r.x;
        if (rightOfSite && el.side === "l" || !rightOfSite && el.side === "r") {
          return null;
        }
        return {
          x: xint,
          y: yint
        };
      },
      rightOf: function(he, p) {
        var e = he.edge, topsite = e.region.r, rightOfSite = p.x > topsite.x;
        if (rightOfSite && he.side === "l") {
          return 1;
        }
        if (!rightOfSite && he.side === "r") {
          return 0;
        }
        if (e.a === 1) {
          var dyp = p.y - topsite.y, dxp = p.x - topsite.x, fast = 0, above = 0;
          if (!rightOfSite && e.b < 0 || rightOfSite && e.b >= 0) {
            above = fast = dyp >= e.b * dxp;
          } else {
            above = p.x + p.y * e.b > e.c;
            if (e.b < 0) {
              above = !above;
            }
            if (!above) {
              fast = 1;
            }
          }
          if (!fast) {
            var dxs = topsite.x - e.region.l.x;
            above = e.b * (dxp * dxp - dyp * dyp) < dxs * dyp * (1 + 2 * dxp / dxs + e.b * e.b);
            if (e.b < 0) {
              above = !above;
            }
          }
        } else {
          var yl = e.c - e.a * p.x, t1 = p.y - yl, t2 = p.x - topsite.x, t3 = yl - topsite.y;
          above = t1 * t1 > t2 * t2 + t3 * t3;
        }
        return he.side === "l" ? above : !above;
      },
      endPoint: function(edge, side, site) {
        edge.ep[side] = site;
        if (!edge.ep[d3_voronoi_opposite[side]]) return;
        callback(edge);
      },
      distance: function(s, t) {
        var dx = s.x - t.x, dy = s.y - t.y;
        return Math.sqrt(dx * dx + dy * dy);
      }
    };
    var EventQueue = {
      list: [],
      insert: function(he, site, offset) {
        he.vertex = site;
        he.ystar = site.y + offset;
        for (var i = 0, list = EventQueue.list, l = list.length; i < l; i++) {
          var next = list[i];
          if (he.ystar > next.ystar || he.ystar == next.ystar && site.x > next.vertex.x) {
            continue;
          } else {
            break;
          }
        }
        list.splice(i, 0, he);
      },
      del: function(he) {
        for (var i = 0, ls = EventQueue.list, l = ls.length; i < l && ls[i] != he; ++i) {}
        ls.splice(i, 1);
      },
      empty: function() {
        return EventQueue.list.length === 0;
      },
      nextEvent: function(he) {
        for (var i = 0, ls = EventQueue.list, l = ls.length; i < l; ++i) {
          if (ls[i] == he) return ls[i + 1];
        }
        return null;
      },
      min: function() {
        var elem = EventQueue.list[0];
        return {
          x: elem.vertex.x,
          y: elem.ystar
        };
      },
      extractMin: function() {
        return EventQueue.list.shift();
      }
    };
    EdgeList.init();
    Sites.bottomSite = Sites.list.shift();
    var newSite = Sites.list.shift(), newIntStar;
    var lbnd, rbnd, llbnd, rrbnd, bisector;
    var bot, top, temp, p, v;
    var e, pm;
    while (true) {
      if (!EventQueue.empty()) {
        newIntStar = EventQueue.min();
      }
      if (newSite && (EventQueue.empty() || newSite.y < newIntStar.y || newSite.y == newIntStar.y && newSite.x < newIntStar.x)) {
        lbnd = EdgeList.leftBound(newSite);
        rbnd = EdgeList.right(lbnd);
        bot = EdgeList.rightRegion(lbnd);
        e = Geom.bisect(bot, newSite);
        bisector = EdgeList.createHalfEdge(e, "l");
        EdgeList.insert(lbnd, bisector);
        p = Geom.intersect(lbnd, bisector);
        if (p) {
          EventQueue.del(lbnd);
          EventQueue.insert(lbnd, p, Geom.distance(p, newSite));
        }
        lbnd = bisector;
        bisector = EdgeList.createHalfEdge(e, "r");
        EdgeList.insert(lbnd, bisector);
        p = Geom.intersect(bisector, rbnd);
        if (p) {
          EventQueue.insert(bisector, p, Geom.distance(p, newSite));
        }
        newSite = Sites.list.shift();
      } else if (!EventQueue.empty()) {
        lbnd = EventQueue.extractMin();
        llbnd = EdgeList.left(lbnd);
        rbnd = EdgeList.right(lbnd);
        rrbnd = EdgeList.right(rbnd);
        bot = EdgeList.leftRegion(lbnd);
        top = EdgeList.rightRegion(rbnd);
        v = lbnd.vertex;
        Geom.endPoint(lbnd.edge, lbnd.side, v);
        Geom.endPoint(rbnd.edge, rbnd.side, v);
        EdgeList.del(lbnd);
        EventQueue.del(rbnd);
        EdgeList.del(rbnd);
        pm = "l";
        if (bot.y > top.y) {
          temp = bot;
          bot = top;
          top = temp;
          pm = "r";
        }
        e = Geom.bisect(bot, top);
        bisector = EdgeList.createHalfEdge(e, pm);
        EdgeList.insert(llbnd, bisector);
        Geom.endPoint(e, d3_voronoi_opposite[pm], v);
        p = Geom.intersect(llbnd, bisector);
        if (p) {
          EventQueue.del(llbnd);
          EventQueue.insert(llbnd, p, Geom.distance(p, bot));
        }
        p = Geom.intersect(bisector, rrbnd);
        if (p) {
          EventQueue.insert(bisector, p, Geom.distance(p, bot));
        }
      } else {
        break;
      }
    }
    for (lbnd = EdgeList.right(EdgeList.leftEnd); lbnd != EdgeList.rightEnd; lbnd = EdgeList.right(lbnd)) {
      callback(lbnd.edge);
    }
  }
  d3.geom.delaunay = function(vertices) {
    var edges = vertices.map(function() {
      return [];
    }), triangles = [];
    d3_voronoi_tessellate(vertices, function(e) {
      edges[e.region.l.index].push(vertices[e.region.r.index]);
    });
    edges.forEach(function(edge, i) {
      var v = vertices[i], cx = v[0], cy = v[1];
      edge.forEach(function(v) {
        v.angle = Math.atan2(v[0] - cx, v[1] - cy);
      });
      edge.sort(function(a, b) {
        return a.angle - b.angle;
      });
      for (var j = 0, m = edge.length - 1; j < m; j++) {
        triangles.push([ v, edge[j], edge[j + 1] ]);
      }
    });
    return triangles;
  };
  d3.geom.quadtree = function(points, x1, y1, x2, y2) {
    var p, i = -1, n = points.length;
    if (arguments.length < 5) {
      if (arguments.length === 3) {
        y2 = y1;
        x2 = x1;
        y1 = x1 = 0;
      } else {
        x1 = y1 = Infinity;
        x2 = y2 = -Infinity;
        while (++i < n) {
          p = points[i];
          if (p.x < x1) x1 = p.x;
          if (p.y < y1) y1 = p.y;
          if (p.x > x2) x2 = p.x;
          if (p.y > y2) y2 = p.y;
        }
      }
    }
    var dx = x2 - x1, dy = y2 - y1;
    if (dx > dy) y2 = y1 + dx; else x2 = x1 + dy;
    function insert(n, p, x1, y1, x2, y2) {
      if (isNaN(p.x) || isNaN(p.y)) return;
      if (n.leaf) {
        var v = n.point;
        if (v) {
          if (Math.abs(v.x - p.x) + Math.abs(v.y - p.y) < .01) {
            insertChild(n, p, x1, y1, x2, y2);
          } else {
            n.point = null;
            insertChild(n, v, x1, y1, x2, y2);
            insertChild(n, p, x1, y1, x2, y2);
          }
        } else {
          n.point = p;
        }
      } else {
        insertChild(n, p, x1, y1, x2, y2);
      }
    }
    function insertChild(n, p, x1, y1, x2, y2) {
      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, right = p.x >= sx, bottom = p.y >= sy, i = (bottom << 1) + right;
      n.leaf = false;
      n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
      if (right) x1 = sx; else x2 = sx;
      if (bottom) y1 = sy; else y2 = sy;
      insert(n, p, x1, y1, x2, y2);
    }
    var root = d3_geom_quadtreeNode();
    root.add = function(p) {
      insert(root, p, x1, y1, x2, y2);
    };
    root.visit = function(f) {
      d3_geom_quadtreeVisit(f, root, x1, y1, x2, y2);
    };
    points.forEach(root.add);
    return root;
  };
  function d3_geom_quadtreeNode() {
    return {
      leaf: true,
      nodes: [],
      point: null
    };
  }
  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
    if (!f(node, x1, y1, x2, y2)) {
      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
    }
  }
  d3.time = {};
  var d3_time = Date, d3_time_daySymbols = [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ];
  function d3_time_utc() {
    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
  }
  d3_time_utc.prototype = {
    getDate: function() {
      return this._.getUTCDate();
    },
    getDay: function() {
      return this._.getUTCDay();
    },
    getFullYear: function() {
      return this._.getUTCFullYear();
    },
    getHours: function() {
      return this._.getUTCHours();
    },
    getMilliseconds: function() {
      return this._.getUTCMilliseconds();
    },
    getMinutes: function() {
      return this._.getUTCMinutes();
    },
    getMonth: function() {
      return this._.getUTCMonth();
    },
    getSeconds: function() {
      return this._.getUTCSeconds();
    },
    getTime: function() {
      return this._.getTime();
    },
    getTimezoneOffset: function() {
      return 0;
    },
    valueOf: function() {
      return this._.valueOf();
    },
    setDate: function() {
      d3_time_prototype.setUTCDate.apply(this._, arguments);
    },
    setDay: function() {
      d3_time_prototype.setUTCDay.apply(this._, arguments);
    },
    setFullYear: function() {
      d3_time_prototype.setUTCFullYear.apply(this._, arguments);
    },
    setHours: function() {
      d3_time_prototype.setUTCHours.apply(this._, arguments);
    },
    setMilliseconds: function() {
      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
    },
    setMinutes: function() {
      d3_time_prototype.setUTCMinutes.apply(this._, arguments);
    },
    setMonth: function() {
      d3_time_prototype.setUTCMonth.apply(this._, arguments);
    },
    setSeconds: function() {
      d3_time_prototype.setUTCSeconds.apply(this._, arguments);
    },
    setTime: function() {
      d3_time_prototype.setTime.apply(this._, arguments);
    }
  };
  var d3_time_prototype = Date.prototype;
  var d3_time_formatDateTime = "%a %b %e %X %Y", d3_time_formatDate = "%m/%d/%Y", d3_time_formatTime = "%H:%M:%S";
  var d3_time_days = [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ], d3_time_dayAbbreviations = [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ], d3_time_months = [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ], d3_time_monthAbbreviations = [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ];
  d3.time.format = function(template) {
    var n = template.length;
    function format(date) {
      var string = [], i = -1, j = 0, c, p, f;
      while (++i < n) {
        if (template.charCodeAt(i) === 37) {
          string.push(template.substring(j, i));
          if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);
          if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);
          string.push(c);
          j = i + 1;
        }
      }
      string.push(template.substring(j, i));
      return string.join("");
    }
    format.parse = function(string) {
      var d = {
        y: 1900,
        m: 0,
        d: 1,
        H: 0,
        M: 0,
        S: 0,
        L: 0
      }, i = d3_time_parse(d, template, string, 0);
      if (i != string.length) return null;
      if ("p" in d) d.H = d.H % 12 + d.p * 12;
      var date = new d3_time();
      date.setFullYear(d.y, d.m, d.d);
      date.setHours(d.H, d.M, d.S, d.L);
      return date;
    };
    format.toString = function() {
      return template;
    };
    return format;
  };
  function d3_time_parse(date, template, string, j) {
    var c, p, i = 0, n = template.length, m = string.length;
    while (i < n) {
      if (j >= m) return -1;
      c = template.charCodeAt(i++);
      if (c === 37) {
        p = d3_time_parsers[template.charAt(i++)];
        if (!p || (j = p(date, string, j)) < 0) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }
    return j;
  }
  function d3_time_formatRe(names) {
    return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
  }
  function d3_time_formatLookup(names) {
    var map = new d3_Map(), i = -1, n = names.length;
    while (++i < n) map.set(names[i].toLowerCase(), i);
    return map;
  }
  function d3_time_formatPad(value, fill, width) {
    value += "";
    var length = value.length;
    return length < width ? new Array(width - length + 1).join(fill) + value : value;
  }
  var d3_time_dayRe = d3_time_formatRe(d3_time_days), d3_time_dayAbbrevRe = d3_time_formatRe(d3_time_dayAbbreviations), d3_time_monthRe = d3_time_formatRe(d3_time_months), d3_time_monthLookup = d3_time_formatLookup(d3_time_months), d3_time_monthAbbrevRe = d3_time_formatRe(d3_time_monthAbbreviations), d3_time_monthAbbrevLookup = d3_time_formatLookup(d3_time_monthAbbreviations);
  var d3_time_formatPads = {
    "-": "",
    _: " ",
    "0": "0"
  };
  var d3_time_formats = {
    a: function(d) {
      return d3_time_dayAbbreviations[d.getDay()];
    },
    A: function(d) {
      return d3_time_days[d.getDay()];
    },
    b: function(d) {
      return d3_time_monthAbbreviations[d.getMonth()];
    },
    B: function(d) {
      return d3_time_months[d.getMonth()];
    },
    c: d3.time.format(d3_time_formatDateTime),
    d: function(d, p) {
      return d3_time_formatPad(d.getDate(), p, 2);
    },
    e: function(d, p) {
      return d3_time_formatPad(d.getDate(), p, 2);
    },
    H: function(d, p) {
      return d3_time_formatPad(d.getHours(), p, 2);
    },
    I: function(d, p) {
      return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
    },
    j: function(d, p) {
      return d3_time_formatPad(1 + d3.time.dayOfYear(d), p, 3);
    },
    L: function(d, p) {
      return d3_time_formatPad(d.getMilliseconds(), p, 3);
    },
    m: function(d, p) {
      return d3_time_formatPad(d.getMonth() + 1, p, 2);
    },
    M: function(d, p) {
      return d3_time_formatPad(d.getMinutes(), p, 2);
    },
    p: function(d) {
      return d.getHours() >= 12 ? "PM" : "AM";
    },
    S: function(d, p) {
      return d3_time_formatPad(d.getSeconds(), p, 2);
    },
    U: function(d, p) {
      return d3_time_formatPad(d3.time.sundayOfYear(d), p, 2);
    },
    w: function(d) {
      return d.getDay();
    },
    W: function(d, p) {
      return d3_time_formatPad(d3.time.mondayOfYear(d), p, 2);
    },
    x: d3.time.format(d3_time_formatDate),
    X: d3.time.format(d3_time_formatTime),
    y: function(d, p) {
      return d3_time_formatPad(d.getFullYear() % 100, p, 2);
    },
    Y: function(d, p) {
      return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
    },
    Z: d3_time_zone,
    "%": function() {
      return "%";
    }
  };
  var d3_time_parsers = {
    a: d3_time_parseWeekdayAbbrev,
    A: d3_time_parseWeekday,
    b: d3_time_parseMonthAbbrev,
    B: d3_time_parseMonth,
    c: d3_time_parseLocaleFull,
    d: d3_time_parseDay,
    e: d3_time_parseDay,
    H: d3_time_parseHour24,
    I: d3_time_parseHour24,
    L: d3_time_parseMilliseconds,
    m: d3_time_parseMonthNumber,
    M: d3_time_parseMinutes,
    p: d3_time_parseAmPm,
    S: d3_time_parseSeconds,
    x: d3_time_parseLocaleDate,
    X: d3_time_parseLocaleTime,
    y: d3_time_parseYear,
    Y: d3_time_parseFullYear
  };
  function d3_time_parseWeekdayAbbrev(date, string, i) {
    d3_time_dayAbbrevRe.lastIndex = 0;
    var n = d3_time_dayAbbrevRe.exec(string.substring(i));
    return n ? i += n[0].length : -1;
  }
  function d3_time_parseWeekday(date, string, i) {
    d3_time_dayRe.lastIndex = 0;
    var n = d3_time_dayRe.exec(string.substring(i));
    return n ? i += n[0].length : -1;
  }
  function d3_time_parseMonthAbbrev(date, string, i) {
    d3_time_monthAbbrevRe.lastIndex = 0;
    var n = d3_time_monthAbbrevRe.exec(string.substring(i));
    return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i += n[0].length) : -1;
  }
  function d3_time_parseMonth(date, string, i) {
    d3_time_monthRe.lastIndex = 0;
    var n = d3_time_monthRe.exec(string.substring(i));
    return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i += n[0].length) : -1;
  }
  function d3_time_parseLocaleFull(date, string, i) {
    return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
  }
  function d3_time_parseLocaleDate(date, string, i) {
    return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
  }
  function d3_time_parseLocaleTime(date, string, i) {
    return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
  }
  function d3_time_parseFullYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 4));
    return n ? (date.y = +n[0], i += n[0].length) : -1;
  }
  function d3_time_parseYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.y = d3_time_expandYear(+n[0]), i += n[0].length) : -1;
  }
  function d3_time_expandYear(d) {
    return d + (d > 68 ? 1900 : 2e3);
  }
  function d3_time_parseMonthNumber(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.m = n[0] - 1, i += n[0].length) : -1;
  }
  function d3_time_parseDay(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.d = +n[0], i += n[0].length) : -1;
  }
  function d3_time_parseHour24(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.H = +n[0], i += n[0].length) : -1;
  }
  function d3_time_parseMinutes(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.M = +n[0], i += n[0].length) : -1;
  }
  function d3_time_parseSeconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.S = +n[0], i += n[0].length) : -1;
  }
  function d3_time_parseMilliseconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 3));
    return n ? (date.L = +n[0], i += n[0].length) : -1;
  }
  var d3_time_numberRe = /^\s*\d+/;
  function d3_time_parseAmPm(date, string, i) {
    var n = d3_time_amPmLookup.get(string.substring(i, i += 2).toLowerCase());
    return n == null ? -1 : (date.p = n, i);
  }
  var d3_time_amPmLookup = d3.map({
    am: 0,
    pm: 1
  });
  function d3_time_zone(d) {
    var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = ~~(Math.abs(z) / 60), zm = Math.abs(z) % 60;
    return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
  }
  d3.time.format.utc = function(template) {
    var local = d3.time.format(template);
    function format(date) {
      try {
        d3_time = d3_time_utc;
        var utc = new d3_time();
        utc._ = date;
        return local(utc);
      } finally {
        d3_time = Date;
      }
    }
    format.parse = function(string) {
      try {
        d3_time = d3_time_utc;
        var date = local.parse(string);
        return date && date._;
      } finally {
        d3_time = Date;
      }
    };
    format.toString = local.toString;
    return format;
  };
  var d3_time_formatIso = d3.time.format.utc("%Y-%m-%dT%H:%M:%S.%LZ");
  d3.time.format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
  function d3_time_formatIsoNative(date) {
    return date.toISOString();
  }
  d3_time_formatIsoNative.parse = function(string) {
    var date = new Date(string);
    return isNaN(date) ? null : date;
  };
  d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
  function d3_time_interval(local, step, number) {
    function round(date) {
      var d0 = local(date), d1 = offset(d0, 1);
      return date - d0 < d1 - date ? d0 : d1;
    }
    function ceil(date) {
      step(date = local(new d3_time(date - 1)), 1);
      return date;
    }
    function offset(date, k) {
      step(date = new d3_time(+date), k);
      return date;
    }
    function range(t0, t1, dt) {
      var time = ceil(t0), times = [];
      if (dt > 1) {
        while (time < t1) {
          if (!(number(time) % dt)) times.push(new Date(+time));
          step(time, 1);
        }
      } else {
        while (time < t1) times.push(new Date(+time)), step(time, 1);
      }
      return times;
    }
    function range_utc(t0, t1, dt) {
      try {
        d3_time = d3_time_utc;
        var utc = new d3_time_utc();
        utc._ = t0;
        return range(utc, t1, dt);
      } finally {
        d3_time = Date;
      }
    }
    local.floor = local;
    local.round = round;
    local.ceil = ceil;
    local.offset = offset;
    local.range = range;
    var utc = local.utc = d3_time_interval_utc(local);
    utc.floor = utc;
    utc.round = d3_time_interval_utc(round);
    utc.ceil = d3_time_interval_utc(ceil);
    utc.offset = d3_time_interval_utc(offset);
    utc.range = range_utc;
    return local;
  }
  function d3_time_interval_utc(method) {
    return function(date, k) {
      try {
        d3_time = d3_time_utc;
        var utc = new d3_time_utc();
        utc._ = date;
        return method(utc, k)._;
      } finally {
        d3_time = Date;
      }
    };
  }
  d3.time.second = d3_time_interval(function(date) {
    return new d3_time(Math.floor(date / 1e3) * 1e3);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 1e3);
  }, function(date) {
    return date.getSeconds();
  });
  d3.time.seconds = d3.time.second.range;
  d3.time.seconds.utc = d3.time.second.utc.range;
  d3.time.minute = d3_time_interval(function(date) {
    return new d3_time(Math.floor(date / 6e4) * 6e4);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 6e4);
  }, function(date) {
    return date.getMinutes();
  });
  d3.time.minutes = d3.time.minute.range;
  d3.time.minutes.utc = d3.time.minute.utc.range;
  d3.time.hour = d3_time_interval(function(date) {
    var timezone = date.getTimezoneOffset() / 60;
    return new d3_time((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 36e5);
  }, function(date) {
    return date.getHours();
  });
  d3.time.hours = d3.time.hour.range;
  d3.time.hours.utc = d3.time.hour.utc.range;
  d3.time.day = d3_time_interval(function(date) {
    var day = new d3_time(1970, 0);
    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
    return day;
  }, function(date, offset) {
    date.setDate(date.getDate() + offset);
  }, function(date) {
    return date.getDate() - 1;
  });
  d3.time.days = d3.time.day.range;
  d3.time.days.utc = d3.time.day.utc.range;
  d3.time.dayOfYear = function(date) {
    var year = d3.time.year(date);
    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
  };
  d3_time_daySymbols.forEach(function(day, i) {
    day = day.toLowerCase();
    i = 7 - i;
    var interval = d3.time[day] = d3_time_interval(function(date) {
      (date = d3.time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
      return date;
    }, function(date, offset) {
      date.setDate(date.getDate() + Math.floor(offset) * 7);
    }, function(date) {
      var day = d3.time.year(date).getDay();
      return Math.floor((d3.time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
    });
    d3.time[day + "s"] = interval.range;
    d3.time[day + "s"].utc = interval.utc.range;
    d3.time[day + "OfYear"] = function(date) {
      var day = d3.time.year(date).getDay();
      return Math.floor((d3.time.dayOfYear(date) + (day + i) % 7) / 7);
    };
  });
  d3.time.week = d3.time.sunday;
  d3.time.weeks = d3.time.sunday.range;
  d3.time.weeks.utc = d3.time.sunday.utc.range;
  d3.time.weekOfYear = d3.time.sundayOfYear;
  d3.time.month = d3_time_interval(function(date) {
    date = d3.time.day(date);
    date.setDate(1);
    return date;
  }, function(date, offset) {
    date.setMonth(date.getMonth() + offset);
  }, function(date) {
    return date.getMonth();
  });
  d3.time.months = d3.time.month.range;
  d3.time.months.utc = d3.time.month.utc.range;
  d3.time.year = d3_time_interval(function(date) {
    date = d3.time.day(date);
    date.setMonth(0, 1);
    return date;
  }, function(date, offset) {
    date.setFullYear(date.getFullYear() + offset);
  }, function(date) {
    return date.getFullYear();
  });
  d3.time.years = d3.time.year.range;
  d3.time.years.utc = d3.time.year.utc.range;
  function d3_time_scale(linear, methods, format) {
    function scale(x) {
      return linear(x);
    }
    scale.invert = function(x) {
      return d3_time_scaleDate(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
      linear.domain(x);
      return scale;
    };
    scale.nice = function(m) {
      return scale.domain(d3_scale_nice(scale.domain(), function() {
        return m;
      }));
    };
    scale.ticks = function(m, k) {
      var extent = d3_time_scaleExtent(scale.domain());
      if (typeof m !== "function") {
        var span = extent[1] - extent[0], target = span / m, i = d3.bisect(d3_time_scaleSteps, target);
        if (i == d3_time_scaleSteps.length) return methods.year(extent, m);
        if (!i) return linear.ticks(m).map(d3_time_scaleDate);
        if (Math.log(target / d3_time_scaleSteps[i - 1]) < Math.log(d3_time_scaleSteps[i] / target)) --i;
        m = methods[i];
        k = m[1];
        m = m[0].range;
      }
      return m(extent[0], new Date(+extent[1] + 1), k);
    };
    scale.tickFormat = function() {
      return format;
    };
    scale.copy = function() {
      return d3_time_scale(linear.copy(), methods, format);
    };
    return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
  }
  function d3_time_scaleExtent(domain) {
    var start = domain[0], stop = domain[domain.length - 1];
    return start < stop ? [ start, stop ] : [ stop, start ];
  }
  function d3_time_scaleDate(t) {
    return new Date(t);
  }
  function d3_time_scaleFormat(formats) {
    return function(date) {
      var i = formats.length - 1, f = formats[i];
      while (!f[1](date)) f = formats[--i];
      return f[0](date);
    };
  }
  function d3_time_scaleSetYear(y) {
    var d = new Date(y, 0, 1);
    d.setFullYear(y);
    return d;
  }
  function d3_time_scaleGetYear(d) {
    var y = d.getFullYear(), d0 = d3_time_scaleSetYear(y), d1 = d3_time_scaleSetYear(y + 1);
    return y + (d - d0) / (d1 - d0);
  }
  var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];
  var d3_time_scaleLocalMethods = [ [ d3.time.second, 1 ], [ d3.time.second, 5 ], [ d3.time.second, 15 ], [ d3.time.second, 30 ], [ d3.time.minute, 1 ], [ d3.time.minute, 5 ], [ d3.time.minute, 15 ], [ d3.time.minute, 30 ], [ d3.time.hour, 1 ], [ d3.time.hour, 3 ], [ d3.time.hour, 6 ], [ d3.time.hour, 12 ], [ d3.time.day, 1 ], [ d3.time.day, 2 ], [ d3.time.week, 1 ], [ d3.time.month, 1 ], [ d3.time.month, 3 ], [ d3.time.year, 1 ] ];
  var d3_time_scaleLocalFormats = [ [ d3.time.format("%Y"), d3_true ], [ d3.time.format("%B"), function(d) {
    return d.getMonth();
  } ], [ d3.time.format("%b %d"), function(d) {
    return d.getDate() != 1;
  } ], [ d3.time.format("%a %d"), function(d) {
    return d.getDay() && d.getDate() != 1;
  } ], [ d3.time.format("%I %p"), function(d) {
    return d.getHours();
  } ], [ d3.time.format("%I:%M"), function(d) {
    return d.getMinutes();
  } ], [ d3.time.format(":%S"), function(d) {
    return d.getSeconds();
  } ], [ d3.time.format(".%L"), function(d) {
    return d.getMilliseconds();
  } ] ];
  var d3_time_scaleLinear = d3.scale.linear(), d3_time_scaleLocalFormat = d3_time_scaleFormat(d3_time_scaleLocalFormats);
  d3_time_scaleLocalMethods.year = function(extent, m) {
    return d3_time_scaleLinear.domain(extent.map(d3_time_scaleGetYear)).ticks(m).map(d3_time_scaleSetYear);
  };
  d3.time.scale = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
  };
  var d3_time_scaleUTCMethods = d3_time_scaleLocalMethods.map(function(m) {
    return [ m[0].utc, m[1] ];
  });
  var d3_time_scaleUTCFormats = [ [ d3.time.format.utc("%Y"), d3_true ], [ d3.time.format.utc("%B"), function(d) {
    return d.getUTCMonth();
  } ], [ d3.time.format.utc("%b %d"), function(d) {
    return d.getUTCDate() != 1;
  } ], [ d3.time.format.utc("%a %d"), function(d) {
    return d.getUTCDay() && d.getUTCDate() != 1;
  } ], [ d3.time.format.utc("%I %p"), function(d) {
    return d.getUTCHours();
  } ], [ d3.time.format.utc("%I:%M"), function(d) {
    return d.getUTCMinutes();
  } ], [ d3.time.format.utc(":%S"), function(d) {
    return d.getUTCSeconds();
  } ], [ d3.time.format.utc(".%L"), function(d) {
    return d.getUTCMilliseconds();
  } ] ];
  var d3_time_scaleUTCFormat = d3_time_scaleFormat(d3_time_scaleUTCFormats);
  function d3_time_scaleUTCSetYear(y) {
    var d = new Date(Date.UTC(y, 0, 1));
    d.setUTCFullYear(y);
    return d;
  }
  function d3_time_scaleUTCGetYear(d) {
    var y = d.getUTCFullYear(), d0 = d3_time_scaleUTCSetYear(y), d1 = d3_time_scaleUTCSetYear(y + 1);
    return y + (d - d0) / (d1 - d0);
  }
  d3_time_scaleUTCMethods.year = function(extent, m) {
    return d3_time_scaleLinear.domain(extent.map(d3_time_scaleUTCGetYear)).ticks(m).map(d3_time_scaleUTCSetYear);
  };
  d3.time.scale.utc = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleUTCMethods, d3_time_scaleUTCFormat);
  };
  return d3;
}();d3.combobox = function() {
    var event = d3.dispatch('accept'),
        id = d3.combobox.id ++,
        data = [];

    var fetcher = function(val, data, cb) {
        cb(data.filter(function(d) {
            return d.title
                .toString()
                .toLowerCase()
                .indexOf(val.toLowerCase()) !== -1;
        }));
    };

    var typeahead = function(input) {
        var idx = -1, container, shown = false;

        input
            .classed('combobox-input', true)
            .each(function() {
                var parent = this.parentNode,
                    sibling = this.nextSibling;
                d3.select(parent)
                    .insert('div', function() { return sibling; })
                    .attr('class', 'combobox-carat')
                    .on('mousedown', function () {
                        // prevent the form element from blurring. it blurs
                        // on mousedown
                        d3.event.stopPropagation();
                        d3.event.preventDefault();
                        mousedown();
                    });
            });

        function updateSize() {
            var rect = input.node().getBoundingClientRect();
            container.style({
                'left': rect.left + 'px',
                'width': rect.width + 'px',
                'top': rect.height + rect.top + 'px'
            });
        }

        function blur() {
            // hide the combobox whenever the input element
            // loses focus
            slowHide();
        }

        function show() {
            if (!shown) {
                container = d3.select(document.body)
                    .insert('div', ':first-child')
                    .attr('class', 'combobox')
                    .style({
                        position: 'absolute',
                        display: 'block',
                        left: '0px'
                    });

                shown = true;
            }
        }

        function hide() {
            if (shown) {
                idx = -1;
                container.remove();
                shown = false;
            }
        }

        function slowHide() {
            window.setTimeout(hide, 150);
        }
        function keydown() {
           if (!shown) return;
           switch (d3.event.keyCode) {
               // down arrow
               case 40:
                   next();
                   d3.event.preventDefault();
                   break;
               // up arrow
               case 38:
                   prev();
                   d3.event.preventDefault();
                   break;
               // escape, tab
               case 13:
                   d3.event.preventDefault();
                   break;
           }
           d3.event.stopPropagation();
        }

        function keyup() {
            switch (d3.event.keyCode) {
                // escape
                case 27:
                    hide();
                    break;
                // escape, tab
                case 9:
                case 13:
                    if (!shown) return;
                    accept();
                    break;
                default:
                    update();
                    d3.event.preventDefault();
            }
            d3.event.stopPropagation();
        }

        function accept() {
            if (container.select('a.selected').node()) {
                select(container.select('a.selected').datum());
            }
            hide();
        }

        function next() {
            var len = container.selectAll('a').data().length;
            idx = Math.min(idx + 1, len - 1);
            highlight();
        }

        function prev() {
            idx = Math.max(idx - 1, 0);
            highlight();
        }

        var prevValue, prevCompletion;

        function autocomplete(e, data) {

            var value = input.property('value'),
                match;

            for (var i = 0; i < data.length; i++) {
                if (data[i].value.indexOf(value) === 0) {
                    match = data[i].value;
                    break;
                }
            }

            // backspace
            if (e.keyCode === 8) {
                prevValue = value;
                prevCompletion = '';

            } else if (value && match && value !== prevValue + prevCompletion) {
                prevValue = value;
                prevCompletion = match.substr(value.length);
                input.property('value', prevValue + prevCompletion);
                input.node().setSelectionRange(value.length, value.length + prevCompletion.length);
            }
        }


        function highlight() {
            container
                .selectAll('a')
                .classed('selected', function(d, i) { return i == idx; });
            var height = container.node().offsetHeight,
                top = container.select('a.selected').node().offsetTop,
                selectedHeight = container.select('a.selected').node().offsetHeight;
            if ((top + selectedHeight) < height) {
                container.node().scrollTop = 0;
            } else {
                container.node().scrollTop = top;
            }
        }

        function update(value) {

            if (typeof value === 'undefined') {
                value = input.property('value');
            }

            var e = d3.event;

            function render(data) {

                if (data.length &&
                    document.activeElement === input.node()) show();
                else return hide();

                autocomplete(e, data);

                updateSize();

                var options = container
                    .selectAll('a.combobox-option')
                    .data(data, function(d) { return d.value; });

                options.enter()
                    .append('a')
                    .text(function(d) { return d.value; })
                    .attr('class', 'combobox-option')
                    .attr('title', function(d) { return d.title; })
                    .on('click', select);

                options.exit().remove();

                options
                    .classed('selected', function(d, i) { return i == idx; })
                    .order();
            }

            fetcher.apply(input, [value, data, render]);
        }

        // select the choice given as d
        function select(d) {
            input
                .property('value', d.value)
                .trigger('change');
            event.accept(d);
            hide();
        }

        function mousedown() {

            if (shown) return hide();

            input.node().focus();
            update('');

            if (!container) return;

            var entries = container.selectAll('a'),
                height = container.node().scrollHeight / entries[0].length,
                w = d3.select(window);

            function getIndex(m) {
                return Math.floor((m[1] + container.node().scrollTop) / height);
            }

            function withinBounds(m) {
                var n = container.node();
                return m[0] >= 0 && m[0] < n.offsetWidth &&
                    m[1] >= 0 && m[1] < n.offsetHeight;
            }

            w.on('mousemove.typeahead', function() {
                var m = d3.mouse(container.node());
                var within = withinBounds(m);
                var n = getIndex(m);
                entries.classed('selected', function(d, i) { return within && i === n; });
            });

            w.on('mouseup.typeahead', function() {
                var m = d3.mouse(container.node());
                if (withinBounds(m)) select(d3.select(entries[0][getIndex(m)]).datum());
                entries.classed('selected', false);
                w.on('mouseup.typeahead', null);
                w.on('mousemove.typeahead', null);
            });
        }

        input
            .on('blur.typeahead', blur)
            .on('keydown.typeahead', keydown)
            .on('keyup.typeahead', keyup)
            .on('mousedown.typeahead', mousedown);

        d3.select(document.body).on('scroll.combo' + id, function() {
            if (shown) updateSize();
        }, true);
    };

    typeahead.fetcher = function(_) {
        if (!arguments.length) return fetcher;
        fetcher = _;
        return typeahead;
    };

    typeahead.data = function(_) {
        if (!arguments.length) return data;
        data = _;
        return typeahead;
    };

    return d3.rebind(typeahead, event, 'on');
};

d3.combobox.id = 0;
d3.geo.tile = function() {
  var size = [960, 500],
      scale = 256,
      scaleExtent = [0, 20],
      translate = [size[0] / 2, size[1] / 2],
      zoomDelta = 0;

  function bound(_) {
      return Math.min(scaleExtent[1], Math.max(scaleExtent[0], _));
  }

  function tile() {
    var z = Math.max(Math.log(scale) / Math.LN2 - 8, 0),
        z0 = bound(Math.round(z + zoomDelta)),
        k = Math.pow(2, z - z0 + 8),
        origin = [(translate[0] - scale / 2) / k, (translate[1] - scale / 2) / k],
        tiles = [],
        cols = d3.range(Math.max(0, Math.floor(-origin[0])), Math.max(0, Math.ceil(size[0] / k - origin[0]))),
        rows = d3.range(Math.max(0, Math.floor(-origin[1])), Math.max(0, Math.ceil(size[1] / k - origin[1])));

    rows.forEach(function(y) {
      cols.forEach(function(x) {
        tiles.push([x, y, z0]);
      });
    });

    tiles.translate = origin;
    tiles.scale = k;

    return tiles;
  }

  tile.scaleExtent = function(_) {
    if (!arguments.length) return scaleExtent;
    scaleExtent = _;
    return tile;
  };

  tile.size = function(_) {
    if (!arguments.length) return size;
    size = _;
    return tile;
  };

  tile.scale = function(_) {
    if (!arguments.length) return scale;
    scale = _;
    return tile;
  };

  tile.translate = function(_) {
    if (!arguments.length) return translate;
    translate = _;
    return tile;
  };

  tile.zoomDelta = function(_) {
    if (!arguments.length) return zoomDelta;
    zoomDelta = +_;
    return tile;
  };

  return tile;
};
d3.jsonp = function (url, callback) {
  function rand() {
    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',
      c = '', i = -1;
    while (++i < 15) c += chars.charAt(Math.floor(Math.random() * 52));
    return c;
  }

  function create(url) {
    var e = url.match(/callback=d3.jsonp.(\w+)/),
      c = e ? e[1] : rand();
    d3.jsonp[c] = function(data) {
      callback(data);
      delete d3.jsonp[c];
      script.remove();
    };
    return 'd3.jsonp.' + c;
  }

  var cb = create(url),
    script = d3.select('head')
    .append('script')
    .attr('type', 'text/javascript')
    .attr('src', url.replace(/(\{|%7B)callback(\}|%7D)/, cb));
};
/*
 * This code is licensed under the MIT license.
 *
 * Copyright © 2013, iD authors.
 *
 * Portions copyright © 2011, Keith Cirkel
 * See https://github.com/keithamus/jwerty
 *
 */
d3.keybinding = function(namespace) {
    var bindings = [];

    function matches(binding, event) {
        for (var p in binding.event) {
            if (event[p] != binding.event[p])
                return false;
        }

        return (!binding.capture) === (event.eventPhase !== Event.CAPTURING_PHASE);
    }

    function capture() {
        for (var i = 0; i < bindings.length; i++) {
            var binding = bindings[i];
            if (matches(binding, d3.event)) {
                binding.callback();
            }
        }
    }

    function bubble() {
        var tagName = d3.select(d3.event.target).node().tagName;
        if (tagName == 'INPUT' || tagName == 'SELECT' || tagName == 'TEXTAREA') {
            return;
        }
        capture();
    }

    function keybinding(selection) {
        selection = selection || d3.select(document);
        selection.on('keydown.capture' + namespace, capture, true);
        selection.on('keydown.bubble' + namespace, bubble, false);
        return keybinding;
    }

    keybinding.off = function(selection) {
        selection = selection || d3.select(document);
        selection.on('keydown.capture' + namespace, null);
        selection.on('keydown.bubble' + namespace, null);
        return keybinding;
    };

    keybinding.on = function(code, callback, capture) {
        var binding = {
            event: {
                keyCode: 0,
                shiftKey: false,
                ctrlKey: false,
                altKey: false,
                metaKey: false
            },
            capture: capture,
            callback: callback
        };

        code = code.toLowerCase().match(/(?:(?:[^+⇧⌃⌥⌘])+|[⇧⌃⌥⌘]|\+\+|^\+$)/g);

        for (var i = 0; i < code.length; i++) {
            // Normalise matching errors
            if (code[i] === '++') code[i] = '+';

            if (code[i] in d3.keybinding.modifierCodes) {
                binding.event[d3.keybinding.modifierProperties[d3.keybinding.modifierCodes[code[i]]]] = true;
            } else if (code[i] in d3.keybinding.keyCodes) {
                binding.event.keyCode = d3.keybinding.keyCodes[code[i]];
            }
        }

        bindings.push(binding);

        return keybinding;
    };

    return keybinding;
};

(function () {
    d3.keybinding.modifierCodes = {
        // Shift key, ⇧
        '⇧': 16, shift: 16,
        // CTRL key, on Mac: ⌃
        '⌃': 17, ctrl: 17,
        // ALT key, on Mac: ⌥ (Alt)
        '⌥': 18, alt: 18, option: 18,
        // META, on Mac: ⌘ (CMD), on Windows (Win), on Linux (Super)
        '⌘': 91, meta: 91, cmd: 91, 'super': 91, win: 91
    };

    d3.keybinding.modifierProperties = {
        16: 'shiftKey',
        17: 'ctrlKey',
        18: 'altKey',
        91: 'metaKey'
    };

    d3.keybinding.keyCodes = {
        // Backspace key, on Mac: ⌫ (Backspace)
        '⌫': 8, backspace: 8,
        // Tab Key, on Mac: ⇥ (Tab), on Windows ⇥⇥
        '⇥': 9, '⇆': 9, tab: 9,
        // Return key, ↩
        '↩': 13, 'return': 13, enter: 13, '⌅': 13,
        // Pause/Break key
        'pause': 19, 'pause-break': 19,
        // Caps Lock key, ⇪
        '⇪': 20, caps: 20, 'caps-lock': 20,
        // Escape key, on Mac: ⎋, on Windows: Esc
        '⎋': 27, escape: 27, esc: 27,
        // Space key
        space: 32,
        // Page-Up key, or pgup, on Mac: ↖
        '↖': 33, pgup: 33, 'page-up': 33,
        // Page-Down key, or pgdown, on Mac: ↘
        '↘': 34, pgdown: 34, 'page-down': 34,
        // END key, on Mac: ⇟
        '⇟': 35, end: 35,
        // HOME key, on Mac: ⇞
        '⇞': 36, home: 36,
        // Insert key, or ins
        ins: 45, insert: 45,
        // Delete key, on Mac: ⌦ (Delete)
        '⌦': 46, del: 46, 'delete': 46,
        // Left Arrow Key, or ←
        '←': 37, left: 37, 'arrow-left': 37,
        // Up Arrow Key, or ↑
        '↑': 38, up: 38, 'arrow-up': 38,
        // Right Arrow Key, or →
        '→': 39, right: 39, 'arrow-right': 39,
        // Up Arrow Key, or ↓
        '↓': 40, down: 40, 'arrow-down': 40,
        // odities, printing characters that come out wrong:
        // Num-Multiply, or *
        '*': 106, star: 106, asterisk: 106, multiply: 106,
        // Num-Plus or +
        '+': 107, 'plus': 107,
        // Num-Subtract, or -
        '-': 109, subtract: 109,
        // Semicolon
        ';': 186, semicolon:186,
        // = or equals
        '=': 187, 'equals': 187,
        // Comma, or ,
        ',': 188, comma: 188,
        'dash': 189, //???
        // Period, or ., or full-stop
        '.': 190, period: 190, 'full-stop': 190,
        // Slash, or /, or forward-slash
        '/': 191, slash: 191, 'forward-slash': 191,
        // Tick, or `, or back-quote
        '`': 192, tick: 192, 'back-quote': 192,
        // Open bracket, or [
        '[': 219, 'open-bracket': 219,
        // Back slash, or \
        '\\': 220, 'back-slash': 220,
        // Close backet, or ]
        ']': 221, 'close-bracket': 221,
        // Apostrophe, or Quote, or '
        '\'': 222, quote: 222, apostrophe: 222
    };

    // NUMPAD 0-9
    var i = 95, n = 0;
    while (++i < 106) {
        d3.keybinding.keyCodes['num-' + n] = i;
        ++n;
    }

    // 0-9
    i = 47; n = 0;
    while (++i < 58) {
        d3.keybinding.keyCodes[n] = i;
        ++n;
    }

    // F1-F25
    i = 111; n = 1;
    while (++i < 136) {
        d3.keybinding.keyCodes['f' + n] = i;
        ++n;
    }

    // a-z
    i = 64;
    while (++i < 91) {
        d3.keybinding.keyCodes[String.fromCharCode(i).toLowerCase()] = i;
    }
})();
d3.selection.prototype.one = function (type, listener, capture) {
    var target = this, typeOnce = type + ".once";
    function one() {
        target.on(typeOnce, null);
        listener.apply(this, arguments);
    }
    target.on(typeOnce, one, capture);
    return this;
};
d3.selection.prototype.size = function (size) {
    if (!arguments.length) {
        var node = this.node();
        return [node.offsetWidth,
                node.offsetHeight];
    }
    return this.attr({width: size[0], height: size[1]});
};
d3.selection.prototype.trigger = function (type) {
    this.each(function() {
        var evt = document.createEvent('HTMLEvents');
        evt.initEvent(type, true, true);
        this.dispatchEvent(evt);
    });
};
d3.typeahead = function() {
    var event = d3.dispatch('accept'),
        autohighlight = false,
        data;

    var typeahead = function(selection) {
        var container,
            hidden,
            idx = autohighlight ? 0 : -1;

        function setup() {
            var rect = selection.node().getBoundingClientRect();
            container = d3.select(document.body)
                .append('div').attr('class', 'typeahead')
                .style({
                    position: 'absolute',
                    left: rect.left + 'px',
                    top: rect.bottom + 'px'
                });
            selection
                .on('keyup.typeahead', key);
            hidden = false;
        }

        function hide() {
            container.remove();
            idx = autohighlight ? 0 : -1;
            hidden = true;
        }

        function slowHide() {
            if (autohighlight) {
                if (container.select('a.selected').node()) {
                    select(container.select('a.selected').datum());
                    event.accept();
                }
            }
            window.setTimeout(hide, 150);
        }

        selection
            .on('focus.typeahead', setup)
            .on('blur.typeahead', slowHide);

        function key() {
           var len = container.selectAll('a').data().length;
           if (d3.event.keyCode === 40) {
               idx = Math.min(idx + 1, len - 1);
               return highlight();
           } else if (d3.event.keyCode === 38) {
               idx = Math.max(idx - 1, 0);
               return highlight();
           } else if (d3.event.keyCode === 13) {
               if (container.select('a.selected').node()) {
                   select(container.select('a.selected').datum());
               }
               event.accept();
               hide();
           } else {
               update();
           }
        }

        function highlight() {
            container
                .selectAll('a')
                .classed('selected', function(d, i) { return i == idx; });
        }

        function update() {
            if (hidden) setup();

            data(selection, function(data) {
                container.style('display', function() {
                    return data.length ? 'block' : 'none';
                });

                var options = container
                    .selectAll('a')
                    .data(data, function(d) { return d.value; });

                options.enter()
                    .append('a')
                    .text(function(d) { return d.value; })
                    .attr('title', function(d) { return d.title; })
                    .on('click', select);

                options.exit().remove();

                options
                    .classed('selected', function(d, i) { return i == idx; });
            });
        }

        function select(d) {
            selection
                .property('value', d.value)
                .trigger('change');
        }

    };

    typeahead.data = function(_) {
        if (!arguments.length) return data;
        data = _;
        return typeahead;
    };

    typeahead.autohighlight = function(_) {
        if (!arguments.length) return autohighlight;
        autohighlight = _;
        return typeahead;
    };

    return d3.rebind(typeahead, event, 'on');
};
const JXON = new (function () {
  const
    sValueProp = "keyValue", sAttributesProp = "keyAttributes", sAttrPref = "@", /* you can customize these values */
    aCache = [], rIsNull = /^\s*$/, rIsBool = /^(?:true|false)$/i;

  function parseText (sValue) {
    if (rIsNull.test(sValue)) { return null; }
    if (rIsBool.test(sValue)) { return sValue.toLowerCase() === "true"; }
    if (isFinite(sValue)) { return parseFloat(sValue); }
    if (isFinite(Date.parse(sValue))) { return new Date(sValue); }
    return sValue;
  }

  function EmptyTree () { }
  EmptyTree.prototype.toString = function () { return "null"; };
  EmptyTree.prototype.valueOf = function () { return null; };

  function objectify (vValue) {
    return vValue === null ? new EmptyTree() : vValue instanceof Object ? vValue : new vValue.constructor(vValue);
  }

  function createObjTree (oParentNode, nVerb, bFreeze, bNesteAttr) {
    const
      nLevelStart = aCache.length, bChildren = oParentNode.hasChildNodes(),
      bAttributes = oParentNode.hasAttributes(), bHighVerb = Boolean(nVerb & 2);

    var
      sProp, vContent, nLength = 0, sCollectedTxt = "",
      vResult = bHighVerb ? {} : /* put here the default value for empty nodes: */ true;

    if (bChildren) {
      for (var oNode, nItem = 0; nItem < oParentNode.childNodes.length; nItem++) {
        oNode = oParentNode.childNodes.item(nItem);
        if (oNode.nodeType === 4) { sCollectedTxt += oNode.nodeValue; } /* nodeType is "CDATASection" (4) */
        else if (oNode.nodeType === 3) { sCollectedTxt += oNode.nodeValue.trim(); } /* nodeType is "Text" (3) */
        else if (oNode.nodeType === 1 && !oNode.prefix) { aCache.push(oNode); } /* nodeType is "Element" (1) */
      }
    }

    const nLevelEnd = aCache.length, vBuiltVal = parseText(sCollectedTxt);

    if (!bHighVerb && (bChildren || bAttributes)) { vResult = nVerb === 0 ? objectify(vBuiltVal) : {}; }

    for (var nElId = nLevelStart; nElId < nLevelEnd; nElId++) {
      sProp = aCache[nElId].nodeName.toLowerCase();
      vContent = createObjTree(aCache[nElId], nVerb, bFreeze, bNesteAttr);
      if (vResult.hasOwnProperty(sProp)) {
        if (vResult[sProp].constructor !== Array) { vResult[sProp] = [vResult[sProp]]; }
        vResult[sProp].push(vContent);
      } else {
        vResult[sProp] = vContent;
        nLength++;
      }
    }

    if (bAttributes) {
      const
        nAttrLen = oParentNode.attributes.length,
        sAPrefix = bNesteAttr ? "" : sAttrPref, oAttrParent = bNesteAttr ? {} : vResult;

      for (var oAttrib, nAttrib = 0; nAttrib < nAttrLen; nLength++, nAttrib++) {
        oAttrib = oParentNode.attributes.item(nAttrib);
        oAttrParent[sAPrefix + oAttrib.name.toLowerCase()] = parseText(oAttrib.value.trim());
      }

      if (bNesteAttr) {
        if (bFreeze) { Object.freeze(oAttrParent); }
        vResult[sAttributesProp] = oAttrParent;
        nLength -= nAttrLen - 1;
      }
    }

    if (nVerb === 3 || (nVerb === 2 || nVerb === 1 && nLength > 0) && sCollectedTxt) {
      vResult[sValueProp] = vBuiltVal;
    } else if (!bHighVerb && nLength === 0 && sCollectedTxt) {
      vResult = vBuiltVal;
    }

    if (bFreeze && (bHighVerb || nLength > 0)) { Object.freeze(vResult); }

    aCache.length = nLevelStart;

    return vResult;
  }

  function loadObjTree (oXMLDoc, oParentEl, oParentObj) {
    var vValue, oChild;

    if (oParentObj instanceof String || oParentObj instanceof Number || oParentObj instanceof Boolean) {
      oParentEl.appendChild(oXMLDoc.createTextNode(oParentObj.toString())); /* verbosity level is 0 */
    } else if (oParentObj.constructor === Date) {
      oParentEl.appendChild(oXMLDoc.createTextNode(oParentObj.toGMTString()));    
    }

    for (var sName in oParentObj) {
      vValue = oParentObj[sName];
      if (isFinite(sName) || vValue instanceof Function) { continue; } /* verbosity level is 0 */
      if (sName === sValueProp) {
        if (vValue !== null && vValue !== true) { oParentEl.appendChild(oXMLDoc.createTextNode(vValue.constructor === Date ? vValue.toGMTString() : String(vValue))); }
      } else if (sName === sAttributesProp) { /* verbosity level is 3 */
        for (var sAttrib in vValue) { oParentEl.setAttribute(sAttrib, vValue[sAttrib]); }
      } else if (sName.charAt(0) === sAttrPref) {
        oParentEl.setAttribute(sName.slice(1), vValue);
      } else if (vValue.constructor === Array) {
        for (var nItem = 0; nItem < vValue.length; nItem++) {
          oChild = oXMLDoc.createElement(sName);
          loadObjTree(oXMLDoc, oChild, vValue[nItem]);
          oParentEl.appendChild(oChild);
        }
      } else {
        oChild = oXMLDoc.createElement(sName);
        if (vValue instanceof Object) {
          loadObjTree(oXMLDoc, oChild, vValue);
        } else if (vValue !== null && vValue !== true) {
          oChild.appendChild(oXMLDoc.createTextNode(vValue.toString()));
        }
        oParentEl.appendChild(oChild);
     }
   }
  }

  this.build = function (oXMLParent, nVerbosity /* optional */, bFreeze /* optional */, bNesteAttributes /* optional */) {
    const _nVerb = arguments.length > 1 && typeof nVerbosity === "number" ? nVerbosity & 3 : /* put here the default verbosity level: */ 1;
    return createObjTree(oXMLParent, _nVerb, bFreeze || false, arguments.length > 3 ? bNesteAttributes : _nVerb === 3);    
  };

  this.unbuild = function (oObjTree) {    
    const oNewDoc = document.implementation.createDocument("", "", null);
    loadObjTree(oNewDoc, oNewDoc, oObjTree);
    return oNewDoc;
  };

  this.stringify = function (oObjTree) {
    return (new XMLSerializer()).serializeToString(JXON.unbuild(oObjTree));
  };
})();
// var myObject = JXON.build(doc);
// we got our javascript object! try: alert(JSON.stringify(myObject));

// var newDoc = JXON.unbuild(myObject);
// we got our Document instance! try: alert((new XMLSerializer()).serializeToString(newDoc));
/*!
 * Lo-Dash 1.0.0-rc.3 <http://lodash.com>
 * (c) 2012 John-David Dalton <http://allyoucanleet.com/>
 * Based on Underscore.js 1.4.3 <http://underscorejs.org>
 * (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.
 * Available under MIT license <http://lodash.com/license>
 */
;(function(window, undefined) {

  /** Detect free variable `exports` */
  var freeExports = typeof exports == 'object' && exports;

  /** Detect free variable `global` and use it as `window` */
  var freeGlobal = typeof global == 'object' && global;
  if (freeGlobal.global === freeGlobal) {
    window = freeGlobal;
  }

  /** Used for array and object method references */
  var arrayRef = [],
      // avoid a Closure Compiler bug by creatively creating an object
      objectRef = new function(){};

  /** Used to generate unique IDs */
  var idCounter = 0;

  /** Used internally to indicate various things */
  var indicatorObject = objectRef;

  /** Used by `cachedContains` as the default size when optimizations are enabled for large arrays */
  var largeArraySize = 30;

  /** Used to restore the original `_` reference in `noConflict` */
  var oldDash = window._;

  /** Used to detect template delimiter values that require a with-statement */
  var reComplexDelimiter = /[-?+=!~*%&^<>|{(\/]|\[\D|\b(?:delete|in|instanceof|new|typeof|void)\b/;

  /** Used to match HTML entities */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#x27);/g;

  /** Used to match empty string literals in compiled template source */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match regexp flags from their coerced string values */
  var reFlags = /\w*$/;

  /** Used to insert the data object variable into compiled template source */
  var reInsertVariable = /(?:__e|__t = )\(\s*(?![\d\s"']|this\.)/g;

  /** Used to detect if a method is native */
  var reNative = RegExp('^' +
    (objectRef.valueOf + '')
      .replace(/[.*+?^=!:${}()|[\]\/\\]/g, '\\$&')
      .replace(/valueOf|for [^\]]+/g, '.+?') + '$'
  );

  /**
   * Used to match ES6 template delimiters
   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-7.8.6
   */
  var reEsTemplate = /\$\{((?:(?=\\?)\\?[\s\S])*?)}/g;

  /** Used to match "interpolate" template delimiters */
  var reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to ensure capturing order of template delimiters */
  var reNoMatch = /($^)/;

  /** Used to match HTML characters */
  var reUnescapedHtml = /[&<>"']/g;

  /** Used to match unescaped characters in compiled string literals */
  var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;

  /** Used to fix the JScript [[DontEnum]] bug */
  var shadowed = [
    'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',
    'toLocaleString', 'toString', 'valueOf'
  ];

  /** Used to make template sourceURLs easier to identify */
  var templateCounter = 0;

  /** Native method shortcuts */
  var ceil = Math.ceil,
      concat = arrayRef.concat,
      floor = Math.floor,
      getPrototypeOf = reNative.test(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
      hasOwnProperty = objectRef.hasOwnProperty,
      push = arrayRef.push,
      propertyIsEnumerable = objectRef.propertyIsEnumerable,
      toString = objectRef.toString;

  /* Native method shortcuts for methods with the same name as other `lodash` methods */
  var nativeBind = reNative.test(nativeBind = slice.bind) && nativeBind,
      nativeIsArray = reNative.test(nativeIsArray = Array.isArray) && nativeIsArray,
      nativeIsFinite = window.isFinite,
      nativeIsNaN = window.isNaN,
      nativeKeys = reNative.test(nativeKeys = Object.keys) && nativeKeys,
      nativeMax = Math.max,
      nativeMin = Math.min,
      nativeRandom = Math.random;

  /** `Object#toString` result shortcuts */
  var argsClass = '[object Arguments]',
      arrayClass = '[object Array]',
      boolClass = '[object Boolean]',
      dateClass = '[object Date]',
      funcClass = '[object Function]',
      numberClass = '[object Number]',
      objectClass = '[object Object]',
      regexpClass = '[object RegExp]',
      stringClass = '[object String]';

  /** Detect various environments */
  var isIeOpera = !!window.attachEvent,
      isV8 = nativeBind && !/\n|true/.test(nativeBind + isIeOpera);

  /* Detect if `Function#bind` exists and is inferred to be fast (all but V8) */
  var isBindFast = nativeBind && !isV8;

  /* Detect if `Object.keys` exists and is inferred to be fast (IE, Opera, V8) */
  var isKeysFast = nativeKeys && (isIeOpera || isV8);

  /**
   * Detect the JScript [[DontEnum]] bug:
   *
   * In IE < 9 an objects own properties, shadowing non-enumerable ones, are
   * made non-enumerable as well.
   */
  var hasDontEnumBug;

  /** Detect if own properties are iterated after inherited properties (IE < 9) */
  var iteratesOwnLast;

  /**
   * Detect if `Array#shift` and `Array#splice` augment array-like objects
   * incorrectly:
   *
   * Firefox < 10, IE compatibility mode, and IE < 9 have buggy Array `shift()`
   * and `splice()` functions that fail to remove the last element, `value[0]`,
   * of array-like objects even though the `length` property is set to `0`.
   * The `shift()` method is buggy in IE 8 compatibility mode, while `splice()`
   * is buggy regardless of mode in IE < 9 and buggy in compatibility mode in IE 9.
   */
  var hasObjectSpliceBug = (hasObjectSpliceBug = { '0': 1, 'length': 1 },
    arrayRef.splice.call(hasObjectSpliceBug, 0, 1), hasObjectSpliceBug[0]);

  /** Detect if an `arguments` object's indexes are non-enumerable (IE < 9) */
  var nonEnumArgs = true;

  (function() {
    var props = [];
    function ctor() { this.x = 1; }
    ctor.prototype = { 'valueOf': 1, 'y': 1 };
    for (var prop in new ctor) { props.push(prop); }
    for (prop in arguments) { nonEnumArgs = !prop; }

    hasDontEnumBug = !/valueOf/.test(props);
    iteratesOwnLast = props[0] != 'x';
  }(1));

  /** Detect if `arguments` objects are `Object` objects (all but Opera < 10.5) */
  var argsAreObjects = arguments.constructor == Object;

  /** Detect if `arguments` objects [[Class]] is unresolvable (Firefox < 4, IE < 9) */
  var noArgsClass = !isArguments(arguments);

  /**
   * Detect lack of support for accessing string characters by index:
   *
   * IE < 8 can't access characters by index and IE 8 can only access
   * characters by index on string literals.
   */
  var noCharByIndex = ('x'[0] + Object('x')[0]) != 'xx';

  /**
   * Detect if a node's [[Class]] is unresolvable (IE < 9)
   * and that the JS engine won't error when attempting to coerce an object to
   * a string without a `toString` property value of `typeof` "function".
   */
  try {
    var noNodeClass = ({ 'toString': 0 } + '', toString.call(document) == objectClass);
  } catch(e) { }

  /**
   * Detect if sourceURL syntax is usable without erroring:
   *
   * The JS engine embedded in Adobe products will throw a syntax error when
   * it encounters a single line comment beginning with the `@` symbol.
   *
   * The JS engine in Narwhal will generate the function `function anonymous(){//}`
   * and throw a syntax error.
   *
   * Avoid comments beginning `@` symbols in IE because they are part of its
   * non-standard conditional compilation support.
   * http://msdn.microsoft.com/en-us/library/121hztk3(v=vs.94).aspx
   */
  try {
    var useSourceURL = (Function('//@')(), !isIeOpera);
  } catch(e) { }

  /** Used to identify object classifications that `_.clone` supports */
  var cloneableClasses = {};
  cloneableClasses[funcClass] = false;
  cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
  cloneableClasses[boolClass] = cloneableClasses[dateClass] =
  cloneableClasses[numberClass] = cloneableClasses[objectClass] =
  cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;

  /** Used to lookup a built-in constructor by [[Class]] */
  var ctorByClass = {};
  ctorByClass[arrayClass] = Array;
  ctorByClass[boolClass] = Boolean;
  ctorByClass[dateClass] = Date;
  ctorByClass[objectClass] = Object;
  ctorByClass[numberClass] = Number;
  ctorByClass[regexpClass] = RegExp;
  ctorByClass[stringClass] = String;

  /** Used to determine if values are of the language type Object */
  var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
  };

  /** Used to escape characters for inclusion in compiled string literals */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\t': 't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a `lodash` object, that wraps the given `value`, to enable
   * method chaining.
   *
   * The chainable wrapper functions are:
   * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`, `compose`,
   * `concat`, `countBy`, `debounce`, `defaults`, `defer`, `delay`, `difference`,
   * `filter`, `flatten`, `forEach`, `forIn`, `forOwn`, `functions`, `groupBy`,
   * `initial`, `intersection`, `invert`, `invoke`, `keys`, `map`, `max`, `memoize`,
   * `merge`, `min`, `object`, `omit`, `once`, `pairs`, `partial`, `pick`, `pluck`,
   * `push`, `range`, `reject`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
   * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `union`, `uniq`,
   * `unshift`, `values`, `where`, `without`, `wrap`, and `zip`
   *
   * The non-chainable wrapper functions are:
   * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `has`, `identity`,
   * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`, `isEmpty`,
   * `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`, `isObject`,
   * `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`, `lastIndexOf`,
   * `mixin`, `noConflict`, `pop`, `random`, `reduce`, `reduceRight`, `result`,
   * `shift`, `size`, `some`, `sortedIndex`, `template`, `unescape`, and `uniqueId`
   *
   * The wrapper functions `first` and `last` return wrapped values when `n` is
   * passed, otherwise they return unwrapped values.
   *
   * @name _
   * @constructor
   * @category Chaining
   * @param {Mixed} value The value to wrap in a `lodash` instance.
   * @returns {Object} Returns a `lodash` instance.
   */
  function lodash(value) {
    // exit early if already wrapped, even if wrapped by a different `lodash` constructor
    if (value && typeof value == 'object' && value.__wrapped__) {
      return value;
    }
    // allow invoking `lodash` without the `new` operator
    if (!(this instanceof lodash)) {
      return new lodash(value);
    }
    this.__wrapped__ = value;
  }

  /**
   * By default, the template delimiters used by Lo-Dash are similar to those in
   * embedded Ruby (ERB). Change the following template settings to use alternative
   * delimiters.
   *
   * @static
   * @memberOf _
   * @type Object
   */
  lodash.templateSettings = {

    /**
     * Used to detect `data` property values to be HTML-escaped.
     *
     * @static
     * @memberOf _.templateSettings
     * @type RegExp
     */
    'escape': /<%-([\s\S]+?)%>/g,

    /**
     * Used to detect code to be evaluated.
     *
     * @static
     * @memberOf _.templateSettings
     * @type RegExp
     */
    'evaluate': /<%([\s\S]+?)%>/g,

    /**
     * Used to detect `data` property values to inject.
     *
     * @static
     * @memberOf _.templateSettings
     * @type RegExp
     */
    'interpolate': reInterpolate,

    /**
     * Used to reference the data object in the template text.
     *
     * @static
     * @memberOf _.templateSettings
     * @type String
     */
    'variable': ''
  };

  /*--------------------------------------------------------------------------*/

  /**
   * The template used to create iterator functions.
   *
   * @private
   * @param {Obect} data The data object used to populate the text.
   * @returns {String} Returns the interpolated text.
   */
  var iteratorTemplate = template(
    // conditional strict mode
    "<% if (obj.useStrict) { %>'use strict';\n<% } %>" +

    // the `iteratee` may be reassigned by the `top` snippet
    'var index, iteratee = <%= firstArg %>, ' +
    // assign the `result` variable an initial value
    'result = <%= firstArg %>;\n' +
    // exit early if the first argument is falsey
    'if (!<%= firstArg %>) return result;\n' +
    // add code before the iteration branches
    '<%= top %>;\n' +

    // array-like iteration:
    '<% if (arrayLoop) { %>' +
    'var length = iteratee.length; index = -1;\n' +
    "if (typeof length == 'number') {" +

    // add support for accessing string characters by index if needed
    '  <% if (noCharByIndex) { %>\n' +
    '  if (isString(iteratee)) {\n' +
    "    iteratee = iteratee.split('')\n" +
    '  }' +
    '  <% } %>\n' +

    // iterate over the array-like value
    '  while (++index < length) {\n' +
    '    <%= arrayLoop %>\n' +
    '  }\n' +
    '}\n' +
    'else {' +

    // object iteration:
    // add support for iterating over `arguments` objects if needed
    '  <%  } else if (nonEnumArgs) { %>\n' +
    '  var length = iteratee.length; index = -1;\n' +
    '  if (length && isArguments(iteratee)) {\n' +
    '    while (++index < length) {\n' +
    "      index += '';\n" +
    '      <%= objectLoop %>\n' +
    '    }\n' +
    '  } else {' +
    '  <% } %>' +

    // Firefox < 3.6, Opera > 9.50 - Opera < 11.60, and Safari < 5.1
    // (if the prototype or a property on the prototype has been set)
    // incorrectly sets a function's `prototype` property [[Enumerable]]
    // value to `true`. Because of this Lo-Dash standardizes on skipping
    // the the `prototype` property of functions regardless of its
    // [[Enumerable]] value.
    '  <% if (!hasDontEnumBug) { %>\n' +
    "  var skipProto = typeof iteratee == 'function' && \n" +
    "    propertyIsEnumerable.call(iteratee, 'prototype');\n" +
    '  <% } %>' +

    // iterate own properties using `Object.keys` if it's fast
    '  <% if (isKeysFast && useHas) { %>\n' +
    '  var ownIndex = -1,\n' +
    '      ownProps = objectTypes[typeof iteratee] ? nativeKeys(iteratee) : [],\n' +
    '      length = ownProps.length;\n\n' +
    '  while (++ownIndex < length) {\n' +
    '    index = ownProps[ownIndex];\n' +
    "    <% if (!hasDontEnumBug) { %>if (!(skipProto && index == 'prototype')) {\n  <% } %>" +
    '    <%= objectLoop %>\n' +
    '    <% if (!hasDontEnumBug) { %>}\n<% } %>' +
    '  }' +

    // else using a for-in loop
    '  <% } else { %>\n' +
    '  for (index in iteratee) {<%' +
    '    if (!hasDontEnumBug || useHas) { %>\n    if (<%' +
    "      if (!hasDontEnumBug) { %>!(skipProto && index == 'prototype')<% }" +
    '      if (!hasDontEnumBug && useHas) { %> && <% }' +
    '      if (useHas) { %>hasOwnProperty.call(iteratee, index)<% }' +
    '    %>) {' +
    '    <% } %>\n' +
    '    <%= objectLoop %>;' +
    '    <% if (!hasDontEnumBug || useHas) { %>\n    }<% } %>\n' +
    '  }' +
    '  <% } %>' +

    // Because IE < 9 can't set the `[[Enumerable]]` attribute of an
    // existing property and the `constructor` property of a prototype
    // defaults to non-enumerable, Lo-Dash skips the `constructor`
    // property when it infers it's iterating over a `prototype` object.
    '  <% if (hasDontEnumBug) { %>\n\n' +
    '  var ctor = iteratee.constructor;\n' +
    '    <% for (var k = 0; k < 7; k++) { %>\n' +
    "  index = '<%= shadowed[k] %>';\n" +
    '  if (<%' +
    "      if (shadowed[k] == 'constructor') {" +
    '        %>!(ctor && ctor.prototype === iteratee) && <%' +
    '      } %>hasOwnProperty.call(iteratee, index)) {\n' +
    '    <%= objectLoop %>\n' +
    '  }' +
    '    <% } %>' +
    '  <% } %>' +
    '  <% if (arrayLoop || nonEnumArgs) { %>\n}<% } %>\n' +

    // add code to the bottom of the iteration function
    '<%= bottom %>;\n' +
    // finally, return the `result`
    'return result'
  );

  /** Reusable iterator options for `assign` and `defaults` */
  var assignIteratorOptions = {
    'args': 'object, source, guard',
    'top':
      "for (var argsIndex = 1, argsLength = typeof guard == 'number' ? 2 : arguments.length; argsIndex < argsLength; argsIndex++) {\n" +
      '  if ((iteratee = arguments[argsIndex])) {',
    'objectLoop': 'result[index] = iteratee[index]',
    'bottom': '  }\n}'
  };

  /**
   * Reusable iterator options shared by `each`, `forIn`, and `forOwn`.
   */
  var eachIteratorOptions = {
    'args': 'collection, callback, thisArg',
    'top': "callback = callback && typeof thisArg == 'undefined' ? callback : createCallback(callback, thisArg)",
    'arrayLoop': 'if (callback(iteratee[index], index, collection) === false) return result',
    'objectLoop': 'if (callback(iteratee[index], index, collection) === false) return result'
  };

  /** Reusable iterator options for `forIn` and `forOwn` */
  var forOwnIteratorOptions = {
    'arrayLoop': null
  };

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a function optimized to search large arrays for a given `value`,
   * starting at `fromIndex`, using strict equality for comparisons, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {Mixed} value The value to search for.
   * @param {Number} [fromIndex=0] The index to search from.
   * @param {Number} [largeSize=30] The length at which an array is considered large.
   * @returns {Boolean} Returns `true` if `value` is found, else `false`.
   */
  function cachedContains(array, fromIndex, largeSize) {
    fromIndex || (fromIndex = 0);

    var length = array.length,
        isLarge = (length - fromIndex) >= (largeSize || largeArraySize);

    if (isLarge) {
      var cache = {},
          index = fromIndex - 1;

      while (++index < length) {
        // manually coerce `value` to a string because `hasOwnProperty`, in some
        // older versions of Firefox, coerces objects incorrectly
        var key = array[index] + '';
        (hasOwnProperty.call(cache, key) ? cache[key] : (cache[key] = [])).push(array[index]);
      }
    }
    return function(value) {
      if (isLarge) {
        var key = value + '';
        return hasOwnProperty.call(cache, key) && indexOf(cache[key], value) > -1;
      }
      return indexOf(array, value, fromIndex) > -1;
    }
  }

  /**
   * Used by `_.max` and `_.min` as the default `callback` when a given
   * `collection` is a string value.
   *
   * @private
   * @param {String} value The character to inspect.
   * @returns {Number} Returns the code unit of given character.
   */
  function charAtCallback(value) {
    return value.charCodeAt(0);
  }

  /**
   * Used by `sortBy` to compare transformed `collection` values, stable sorting
   * them in ascending order.
   *
   * @private
   * @param {Object} a The object to compare to `b`.
   * @param {Object} b The object to compare to `a`.
   * @returns {Number} Returns the sort order indicator of `1` or `-1`.
   */
  function compareAscending(a, b) {
    var ai = a.index,
        bi = b.index;

    a = a.criteria;
    b = b.criteria;

    // ensure a stable sort in V8 and other engines
    // http://code.google.com/p/v8/issues/detail?id=90
    if (a !== b) {
      if (a > b || typeof a == 'undefined') {
        return 1;
      }
      if (a < b || typeof b == 'undefined') {
        return -1;
      }
    }
    return ai < bi ? -1 : 1;
  }

  /**
   * Creates a function that, when called, invokes `func` with the `this`
   * binding of `thisArg` and prepends any `partailArgs` to the arguments passed
   * to the bound function.
   *
   * @private
   * @param {Function|String} func The function to bind or the method name.
   * @param {Mixed} [thisArg] The `this` binding of `func`.
   * @param {Array} partialArgs An array of arguments to be partially applied.
   * @returns {Function} Returns the new bound function.
   */
  function createBound(func, thisArg, partialArgs) {
    var isFunc = isFunction(func),
        isPartial = !partialArgs,
        key = thisArg;

    // juggle arguments
    if (isPartial) {
      partialArgs = thisArg;
    }
    if (!isFunc) {
      thisArg = func;
    }

    function bound() {
      // `Function#bind` spec
      // http://es5.github.com/#x15.3.4.5
      var args = arguments,
          thisBinding = isPartial ? this : thisArg;

      if (!isFunc) {
        func = thisArg[key];
      }
      if (partialArgs.length) {
        args = args.length
          ? partialArgs.concat(slice(args))
          : partialArgs;
      }
      if (this instanceof bound) {
        // ensure `new bound` is an instance of `bound` and `func`
        noop.prototype = func.prototype;
        thisBinding = new noop;
        noop.prototype = null;

        // mimic the constructor's `return` behavior
        // http://es5.github.com/#x13.2.2
        var result = func.apply(thisBinding, args);
        return isObject(result) ? result : thisBinding;
      }
      return func.apply(thisBinding, args);
    }
    return bound;
  }

  /**
   * Produces an iteration callback bound to an optional `thisArg`. If `func` is
   * a property name, the callback will return the property value for a given element.
   *
   * @private
   * @param {Function|String} [func=identity|property] The function called per
   * iteration or property name to query.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @param {Object} [accumulating] Used to indicate that the callback should
   *  accept an `accumulator` argument.
   * @returns {Function} Returns a callback function.
   */
  function createCallback(func, thisArg, accumulating) {
    if (!func) {
      return identity;
    }
    if (typeof func != 'function') {
      return function(object) {
        return object[func];
      };
    }
    if (typeof thisArg != 'undefined') {
      if (accumulating) {
        return function(accumulator, value, index, object) {
          return func.call(thisArg, accumulator, value, index, object);
        };
      }
      return function(value, index, object) {
        return func.call(thisArg, value, index, object);
      };
    }
    return func;
  }

  /**
   * Creates compiled iteration functions.
   *
   * @private
   * @param {Object} [options1, options2, ...] The compile options object(s).
   *  useHas - A boolean to specify using `hasOwnProperty` checks in the object loop.
   *  args - A string of comma separated arguments the iteration function will accept.
   *  top - A string of code to execute before the iteration branches.
   *  arrayLoop - A string of code to execute in the array loop.
   *  objectLoop - A string of code to execute in the object loop.
   *  bottom - A string of code to execute after the iteration branches.
   *
   * @returns {Function} Returns the compiled function.
   */
  function createIterator() {
    var data = {
      'arrayLoop': '',
      'bottom': '',
      'hasDontEnumBug': hasDontEnumBug,
      'isKeysFast': isKeysFast,
      'objectLoop': '',
      'nonEnumArgs': nonEnumArgs,
      'noCharByIndex': noCharByIndex,
      'shadowed': shadowed,
      'top': '',
      'useHas': true
    };

    // merge options into a template data object
    for (var object, index = 0; object = arguments[index]; index++) {
      for (var key in object) {
        data[key] = object[key];
      }
    }
    var args = data.args;
    data.firstArg = /^[^,]+/.exec(args)[0];

    // create the function factory
    var factory = Function(
        'createCallback, hasOwnProperty, isArguments, isString, objectTypes, ' +
        'nativeKeys, propertyIsEnumerable',
      'return function(' + args + ') {\n' + iteratorTemplate(data) + '\n}'
    );
    // return the compiled function
    return factory(
      createCallback, hasOwnProperty, isArguments, isString, objectTypes,
      nativeKeys, propertyIsEnumerable
    );
  }

  /**
   * A function compiled to iterate `arguments` objects, arrays, objects, and
   * strings consistenly across environments, executing the `callback` for each
   * element in the `collection`. The `callback` is bound to `thisArg` and invoked
   * with three arguments; (value, index|key, collection). Callbacks may exit
   * iteration early by explicitly returning `false`.
   *
   * @private
   * @param {Array|Object|String} collection The collection to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Array|Object|String} Returns `collection`.
   */
  var each = createIterator(eachIteratorOptions);

  /**
   * Used by `template` to escape characters for inclusion in compiled
   * string literals.
   *
   * @private
   * @param {String} match The matched character to escape.
   * @returns {String} Returns the escaped character.
   */
  function escapeStringChar(match) {
    return '\\' + stringEscapes[match];
  }

  /**
   * Used by `escape` to convert characters to HTML entities.
   *
   * @private
   * @param {String} match The matched character to escape.
   * @returns {String} Returns the escaped character.
   */
  function escapeHtmlChar(match) {
    return htmlEscapes[match];
  }

  /**
   * Checks if `value` is a DOM node in IE < 9.
   *
   * @private
   * @param {Mixed} value The value to check.
   * @returns {Boolean} Returns `true` if the `value` is a DOM node, else `false`.
   */
  function isNode(value) {
    // IE < 9 presents DOM nodes as `Object` objects except they have `toString`
    // methods that are `typeof` "string" and still can coerce nodes to strings
    return typeof value.toString != 'function' && typeof (value + '') == 'string';
  }

  /**
   * A no-operation function.
   *
   * @private
   */
  function noop() {
    // no operation performed
  }

  /**
   * Slices the `collection` from the `start` index up to, but not including,
   * the `end` index.
   *
   * Note: This function is used, instead of `Array#slice`, to support node lists
   * in IE < 9 and to ensure dense arrays are returned.
   *
   * @private
   * @param {Array|Object|String} collection The collection to slice.
   * @param {Number} start The start index.
   * @param {Number} end The end index.
   * @returns {Array} Returns the new array.
   */
  function slice(array, start, end) {
    start || (start = 0);
    if (typeof end == 'undefined') {
      end = array ? array.length : 0;
    }
    var index = -1,
        length = end - start || 0,
        result = Array(length < 0 ? 0 : length);

    while (++index < length) {
      result[index] = array[start + index];
    }
    return result;
  }

  /**
   * Used by `unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {String} match The matched character to unescape.
   * @returns {String} Returns the unescaped character.
   */
  function unescapeHtmlChar(match) {
    return htmlUnescapes[match];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Assigns own enumerable properties of source object(s) to the `destination`
   * object. Subsequent sources will overwrite propery assignments of previous
   * sources.
   *
   * @static
   * @memberOf _
   * @alias extend
   * @category Objects
   * @param {Object} object The destination object.
   * @param {Object} [source1, source2, ...] The source objects.
   * @returns {Object} Returns the destination object.
   * @example
   *
   * _.assign({ 'name': 'moe' }, { 'age': 40 });
   * // => { 'name': 'moe', 'age': 40 }
   */
  var assign = createIterator(assignIteratorOptions);

  /**
   * Checks if `value` is an `arguments` object.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Mixed} value The value to check.
   * @returns {Boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
   * @example
   *
   * (function() { return _.isArguments(arguments); })(1, 2, 3);
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  function isArguments(value) {
    return toString.call(value) == argsClass;
  }
  // fallback for browsers that can't detect `arguments` objects by [[Class]]
  if (noArgsClass) {
    isArguments = function(value) {
      return value ? hasOwnProperty.call(value, 'callee') : false;
    };
  }

  /**
   * Iterates over `object`'s own and inherited enumerable properties, executing
   * the `callback` for each property. The `callback` is bound to `thisArg` and
   * invoked with three arguments; (value, key, object). Callbacks may exit iteration
   * early by explicitly returning `false`.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The object to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Object} Returns `object`.
   * @example
   *
   * function Dog(name) {
   *   this.name = name;
   * }
   *
   * Dog.prototype.bark = function() {
   *   alert('Woof, woof!');
   * };
   *
   * _.forIn(new Dog('Dagny'), function(value, key) {
   *   alert(key);
   * });
   * // => alerts 'name' and 'bark' (order is not guaranteed)
   */
  var forIn = createIterator(eachIteratorOptions, forOwnIteratorOptions, {
    'useHas': false
  });

  /**
   * Iterates over an object's own enumerable properties, executing the `callback`
   * for each property. The `callback` is bound to `thisArg` and invoked with three
   * arguments; (value, key, object). Callbacks may exit iteration early by explicitly
   * returning `false`.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The object to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Object} Returns `object`.
   * @example
   *
   * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
   *   alert(key);
   * });
   * // => alerts '0', '1', and 'length' (order is not guaranteed)
   */
  var forOwn = createIterator(eachIteratorOptions, forOwnIteratorOptions);

  /**
   * A fallback implementation of `isPlainObject` that checks if a given `value`
   * is an object created by the `Object` constructor, assuming objects created
   * by the `Object` constructor have no inherited enumerable properties and that
   * there are no `Object.prototype` extensions.
   *
   * @private
   * @param {Mixed} value The value to check.
   * @returns {Boolean} Returns `true` if `value` is a plain object, else `false`.
   */
  function shimIsPlainObject(value) {
    // avoid non-objects and false positives for `arguments` objects
    var result = false;
    if (!(value && typeof value == 'object') || isArguments(value)) {
      return result;
    }
    // check that the constructor is `Object` (i.e. `Object instanceof Object`)
    var ctor = value.constructor;
    if ((!isFunction(ctor) && (!noNodeClass || !isNode(value))) || ctor instanceof ctor) {
      // IE < 9 iterates inherited properties before own properties. If the first
      // iterated property is an object's own property then there are no inherited
      // enumerable properties.
      if (iteratesOwnLast) {
        forIn(value, function(value, key, object) {
          result = !hasOwnProperty.call(object, key);
          return false;
        });
        return result === false;
      }
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      forIn(value, function(value, key) {
        result = key;
      });
      return result === false || hasOwnProperty.call(value, result);
    }
    return result;
  }

  /**
   * A fallback implementation of `Object.keys` that produces an array of the
   * given object's own enumerable property names.
   *
   * @private
   * @param {Object} object The object to inspect.
   * @returns {Array} Returns a new array of property names.
   */
  function shimKeys(object) {
    var result = [];
    forOwn(object, function(value, key) {
      result.push(key);
    });
    return result;
  }

  /**
   * Used to convert characters to HTML entities:
   *
   * Though the `>` character is escaped for symmetry, characters like `>` and `/`
   * don't require escaping in HTML and have no special meaning unless they're part
   * of a tag or an unquoted attribute value.
   * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
   */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;'
  };

  /** Used to convert HTML entities to characters */
  var htmlUnescapes = invert(htmlEscapes);

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a clone of `value`. If `deep` is `true`, nested objects will also
   * be cloned, otherwise they will be assigned by reference.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Mixed} value The value to clone.
   * @param {Boolean} deep A flag to indicate a deep clone.
   * @param- {Object} [guard] Internally used to allow this method to work with
   *  others like `_.map` without using their callback `index` argument for `deep`.
   * @param- {Array} [stackA=[]] Internally used to track traversed source objects.
   * @param- {Array} [stackB=[]] Internally used to associate clones with their
   *  source counterparts.
   * @returns {Mixed} Returns the cloned `value`.
   * @example
   *
   * var stooges = [
   *   { 'name': 'moe', 'age': 40 },
   *   { 'name': 'larry', 'age': 50 },
   *   { 'name': 'curly', 'age': 60 }
   * ];
   *
   * var shallow = _.clone(stooges);
   * shallow[0] === stooges[0];
   * // => true
   *
   * var deep = _.clone(stooges, true);
   * deep[0] === stooges[0];
   * // => false
   */
  function clone(value, deep, guard, stackA, stackB) {
    if (value == null) {
      return value;
    }
    if (guard) {
      deep = false;
    }
    // inspect [[Class]]
    var isObj = isObject(value);
    if (isObj) {
      var className = toString.call(value);
      if (!cloneableClasses[className] || (noNodeClass && isNode(value))) {
        return value;
      }
      var isArr = isArray(value);
    }
    // shallow clone
    if (!isObj || !deep) {
      return isObj
        ? (isArr ? slice(value) : assign({}, value))
        : value;
    }
    var ctor = ctorByClass[className];
    switch (className) {
      case boolClass:
      case dateClass:
        return new ctor(+value);

      case numberClass:
      case stringClass:
        return new ctor(value);

      case regexpClass:
        return ctor(value.source, reFlags.exec(value));
    }
    // check for circular references and return corresponding clone
    stackA || (stackA = []);
    stackB || (stackB = []);

    var length = stackA.length;
    while (length--) {
      if (stackA[length] == value) {
        return stackB[length];
      }
    }
    // init cloned object
    var result = isArr ? ctor(value.length) : {};

    // add the source value to the stack of traversed objects
    // and associate it with its clone
    stackA.push(value);
    stackB.push(result);

    // recursively populate clone (susceptible to call stack limits)
    (isArr ? forEach : forOwn)(value, function(objValue, key) {
      result[key] = clone(objValue, deep, null, stackA, stackB);
    });

    // add array properties assigned by `RegExp#exec`
    if (isArr) {
      if (hasOwnProperty.call(value, 'index')) {
        result.index = value.index;
      }
      if (hasOwnProperty.call(value, 'input')) {
        result.input = value.input;
      }
    }
    return result;
  }

  /**
   * Creates a deep clone of `value`. Functions and DOM nodes are **not** cloned.
   * The enumerable properties of `arguments` objects and objects created by
   * constructors other than `Object` are cloned to plain `Object` objects.
   *
   * Note: This function is loosely based on the structured clone algorithm.
   * See http://www.w3.org/TR/html5/common-dom-interfaces.html#internal-structured-cloning-algorithm.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Mixed} value The value to deep clone.
   * @returns {Mixed} Returns the deep cloned `value`.
   * @example
   *
   * var stooges = [
   *   { 'name': 'moe', 'age': 40 },
   *   { 'name': 'larry', 'age': 50 },
   *   { 'name': 'curly', 'age': 60 }
   * ];
   *
   * var deep = _.cloneDeep(stooges);
   * deep[0] === stooges[0];
   * // => false
   */
  function cloneDeep(value) {
    return clone(value, true);
  }

  /**
   * Assigns own enumerable properties of source object(s) to the `destination`
   * object for all `destination` properties that resolve to `null`/`undefined`.
   * Once a property is set, additional defaults of the same property will be
   * ignored.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The destination object.
   * @param {Object} [default1, default2, ...] The default objects.
   * @returns {Object} Returns the destination object.
   * @example
   *
   * var iceCream = { 'flavor': 'chocolate' };
   * _.defaults(iceCream, { 'flavor': 'vanilla', 'sprinkles': 'rainbow' });
   * // => { 'flavor': 'chocolate', 'sprinkles': 'rainbow' }
   */
  var defaults = createIterator(assignIteratorOptions, {
    'objectLoop': 'if (result[index] == null) ' + assignIteratorOptions.objectLoop
  });

  /**
   * Creates a sorted array of all enumerable properties, own and inherited,
   * of `object` that have function values.
   *
   * @static
   * @memberOf _
   * @alias methods
   * @category Objects
   * @param {Object} object The object to inspect.
   * @returns {Array} Returns a new array of property names that have function values.
   * @example
   *
   * _.functions(_);
   * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
   */
  function functions(object) {
    var result = [];
    forIn(object, function(value, key) {
      if (isFunction(value)) {
        result.push(key);
      }
    });
    return result.sort();
  }

  /**
   * Checks if the specified object `property` exists and is a direct property,
   * instead of an inherited property.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The object to check.
   * @param {String} property The property to check for.
   * @returns {Boolean} Returns `true` if key is a direct property, else `false`.
   * @example
   *
   * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
   * // => true
   */
  function has(object, property) {
    return object ? hasOwnProperty.call(object, property) : false;
  }

  /**
   * Creates an object composed of the inverted keys and values of the given `object`.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The object to invert.
   * @returns {Object} Returns the created inverted object.
   * @example
   *
   *  _.invert({ 'first': 'Moe', 'second': 'Larry', 'third': 'Curly' });
   * // => { 'Moe': 'first', 'Larry': 'second', 'Curly': 'third' } (order is not guaranteed)
   */
  function invert(object) {
    var result = {};
    forOwn(object, function(value, key) {
      result[value] = key;
    });
    return result;
  }

  /**
   * Checks if `value` is an array.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Mixed} value The value to check.
   * @returns {Boolean} Returns `true` if the `value` is an array, else `false`.
   * @example
   *
   * (function() { return _.isArray(arguments); })();
   * // => false
   *
   * _.isArray([1, 2, 3]);
   * // => true
   */
  var isArray = nativeIsArray || function(value) {
    // `instanceof` may cause a memory leak in IE 7 if `value` is a host object
    // http://ajaxian.com/archives/working-aroung-the-instanceof-memory-leak
    return (argsAreObjects && value instanceof Array) || toString.call(value) == arrayClass;
  };

  /**
   * Checks if `value` is a boolean (`true` or `false`) value.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Mixed} value The value to check.
   * @returns {Boolean} Returns `true` if the `value` is a boolean value, else `false`.
   * @example
   *
   * _.isBoolean(null);
   * // => false
   */
  function isBoolean(value) {
    return value === true || value === false || toString.call(value) == boolClass;
  }

  /**
   * Checks if `value` is a date.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Mixed} value The value to check.
   * @returns {Boolean} Returns `true` if the `value` is a date, else `false`.
   * @example
   *
   * _.isDate(new Date);
   * // => true
   */
  function isDate(value) {
    return value instanceof Date || toString.call(value) == dateClass;
  }

  /**
   * Checks if `value` is a DOM element.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Mixed} value The value to check.
   * @returns {Boolean} Returns `true` if the `value` is a DOM element, else `false`.
   * @example
   *
   * _.isElement(document.body);
   * // => true
   */
  function isElement(value) {
    return value ? value.nodeType === 1 : false;
  }

  /**
   * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
   * length of `0` and objects with no own enumerable properties are considered
   * "empty".
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Array|Object|String} value The value to inspect.
   * @returns {Boolean} Returns `true` if the `value` is empty, else `false`.
   * @example
   *
   * _.isEmpty([1, 2, 3]);
   * // => false
   *
   * _.isEmpty({});
   * // => true
   *
   * _.isEmpty('');
   * // => true
   */
  function isEmpty(value) {
    var result = true;
    if (!value) {
      return result;
    }
    var className = toString.call(value),
        length = value.length;

    if ((className == arrayClass || className == stringClass ||
        className == argsClass || (noArgsClass && isArguments(value))) ||
        (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
      return !length;
    }
    forOwn(value, function() {
      return (result = false);
    });
    return result;
  }

  /**
   * Performs a deep comparison between two values to determine if they are
   * equivalent to each other.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Mixed} a The value to compare.
   * @param {Mixed} b The other value to compare.
   * @param- {Object} [stackA=[]] Internally used track traversed `a` objects.
   * @param- {Object} [stackB=[]] Internally used track traversed `b` objects.
   * @returns {Boolean} Returns `true` if the values are equvalent, else `false`.
   * @example
   *
   * var moe = { 'name': 'moe', 'luckyNumbers': [13, 27, 34] };
   * var clone = { 'name': 'moe', 'luckyNumbers': [13, 27, 34] };
   *
   * moe == clone;
   * // => false
   *
   * _.isEqual(moe, clone);
   * // => true
   */
  function isEqual(a, b, stackA, stackB) {
    // exit early for identical values
    if (a === b) {
      // treat `+0` vs. `-0` as not equal
      return a !== 0 || (1 / a == 1 / b);
    }
    // a strict comparison is necessary because `null == undefined`
    if (a == null || b == null) {
      return a === b;
    }
    // compare [[Class]] names
    var className = toString.call(a),
        otherName = toString.call(b);

    if (className == argsClass) {
      className = objectClass;
    }
    if (otherName == argsClass) {
      otherName = objectClass;
    }
    if (className != otherName) {
      return false;
    }
    switch (className) {
      case boolClass:
      case dateClass:
        // coerce dates and booleans to numbers, dates to milliseconds and booleans
        // to `1` or `0`, treating invalid dates coerced to `NaN` as not equal
        return +a == +b;

      case numberClass:
        // treat `NaN` vs. `NaN` as equal
        return a != +a
          ? b != +b
          // but treat `+0` vs. `-0` as not equal
          : (a == 0 ? (1 / a == 1 / b) : a == +b);

      case regexpClass:
      case stringClass:
        // coerce regexes to strings (http://es5.github.com/#x15.10.6.4)
        // treat string primitives and their corresponding object instances as equal
        return a == b + '';
    }
    var isArr = className == arrayClass;
    if (!isArr) {
      // unwrap any `lodash` wrapped values
      if (a.__wrapped__ || b.__wrapped__) {
        return isEqual(a.__wrapped__ || a, b.__wrapped__ || b);
      }
      // exit for functions and DOM nodes
      if (className != objectClass || (noNodeClass && (isNode(a) || isNode(b)))) {
        return false;
      }
      // in older versions of Opera, `arguments` objects have `Array` constructors
      var ctorA = !argsAreObjects && isArguments(a) ? Object : a.constructor,
          ctorB = !argsAreObjects && isArguments(b) ? Object : b.constructor;

      // non `Object` object instances with different constructors are not equal
      if (ctorA != ctorB && !(
            isFunction(ctorA) && ctorA instanceof ctorA &&
            isFunction(ctorB) && ctorB instanceof ctorB
          )) {
        return false;
      }
    }
    // assume cyclic structures are equal
    // the algorithm for detecting cyclic structures is adapted from ES 5.1
    // section 15.12.3, abstract operation `JO` (http://es5.github.com/#x15.12.3)
    stackA || (stackA = []);
    stackB || (stackB = []);

    var length = stackA.length;
    while (length--) {
      if (stackA[length] == a) {
        return stackB[length] == b;
      }
    }
    var index = -1,
        result = true,
        size = 0;

    // add `a` and `b` to the stack of traversed objects
    stackA.push(a);
    stackB.push(b);

    // recursively compare objects and arrays (susceptible to call stack limits)
    if (isArr) {
      // compare lengths to determine if a deep comparison is necessary
      size = a.length;
      result = size == b.length;

      if (result) {
        // deep compare the contents, ignoring non-numeric properties
        while (size--) {
          if (!(result = isEqual(a[size], b[size], stackA, stackB))) {
            break;
          }
        }
      }
      return result;
    }
    // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
    // which, in this case, is more costly
    forIn(a, function(value, key, a) {
      if (hasOwnProperty.call(a, key)) {
        // count the number of properties.
        size++;
        // deep compare each property value.
        return (result = hasOwnProperty.call(b, key) && isEqual(value, b[key], stackA, stackB));
      }
    });

    if (result) {
      // ensure both objects have the same number of properties
      forIn(b, function(value, key, b) {
        if (hasOwnProperty.call(b, key)) {
          // `size` will be `-1` if `b` has more properties than `a`
          return (result = --size > -1);
        }
      });
    }
    return result;
  }

  /**
   * Checks if `value` is, or can be coerced to, a finite number.
   *
   * Note: This is not the same as native `isFinite`, which will return true for
   * booleans and empty strings. See http://es5.github.com/#x15.1.2.5.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Mixed} value The value to check.
   * @returns {Boolean} Returns `true` if the `value` is a finite number, else `false`.
   * @example
   *
   * _.isFinite(-101);
   * // => true
   *
   * _.isFinite('10');
   * // => true
   *
   * _.isFinite(true);
   * // => false
   *
   * _.isFinite('');
   * // => false
   *
   * _.isFinite(Infinity);
   * // => false
   */
  function isFinite(value) {
    return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
  }

  /**
   * Checks if `value` is a function.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Mixed} value The value to check.
   * @returns {Boolean} Returns `true` if the `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   */
  function isFunction(value) {
    return typeof value == 'function';
  }
  // fallback for older versions of Chrome and Safari
  if (isFunction(/x/)) {
    isFunction = function(value) {
      return value instanceof Function || toString.call(value) == funcClass;
    };
  }

  /**
   * Checks if `value` is the language type of Object.
   * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Mixed} value The value to check.
   * @returns {Boolean} Returns `true` if the `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(1);
   * // => false
   */
  function isObject(value) {
    // check if the value is the ECMAScript language type of Object
    // http://es5.github.com/#x8
    // and avoid a V8 bug
    // http://code.google.com/p/v8/issues/detail?id=2291
    return value ? objectTypes[typeof value] : false;
  }

  /**
   * Checks if `value` is `NaN`.
   *
   * Note: This is not the same as native `isNaN`, which will return `true` for
   * `undefined` and other values. See http://es5.github.com/#x15.1.2.4.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Mixed} value The value to check.
   * @returns {Boolean} Returns `true` if the `value` is `NaN`, else `false`.
   * @example
   *
   * _.isNaN(NaN);
   * // => true
   *
   * _.isNaN(new Number(NaN));
   * // => true
   *
   * isNaN(undefined);
   * // => true
   *
   * _.isNaN(undefined);
   * // => false
   */
  function isNaN(value) {
    // `NaN` as a primitive is the only value that is not equal to itself
    // (perform the [[Class]] check first to avoid errors with some host objects in IE)
    return isNumber(value) && value != +value
  }

  /**
   * Checks if `value` is `null`.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Mixed} value The value to check.
   * @returns {Boolean} Returns `true` if the `value` is `null`, else `false`.
   * @example
   *
   * _.isNull(null);
   * // => true
   *
   * _.isNull(undefined);
   * // => false
   */
  function isNull(value) {
    return value === null;
  }

  /**
   * Checks if `value` is a number.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Mixed} value The value to check.
   * @returns {Boolean} Returns `true` if the `value` is a number, else `false`.
   * @example
   *
   * _.isNumber(8.4 * 5);
   * // => true
   */
  function isNumber(value) {
    return typeof value == 'number' || toString.call(value) == numberClass;
  }

  /**
   * Checks if a given `value` is an object created by the `Object` constructor.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Mixed} value The value to check.
   * @returns {Boolean} Returns `true` if `value` is a plain object, else `false`.
   * @example
   *
   * function Stooge(name, age) {
   *   this.name = name;
   *   this.age = age;
   * }
   *
   * _.isPlainObject(new Stooge('moe', 40));
   * // => false
   *
   * _.isPlainObject([1, 2, 3]);
   * // => false
   *
   * _.isPlainObject({ 'name': 'moe', 'age': 40 });
   * // => true
   */
  var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
    if (!(value && typeof value == 'object')) {
      return false;
    }
    var valueOf = value.valueOf,
        objProto = typeof valueOf == 'function' && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

    return objProto
      ? value == objProto || (getPrototypeOf(value) == objProto && !isArguments(value))
      : shimIsPlainObject(value);
  };

  /**
   * Checks if `value` is a regular expression.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Mixed} value The value to check.
   * @returns {Boolean} Returns `true` if the `value` is a regular expression, else `false`.
   * @example
   *
   * _.isRegExp(/moe/);
   * // => true
   */
  function isRegExp(value) {
    return value instanceof RegExp || toString.call(value) == regexpClass;
  }

  /**
   * Checks if `value` is a string.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Mixed} value The value to check.
   * @returns {Boolean} Returns `true` if the `value` is a string, else `false`.
   * @example
   *
   * _.isString('moe');
   * // => true
   */
  function isString(value) {
    return typeof value == 'string' || toString.call(value) == stringClass;
  }

  /**
   * Checks if `value` is `undefined`.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Mixed} value The value to check.
   * @returns {Boolean} Returns `true` if the `value` is `undefined`, else `false`.
   * @example
   *
   * _.isUndefined(void 0);
   * // => true
   */
  function isUndefined(value) {
    return typeof value == 'undefined';
  }

  /**
   * Creates an array composed of the own enumerable property names of `object`.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The object to inspect.
   * @returns {Array} Returns a new array of property names.
   * @example
   *
   * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
   * // => ['one', 'two', 'three'] (order is not guaranteed)
   */
  var keys = !nativeKeys ? shimKeys : function(object) {
    // avoid iterating over the `prototype` property
    return typeof object == 'function' && propertyIsEnumerable.call(object, 'prototype')
      ? shimKeys(object)
      : (isObject(object) ? nativeKeys(object) : []);
  };

  /**
   * Merges enumerable properties of the source object(s) into the `destination`
   * object. Subsequent sources will overwrite propery assignments of previous
   * sources.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The destination object.
   * @param {Object} [source1, source2, ...] The source objects.
   * @param- {Object} [indicator] Internally used to indicate that the `stack`
   *  argument is an array of traversed objects instead of another source object.
   * @param- {Array} [stackA=[]] Internally used to track traversed source objects.
   * @param- {Array} [stackB=[]] Internally used to associate values with their
   *  source counterparts.
   * @returns {Object} Returns the destination object.
   * @example
   *
   * var stooges = [
   *   { 'name': 'moe' },
   *   { 'name': 'larry' }
   * ];
   *
   * var ages = [
   *   { 'age': 40 },
   *   { 'age': 50 }
   * ];
   *
   * _.merge(stooges, ages);
   * // => [{ 'name': 'moe', 'age': 40 }, { 'name': 'larry', 'age': 50 }]
   */
  function merge(object, source, indicator) {
    var args = arguments,
        index = 0,
        length = 2,
        stackA = args[3],
        stackB = args[4];

    if (indicator !== indicatorObject) {
      stackA = [];
      stackB = [];

      // work with `_.reduce` by only using its callback `accumulator` and `value` arguments
      if (typeof indicator != 'number') {
        length = args.length;
      }
    }
    while (++index < length) {
      forOwn(args[index], function(source, key) {
        var found, isArr, value;
        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
          // avoid merging previously merged cyclic sources
          var stackLength = stackA.length;
          while (stackLength--) {
            found = stackA[stackLength] == source;
            if (found) {
              break;
            }
          }
          if (found) {
            object[key] = stackB[stackLength];
          }
          else {
            // add `source` and associated `value` to the stack of traversed objects
            stackA.push(source);
            stackB.push(value = (value = object[key], isArr)
              ? (isArray(value) ? value : [])
              : (isPlainObject(value) ? value : {})
            );
            // recursively merge objects and arrays (susceptible to call stack limits)
            object[key] = merge(value, source, indicatorObject, stackA, stackB);
          }
        } else if (source != null) {
          object[key] = source;
        }
      });
    }
    return object;
  }

  /**
   * Creates a shallow clone of `object` excluding the specified properties.
   * Property names may be specified as individual arguments or as arrays of
   * property names. If `callback` is passed, it will be executed for each property
   * in the `object`, omitting the properties `callback` returns truthy for. The
   * `callback` is bound to `thisArg` and invoked with three arguments; (value, key, object).
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The source object.
   * @param {Function|String} callback|[prop1, prop2, ...] The properties to omit
   *  or the function called per iteration.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Object} Returns an object without the omitted properties.
   * @example
   *
   * _.omit({ 'name': 'moe', 'age': 40, 'userid': 'moe1' }, 'userid');
   * // => { 'name': 'moe', 'age': 40 }
   *
   * _.omit({ 'name': 'moe', '_hint': 'knucklehead', '_seed': '96c4eb' }, function(value, key) {
   *   return key.charAt(0) == '_';
   * });
   * // => { 'name': 'moe' }
   */
  function omit(object, callback, thisArg) {
    var isFunc = typeof callback == 'function',
        result = {};

    if (isFunc) {
      callback = createCallback(callback, thisArg);
    } else {
      var props = concat.apply(arrayRef, arguments);
    }
    forIn(object, function(value, key, object) {
      if (isFunc
            ? !callback(value, key, object)
            : indexOf(props, key, 1) < 0
          ) {
        result[key] = value;
      }
    });
    return result;
  }

  /**
   * Creates a two dimensional array of the given object's key-value pairs,
   * i.e. `[[key1, value1], [key2, value2]]`.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The object to inspect.
   * @returns {Array} Returns new array of key-value pairs.
   * @example
   *
   * _.pairs({ 'moe': 30, 'larry': 40, 'curly': 50 });
   * // => [['moe', 30], ['larry', 40], ['curly', 50]] (order is not guaranteed)
   */
  function pairs(object) {
    var result = [];
    forOwn(object, function(value, key) {
      result.push([key, value]);
    });
    return result;
  }

  /**
   * Creates a shallow clone of `object` composed of the specified properties.
   * Property names may be specified as individual arguments or as arrays of
   * property names. If `callback` is passed, it will be executed for each property
   * in the `object`, picking the properties `callback` returns truthy for. The
   * `callback` is bound to `thisArg` and invoked with three arguments; (value, key, object).
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The source object.
   * @param {Function|String} callback|[prop1, prop2, ...] The properties to pick
   *  or the function called per iteration.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Object} Returns an object composed of the picked properties.
   * @example
   *
   * _.pick({ 'name': 'moe', 'age': 40, 'userid': 'moe1' }, 'name', 'age');
   * // => { 'name': 'moe', 'age': 40 }
   *
   * _.pick({ 'name': 'moe', '_hint': 'knucklehead', '_seed': '96c4eb' }, function(value, key) {
   *   return key.charAt(0) != '_';
   * });
   * // => { 'name': 'moe' }
   */
  function pick(object, callback, thisArg) {
    var result = {};
    if (typeof callback != 'function') {
      var index = 0,
          props = concat.apply(arrayRef, arguments),
          length = props.length;

      while (++index < length) {
        var key = props[index];
        if (key in object) {
          result[key] = object[key];
        }
      }
    } else {
      callback = createCallback(callback, thisArg);
      forIn(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result[key] = value;
        }
      });
    }
    return result;
  }

  /**
   * Creates an array composed of the own enumerable property values of `object`.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The object to inspect.
   * @returns {Array} Returns a new array of property values.
   * @example
   *
   * _.values({ 'one': 1, 'two': 2, 'three': 3 });
   * // => [1, 2, 3]
   */
  function values(object) {
    var result = [];
    forOwn(object, function(value) {
      result.push(value);
    });
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Checks if a given `target` element is present in a `collection` using strict
   * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
   * as the offset from the end of the collection.
   *
   * @static
   * @memberOf _
   * @alias include
   * @category Collections
   * @param {Array|Object|String} collection The collection to iterate over.
   * @param {Mixed} target The value to check for.
   * @param {Number} [fromIndex=0] The index to search from.
   * @returns {Boolean} Returns `true` if the `target` element is found, else `false`.
   * @example
   *
   * _.contains([1, 2, 3], 1);
   * // => true
   *
   * _.contains([1, 2, 3], 1, 2);
   * // => false
   *
   * _.contains({ 'name': 'moe', 'age': 40 }, 'moe');
   * // => true
   *
   * _.contains('curly', 'ur');
   * // => true
   */
  function contains(collection, target, fromIndex) {
    var index = -1,
        length = collection ? collection.length : 0,
        result = false;

    fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
    if (typeof length == 'number') {
      result = (isString(collection)
        ? collection.indexOf(target, fromIndex)
        : indexOf(collection, target, fromIndex)
      ) > -1;
    } else {
      each(collection, function(value) {
        if (++index >= fromIndex) {
          return !(result = value === target);
        }
      });
    }
    return result;
  }

  /**
   * Creates an object composed of keys returned from running each element of
   * `collection` through a `callback`. The corresponding value of each key is
   * the number of times the key was returned by `callback`. The `callback` is
   * bound to `thisArg` and invoked with three arguments; (value, index|key, collection).
   * The `callback` argument may also be the name of a property to count by (e.g. 'length').
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|String} collection The collection to iterate over.
   * @param {Function|String} callback|property The function called per iteration
   *  or property name to count by.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Object} Returns the composed aggregate object.
   * @example
   *
   * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
   * // => { '4': 1, '6': 2 }
   *
   * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
   * // => { '4': 1, '6': 2 }
   *
   * _.countBy(['one', 'two', 'three'], 'length');
   * // => { '3': 2, '5': 1 }
   */
  function countBy(collection, callback, thisArg) {
    var result = {};
    callback = createCallback(callback, thisArg);

    forEach(collection, function(value, key, collection) {
      key = callback(value, key, collection);
      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
    });
    return result;
  }

  /**
   * Checks if the `callback` returns a truthy value for **all** elements of a
   * `collection`. The `callback` is bound to `thisArg` and invoked with three
   * arguments; (value, index|key, collection).
   *
   * @static
   * @memberOf _
   * @alias all
   * @category Collections
   * @param {Array|Object|String} collection The collection to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Boolean} Returns `true` if all elements pass the callback check,
   *  else `false`.
   * @example
   *
   * _.every([true, 1, null, 'yes'], Boolean);
   * // => false
   */
  function every(collection, callback, thisArg) {
    var result = true;
    callback = createCallback(callback, thisArg);

    if (isArray(collection)) {
      var index = -1,
          length = collection.length;

      while (++index < length) {
        if (!(result = !!callback(collection[index], index, collection))) {
          break;
        }
      }
    } else {
      each(collection, function(value, index, collection) {
        return (result = !!callback(value, index, collection));
      });
    }
    return result;
  }

  /**
   * Examines each element in a `collection`, returning an array of all elements
   * the `callback` returns truthy for. The `callback` is bound to `thisArg` and
   * invoked with three arguments; (value, index|key, collection).
   *
   * @static
   * @memberOf _
   * @alias select
   * @category Collections
   * @param {Array|Object|String} collection The collection to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a new array of elements that passed the callback check.
   * @example
   *
   * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
   * // => [2, 4, 6]
   */
  function filter(collection, callback, thisArg) {
    var result = [];
    callback = createCallback(callback, thisArg);

    if (isArray(collection)) {
      var index = -1,
          length = collection.length;

      while (++index < length) {
        var value = collection[index];
        if (callback(value, index, collection)) {
          result.push(value);
        }
      }
    } else {
      each(collection, function(value, index, collection) {
        if (callback(value, index, collection)) {
          result.push(value);
        }
      });
    }
    return result;
  }

  /**
   * Examines each element in a `collection`, returning the first one the `callback`
   * returns truthy for. The function returns as soon as it finds an acceptable
   * element, and does not iterate over the entire `collection`. The `callback` is
   * bound to `thisArg` and invoked with three arguments; (value, index|key, collection).
   *
   * @static
   * @memberOf _
   * @alias detect
   * @category Collections
   * @param {Array|Object|String} collection The collection to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Mixed} Returns the element that passed the callback check,
   *  else `undefined`.
   * @example
   *
   * var even = _.find([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
   * // => 2
   */
  function find(collection, callback, thisArg) {
    var result;
    callback = createCallback(callback, thisArg);

    forEach(collection, function(value, index, collection) {
      if (callback(value, index, collection)) {
        result = value;
        return false;
      }
    });
    return result;
  }

  /**
   * Iterates over a `collection`, executing the `callback` for each element in
   * the `collection`. The `callback` is bound to `thisArg` and invoked with three
   * arguments; (value, index|key, collection). Callbacks may exit iteration early
   * by explicitly returning `false`.
   *
   * @static
   * @memberOf _
   * @alias each
   * @category Collections
   * @param {Array|Object|String} collection The collection to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Array|Object|String} Returns `collection`.
   * @example
   *
   * _([1, 2, 3]).forEach(alert).join(',');
   * // => alerts each number and returns '1,2,3'
   *
   * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, alert);
   * // => alerts each number value (order is not guaranteed)
   */
  function forEach(collection, callback, thisArg) {
    if (callback && typeof thisArg == 'undefined' && isArray(collection)) {
      var index = -1,
          length = collection.length;

      while (++index < length) {
        if (callback(collection[index], index, collection) === false) {
          break;
        }
      }
    } else {
      each(collection, callback, thisArg);
    }
    return collection;
  }

  /**
   * Creates an object composed of keys returned from running each element of
   * `collection` through a `callback`. The corresponding value of each key is an
   * array of elements passed to `callback` that returned the key. The `callback`
   * is bound to `thisArg` and invoked with three arguments; (value, index|key, collection).
   * The `callback` argument may also be the name of a property to group by (e.g. 'length').
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|String} collection The collection to iterate over.
   * @param {Function|String} callback|property The function called per iteration
   *  or property name to group by.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Object} Returns the composed aggregate object.
   * @example
   *
   * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
   * // => { '4': [4.2], '6': [6.1, 6.4] }
   *
   * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
   * // => { '4': [4.2], '6': [6.1, 6.4] }
   *
   * _.groupBy(['one', 'two', 'three'], 'length');
   * // => { '3': ['one', 'two'], '5': ['three'] }
   */
  function groupBy(collection, callback, thisArg) {
    var result = {};
    callback = createCallback(callback, thisArg);

    forEach(collection, function(value, key, collection) {
      key = callback(value, key, collection);
      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
    });
    return result;
  }

  /**
   * Invokes the method named by `methodName` on each element in the `collection`,
   * returning an array of the results of each invoked method. Additional arguments
   * will be passed to each invoked method. If `methodName` is a function it will
   * be invoked for, and `this` bound to, each element in the `collection`.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|String} collection The collection to iterate over.
   * @param {Function|String} methodName The name of the method to invoke or
   *  the function invoked per iteration.
   * @param {Mixed} [arg1, arg2, ...] Arguments to invoke the method with.
   * @returns {Array} Returns a new array of the results of each invoked method.
   * @example
   *
   * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
   * // => [[1, 5, 7], [1, 2, 3]]
   *
   * _.invoke([123, 456], String.prototype.split, '');
   * // => [['1', '2', '3'], ['4', '5', '6']]
   */
  function invoke(collection, methodName) {
    var args = slice(arguments, 2),
        isFunc = typeof methodName == 'function',
        result = [];

    forEach(collection, function(value) {
      result.push((isFunc ? methodName : value[methodName]).apply(value, args));
    });
    return result;
  }

  /**
   * Creates an array of values by running each element in the `collection`
   * through a `callback`. The `callback` is bound to `thisArg` and invoked with
   * three arguments; (value, index|key, collection).
   *
   * @static
   * @memberOf _
   * @alias collect
   * @category Collections
   * @param {Array|Object|String} collection The collection to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a new array of the results of each `callback` execution.
   * @example
   *
   * _.map([1, 2, 3], function(num) { return num * 3; });
   * // => [3, 6, 9]
   *
   * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
   * // => [3, 6, 9] (order is not guaranteed)
   */
  function map(collection, callback, thisArg) {
    var index = -1,
        length = collection ? collection.length : 0,
        result = Array(typeof length == 'number' ? length : 0);

    callback = createCallback(callback, thisArg);
    if (isArray(collection)) {
      while (++index < length) {
        result[index] = callback(collection[index], index, collection);
      }
    } else {
      each(collection, function(value, key, collection) {
        result[++index] = callback(value, key, collection);
      });
    }
    return result;
  }

  /**
   * Retrieves the maximum value of an `array`. If `callback` is passed,
   * it will be executed for each value in the `array` to generate the
   * criterion by which the value is ranked. The `callback` is bound to
   * `thisArg` and invoked with three arguments; (value, index, collection).
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|String} collection The collection to iterate over.
   * @param {Function} [callback] The function called per iteration.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Mixed} Returns the maximum value.
   * @example
   *
   * var stooges = [
   *   { 'name': 'moe', 'age': 40 },
   *   { 'name': 'larry', 'age': 50 },
   *   { 'name': 'curly', 'age': 60 }
   * ];
   *
   * _.max(stooges, function(stooge) { return stooge.age; });
   * // => { 'name': 'curly', 'age': 60 };
   */
  function max(collection, callback, thisArg) {
    var computed = -Infinity,
        index = -1,
        length = collection ? collection.length : 0,
        result = computed;

    if (callback || !isArray(collection)) {
      callback = !callback && isString(collection)
        ? charAtCallback
        : createCallback(callback, thisArg);

      each(collection, function(value, index, collection) {
        var current = callback(value, index, collection);
        if (current > computed) {
          computed = current;
          result = value;
        }
      });
    } else {
      while (++index < length) {
        if (collection[index] > result) {
          result = collection[index];
        }
      }
    }
    return result;
  }

  /**
   * Retrieves the minimum value of an `array`. If `callback` is passed,
   * it will be executed for each value in the `array` to generate the
   * criterion by which the value is ranked. The `callback` is bound to `thisArg`
   * and invoked with three arguments; (value, index, collection).
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|String} collection The collection to iterate over.
   * @param {Function} [callback] The function called per iteration.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Mixed} Returns the minimum value.
   * @example
   *
   * _.min([10, 5, 100, 2, 1000]);
   * // => 2
   */
  function min(collection, callback, thisArg) {
    var computed = Infinity,
        index = -1,
        length = collection ? collection.length : 0,
        result = computed;

    if (callback || !isArray(collection)) {
      callback = !callback && isString(collection)
        ? charAtCallback
        : createCallback(callback, thisArg);

      each(collection, function(value, index, collection) {
        var current = callback(value, index, collection);
        if (current < computed) {
          computed = current;
          result = value;
        }
      });
    } else {
      while (++index < length) {
        if (collection[index] < result) {
          result = collection[index];
        }
      }
    }
    return result;
  }

  /**
   * Retrieves the value of a specified property from all elements in
   * the `collection`.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|String} collection The collection to iterate over.
   * @param {String} property The property to pluck.
   * @returns {Array} Returns a new array of property values.
   * @example
   *
   * var stooges = [
   *   { 'name': 'moe', 'age': 40 },
   *   { 'name': 'larry', 'age': 50 },
   *   { 'name': 'curly', 'age': 60 }
   * ];
   *
   * _.pluck(stooges, 'name');
   * // => ['moe', 'larry', 'curly']
   */
  function pluck(collection, property) {
    return map(collection, property + '');
  }

  /**
   * Boils down a `collection` to a single value. The initial state of the
   * reduction is `accumulator` and each successive step of it should be returned
   * by the `callback`. The `callback` is bound to `thisArg` and invoked with 4
   * arguments; for arrays they are (accumulator, value, index|key, collection).
   *
   * @static
   * @memberOf _
   * @alias foldl, inject
   * @category Collections
   * @param {Array|Object|String} collection The collection to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {Mixed} [accumulator] Initial value of the accumulator.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Mixed} Returns the accumulated value.
   * @example
   *
   * var sum = _.reduce([1, 2, 3], function(memo, num) { return memo + num; });
   * // => 6
   */
  function reduce(collection, callback, accumulator, thisArg) {
    var noaccum = arguments.length < 3;
    callback = createCallback(callback, thisArg, indicatorObject);

    if (isArray(collection)) {
      var index = -1,
          length = collection.length;

      if (noaccum) {
        accumulator = collection[++index];
      }
      while (++index < length) {
        accumulator = callback(accumulator, collection[index], index, collection);
      }
    } else {
      each(collection, function(value, index, collection) {
        accumulator = noaccum
          ? (noaccum = false, value)
          : callback(accumulator, value, index, collection)
      });
    }
    return accumulator;
  }

  /**
   * The right-associative version of `_.reduce`.
   *
   * @static
   * @memberOf _
   * @alias foldr
   * @category Collections
   * @param {Array|Object|String} collection The collection to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {Mixed} [accumulator] Initial value of the accumulator.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Mixed} Returns the accumulated value.
   * @example
   *
   * var list = [[0, 1], [2, 3], [4, 5]];
   * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
   * // => [4, 5, 2, 3, 0, 1]
   */
  function reduceRight(collection, callback, accumulator, thisArg) {
    var iteratee = collection,
        length = collection ? collection.length : 0,
        noaccum = arguments.length < 3;

    if (typeof length != 'number') {
      var props = keys(collection);
      length = props.length;
    } else if (noCharByIndex && isString(collection)) {
      iteratee = collection.split('');
    }
    callback = createCallback(callback, thisArg, indicatorObject);
    forEach(collection, function(value, index, collection) {
      index = props ? props[--length] : --length;
      accumulator = noaccum
        ? (noaccum = false, iteratee[index])
        : callback(accumulator, iteratee[index], index, collection);
    });
    return accumulator;
  }

  /**
   * The opposite of `_.filter`, this method returns the values of a
   * `collection` that `callback` does **not** return truthy for.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|String} collection The collection to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a new array of elements that did **not** pass the
   *  callback check.
   * @example
   *
   * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
   * // => [1, 3, 5]
   */
  function reject(collection, callback, thisArg) {
    callback = createCallback(callback, thisArg);
    return filter(collection, function(value, index, collection) {
      return !callback(value, index, collection);
    });
  }

  /**
   * Creates an array of shuffled `array` values, using a version of the
   * Fisher-Yates shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|String} collection The collection to shuffle.
   * @returns {Array} Returns a new shuffled collection.
   * @example
   *
   * _.shuffle([1, 2, 3, 4, 5, 6]);
   * // => [4, 1, 6, 3, 5, 2]
   */
  function shuffle(collection) {
    var index = -1,
        result = Array(collection ? collection.length : 0);

    forEach(collection, function(value) {
      var rand = floor(nativeRandom() * (++index + 1));
      result[index] = result[rand];
      result[rand] = value;
    });
    return result;
  }

  /**
   * Gets the size of the `collection` by returning `collection.length` for arrays
   * and array-like objects or the number of own enumerable properties for objects.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|String} collection The collection to inspect.
   * @returns {Number} Returns `collection.length` or number of own enumerable properties.
   * @example
   *
   * _.size([1, 2]);
   * // => 2
   *
   * _.size({ 'one': 1, 'two': 2, 'three': 3 });
   * // => 3
   *
   * _.size('curly');
   * // => 5
   */
  function size(collection) {
    var length = collection ? collection.length : 0;
    return typeof length == 'number' ? length : keys(collection).length;
  }

  /**
   * Checks if the `callback` returns a truthy value for **any** element of a
   * `collection`. The function returns as soon as it finds passing value, and
   * does not iterate over the entire `collection`. The `callback` is bound to
   * `thisArg` and invoked with three arguments; (value, index|key, collection).
   *
   * @static
   * @memberOf _
   * @alias any
   * @category Collections
   * @param {Array|Object|String} collection The collection to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Boolean} Returns `true` if any element passes the callback check,
   *  else `false`.
   * @example
   *
   * _.some([null, 0, 'yes', false], Boolean);
   * // => true
   */
  function some(collection, callback, thisArg) {
    var result;
    callback = createCallback(callback, thisArg);

    if (isArray(collection)) {
      var index = -1,
          length = collection.length;

      while (++index < length) {
        if ((result = callback(collection[index], index, collection))) {
          break;
        }
      }
    } else {
      each(collection, function(value, index, collection) {
        return !(result = callback(value, index, collection));
      });
    }
    return !!result;
  }

  /**
   * Creates an array, stable sorted in ascending order by the results of
   * running each element of `collection` through a `callback`. The `callback`
   * is bound to `thisArg` and invoked with three arguments; (value, index|key, collection).
   * The `callback` argument may also be the name of a property to sort by (e.g. 'length').
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|String} collection The collection to iterate over.
   * @param {Function|String} callback|property The function called per iteration
   *  or property name to sort by.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a new array of sorted elements.
   * @example
   *
   * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
   * // => [3, 1, 2]
   *
   * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
   * // => [3, 1, 2]
   *
   * _.sortBy(['larry', 'brendan', 'moe'], 'length');
   * // => ['moe', 'larry', 'brendan']
   */
  function sortBy(collection, callback, thisArg) {
    var result = [];
    callback = createCallback(callback, thisArg);

    forEach(collection, function(value, index, collection) {
      result.push({
        'criteria': callback(value, index, collection),
        'index': index,
        'value': value
      });
    });

    var length = result.length;
    result.sort(compareAscending);
    while (length--) {
      result[length] = result[length].value;
    }
    return result;
  }

  /**
   * Converts the `collection` to an array.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|String} collection The collection to convert.
   * @returns {Array} Returns the new converted array.
   * @example
   *
   * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
   * // => [2, 3, 4]
   */
  function toArray(collection) {
    var length = collection ? collection.length : 0;
    if (typeof length == 'number') {
      return noCharByIndex && isString(collection)
        ? collection.split('')
        : slice(collection);
    }
    return values(collection);
  }

  /**
   * Examines each element in a `collection`, returning an array of all elements
   * that contain the given `properties`.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|String} collection The collection to iterate over.
   * @param {Object} properties The object of property values to filter by.
   * @returns {Array} Returns a new array of elements that contain the given `properties`.
   * @example
   *
   * var stooges = [
   *   { 'name': 'moe', 'age': 40 },
   *   { 'name': 'larry', 'age': 50 },
   *   { 'name': 'curly', 'age': 60 }
   * ];
   *
   * _.where(stooges, { 'age': 40 });
   * // => [{ 'name': 'moe', 'age': 40 }]
   */
  function where(collection, properties) {
    var props = keys(properties);
    return filter(collection, function(object) {
      var length = props.length;
      while (length--) {
        var result = object[props[length]] === properties[props[length]];
        if (!result) {
          break;
        }
      }
      return !!result;
    });
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Creates an array with all falsey values of `array` removed. The values
   * `false`, `null`, `0`, `""`, `undefined` and `NaN` are all falsey.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to compact.
   * @returns {Array} Returns a new filtered array.
   * @example
   *
   * _.compact([0, 1, false, 2, '', 3]);
   * // => [1, 2, 3]
   */
  function compact(array) {
    var index = -1,
        length = array ? array.length : 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (value) {
        result.push(value);
      }
    }
    return result;
  }

  /**
   * Creates an array of `array` elements not present in the other arrays
   * using strict equality for comparisons, i.e. `===`.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to process.
   * @param {Array} [array1, array2, ...] Arrays to check.
   * @returns {Array} Returns a new array of `array` elements not present in the
   *  other arrays.
   * @example
   *
   * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
   * // => [1, 3, 4]
   */
  function difference(array) {
    var index = -1,
        length = array ? array.length : 0,
        flattened = concat.apply(arrayRef, arguments),
        contains = cachedContains(flattened, length),
        result = [];

    while (++index < length) {
      var value = array[index];
      if (!contains(value)) {
        result.push(value);
      }
    }
    return result;
  }

  /**
   * Gets the first element of the `array`. Pass `n` to return the first `n`
   * elements of the `array`.
   *
   * @static
   * @memberOf _
   * @alias head, take
   * @category Arrays
   * @param {Array} array The array to query.
   * @param {Number} [n] The number of elements to return.
   * @param- {Object} [guard] Internally used to allow this method to work with
   *  others like `_.map` without using their callback `index` argument for `n`.
   * @returns {Mixed} Returns the first element, or an array of the first `n`
   *  elements, of `array`.
   * @example
   *
   * _.first([5, 4, 3, 2, 1]);
   * // => 5
   */
  function first(array, n, guard) {
    if (array) {
      var length = array.length;
      return (n == null || guard)
        ? array[0]
        : slice(array, 0, nativeMin(nativeMax(0, n), length));
    }
  }

  /**
   * Flattens a nested array (the nesting can be to any depth). If `shallow` is
   * truthy, `array` will only be flattened a single level.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to compact.
   * @param {Boolean} shallow A flag to indicate only flattening a single level.
   * @returns {Array} Returns a new flattened array.
   * @example
   *
   * _.flatten([1, [2], [3, [[4]]]]);
   * // => [1, 2, 3, 4];
   *
   * _.flatten([1, [2], [3, [[4]]]], true);
   * // => [1, 2, 3, [[4]]];
   */
  function flatten(array, shallow) {
    var index = -1,
        length = array ? array.length : 0,
        result = [];

    while (++index < length) {
      var value = array[index];

      // recursively flatten arrays (susceptible to call stack limits)
      if (isArray(value)) {
        push.apply(result, shallow ? value : flatten(value));
      } else {
        result.push(value);
      }
    }
    return result;
  }

  /**
   * Gets the index at which the first occurrence of `value` is found using
   * strict equality for comparisons, i.e. `===`. If the `array` is already
   * sorted, passing `true` for `fromIndex` will run a faster binary search.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to search.
   * @param {Mixed} value The value to search for.
   * @param {Boolean|Number} [fromIndex=0] The index to search from or `true` to
   *  perform a binary search on a sorted `array`.
   * @returns {Number} Returns the index of the matched value or `-1`.
   * @example
   *
   * _.indexOf([1, 2, 3, 1, 2, 3], 2);
   * // => 1
   *
   * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
   * // => 4
   *
   * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
   * // => 2
   */
  function indexOf(array, value, fromIndex) {
    var index = -1,
        length = array ? array.length : 0;

    if (typeof fromIndex == 'number') {
      index = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0) - 1;
    } else if (fromIndex) {
      index = sortedIndex(array, value);
      return array[index] === value ? index : -1;
    }
    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * Gets all but the last element of `array`. Pass `n` to exclude the last `n`
   * elements from the result.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to query.
   * @param {Number} [n=1] The number of elements to exclude.
   * @param- {Object} [guard] Internally used to allow this method to work with
   *  others like `_.map` without using their callback `index` argument for `n`.
   * @returns {Array} Returns all but the last element, or `n` elements, of `array`.
   * @example
   *
   * _.initial([3, 2, 1]);
   * // => [3, 2]
   */
  function initial(array, n, guard) {
    if (!array) {
      return [];
    }
    var length = array.length;
    n = n == null || guard ? 1 : n || 0;
    return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
  }

  /**
   * Computes the intersection of all the passed-in arrays using strict equality
   * for comparisons, i.e. `===`.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} [array1, array2, ...] Arrays to process.
   * @returns {Array} Returns a new array of unique elements that are present
   *  in **all** of the arrays.
   * @example
   *
   * _.intersection([1, 2, 3], [101, 2, 1, 10], [2, 1]);
   * // => [1, 2]
   */
  function intersection(array) {
    var args = arguments,
        argsLength = args.length,
        cache = { '0': {} },
        index = -1,
        length = array ? array.length : 0,
        isLarge = length >= 100,
        result = [],
        seen = result;

    outer:
    while (++index < length) {
      var value = array[index];
      if (isLarge) {
        var key = value + '';
        var inited = hasOwnProperty.call(cache[0], key)
          ? !(seen = cache[0][key])
          : (seen = cache[0][key] = []);
      }
      if (inited || indexOf(seen, value) < 0) {
        if (isLarge) {
          seen.push(value);
        }
        var argsIndex = argsLength;
        while (--argsIndex) {
          if (!(cache[argsIndex] || (cache[argsIndex] = cachedContains(args[argsIndex], 0, 100)))(value)) {
            continue outer;
          }
        }
        result.push(value);
      }
    }
    return result;
  }

  /**
   * Gets the last element of the `array`. Pass `n` to return the last `n`
   * elements of the `array`.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to query.
   * @param {Number} [n] The number of elements to return.
   * @param- {Object} [guard] Internally used to allow this method to work with
   *  others like `_.map` without using their callback `index` argument for `n`.
   * @returns {Mixed} Returns the last element, or an array of the last `n`
   *  elements, of `array`.
   * @example
   *
   * _.last([3, 2, 1]);
   * // => 1
   */
  function last(array, n, guard) {
    if (array) {
      var length = array.length;
      return (n == null || guard) ? array[length - 1] : slice(array, nativeMax(0, length - n));
    }
  }

  /**
   * Gets the index at which the last occurrence of `value` is found using strict
   * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
   * as the offset from the end of the collection.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to search.
   * @param {Mixed} value The value to search for.
   * @param {Number} [fromIndex=array.length-1] The index to search from.
   * @returns {Number} Returns the index of the matched value or `-1`.
   * @example
   *
   * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
   * // => 4
   *
   * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
   * // => 1
   */
  function lastIndexOf(array, value, fromIndex) {
    var index = array ? array.length : 0;
    if (typeof fromIndex == 'number') {
      index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
    }
    while (index--) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * Creates an object composed from arrays of `keys` and `values`. Pass either
   * a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`, or
   * two arrays, one of `keys` and one of corresponding `values`.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} keys The array of keys.
   * @param {Array} [values=[]] The array of values.
   * @returns {Object} Returns an object composed of the given keys and
   *  corresponding values.
   * @example
   *
   * _.object(['moe', 'larry', 'curly'], [30, 40, 50]);
   * // => { 'moe': 30, 'larry': 40, 'curly': 50 }
   */
  function object(keys, values) {
    var index = -1,
        length = keys ? keys.length : 0,
        result = {};

    while (++index < length) {
      var key = keys[index];
      if (values) {
        result[key] = values[index];
      } else {
        result[key[0]] = key[1];
      }
    }
    return result;
  }

  /**
   * Creates an array of numbers (positive and/or negative) progressing from
   * `start` up to but not including `stop`. This method is a port of Python's
   * `range()` function. See http://docs.python.org/library/functions.html#range.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Number} [start=0] The start of the range.
   * @param {Number} end The end of the range.
   * @param {Number} [step=1] The value to increment or descrement by.
   * @returns {Array} Returns a new range array.
   * @example
   *
   * _.range(10);
   * // => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
   *
   * _.range(1, 11);
   * // => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
   *
   * _.range(0, 30, 5);
   * // => [0, 5, 10, 15, 20, 25]
   *
   * _.range(0, -10, -1);
   * // => [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
   *
   * _.range(0);
   * // => []
   */
  function range(start, end, step) {
    start = +start || 0;
    step = +step || 1;

    if (end == null) {
      end = start;
      start = 0;
    }
    // use `Array(length)` so V8 will avoid the slower "dictionary" mode
    // http://youtu.be/XAqIpGU8ZZk#t=17m25s
    var index = -1,
        length = nativeMax(0, ceil((end - start) / step)),
        result = Array(length);

    while (++index < length) {
      result[index] = start;
      start += step;
    }
    return result;
  }

  /**
   * The opposite of `_.initial`, this method gets all but the first value of
   * `array`. Pass `n` to exclude the first `n` values from the result.
   *
   * @static
   * @memberOf _
   * @alias drop, tail
   * @category Arrays
   * @param {Array} array The array to query.
   * @param {Number} [n=1] The number of elements to exclude.
   * @param- {Object} [guard] Internally used to allow this method to work with
   *  others like `_.map` without using their callback `index` argument for `n`.
   * @returns {Array} Returns all but the first element, or `n` elements, of `array`.
   * @example
   *
   * _.rest([3, 2, 1]);
   * // => [2, 1]
   */
  function rest(array, n, guard) {
    return slice(array, (n == null || guard) ? 1 : nativeMax(0, n));
  }

  /**
   * Uses a binary search to determine the smallest index at which the `value`
   * should be inserted into `array` in order to maintain the sort order of the
   * sorted `array`. If `callback` is passed, it will be executed for `value` and
   * each element in `array` to compute their sort ranking. The `callback` is
   * bound to `thisArg` and invoked with one argument; (value). The `callback`
   * argument may also be the name of a property to order by.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to iterate over.
   * @param {Mixed} value The value to evaluate.
   * @param {Function|String} [callback=identity|property] The function called
   *  per iteration or property name to order by.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Number} Returns the index at which the value should be inserted
   *  into `array`.
   * @example
   *
   * _.sortedIndex([20, 30, 50], 40);
   * // => 2
   *
   * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
   * // => 2
   *
   * var dict = {
   *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
   * };
   *
   * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
   *   return dict.wordToNumber[word];
   * });
   * // => 2
   *
   * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
   *   return this.wordToNumber[word];
   * }, dict);
   * // => 2
   */
  function sortedIndex(array, value, callback, thisArg) {
    var low = 0,
        high = array ? array.length : low;

    // explicitly reference `identity` for better inlining in Firefox
    callback = callback ? createCallback(callback, thisArg) : identity;
    value = callback(value);

    while (low < high) {
      var mid = (low + high) >>> 1;
      callback(array[mid]) < value
        ? low = mid + 1
        : high = mid;
    }
    return low;
  }

  /**
   * Computes the union of the passed-in arrays using strict equality for
   * comparisons, i.e. `===`.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} [array1, array2, ...] Arrays to process.
   * @returns {Array} Returns a new array of unique values, in order, that are
   *  present in one or more of the arrays.
   * @example
   *
   * _.union([1, 2, 3], [101, 2, 1, 10], [2, 1]);
   * // => [1, 2, 3, 101, 10]
   */
  function union() {
    return uniq(concat.apply(arrayRef, arguments));
  }

  /**
   * Creates a duplicate-value-free version of the `array` using strict equality
   * for comparisons, i.e. `===`. If the `array` is already sorted, passing `true`
   * for `isSorted` will run a faster algorithm. If `callback` is passed, each
   * element of `array` is passed through a callback` before uniqueness is computed.
   * The `callback` is bound to `thisArg` and invoked with three arguments; (value, index, array).
   *
   * @static
   * @memberOf _
   * @alias unique
   * @category Arrays
   * @param {Array} array The array to process.
   * @param {Boolean} [isSorted=false] A flag to indicate that the `array` is already sorted.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a duplicate-value-free array.
   * @example
   *
   * _.uniq([1, 2, 1, 3, 1]);
   * // => [1, 2, 3]
   *
   * _.uniq([1, 1, 2, 2, 3], true);
   * // => [1, 2, 3]
   *
   * _.uniq([1, 2, 1.5, 3, 2.5], function(num) { return Math.floor(num); });
   * // => [1, 2, 3]
   *
   * _.uniq([1, 2, 1.5, 3, 2.5], function(num) { return this.floor(num); }, Math);
   * // => [1, 2, 3]
   */
  function uniq(array, isSorted, callback, thisArg) {
    var index = -1,
        length = array ? array.length : 0,
        result = [],
        seen = result;

    // juggle arguments
    if (typeof isSorted == 'function') {
      thisArg = callback;
      callback = isSorted;
      isSorted = false;
    }
    // init value cache for large arrays
    var isLarge = !isSorted && length >= 75;
    if (isLarge) {
      var cache = {};
    }
    if (callback) {
      seen = [];
      callback = createCallback(callback, thisArg);
    }
    while (++index < length) {
      var value = array[index],
          computed = callback ? callback(value, index, array) : value;

      if (isLarge) {
        var key = computed + '';
        var inited = hasOwnProperty.call(cache, key)
          ? !(seen = cache[key])
          : (seen = cache[key] = []);
      }
      if (isSorted
            ? !index || seen[seen.length - 1] !== computed
            : inited || indexOf(seen, computed) < 0
          ) {
        if (callback || isLarge) {
          seen.push(computed);
        }
        result.push(value);
      }
    }
    return result;
  }

  /**
   * Creates an array with all occurrences of the passed values removed using
   * strict equality for comparisons, i.e. `===`.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to filter.
   * @param {Mixed} [value1, value2, ...] Values to remove.
   * @returns {Array} Returns a new filtered array.
   * @example
   *
   * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
   * // => [2, 3, 4]
   */
  function without(array) {
    var index = -1,
        length = array ? array.length : 0,
        contains = cachedContains(arguments, 1, 20),
        result = [];

    while (++index < length) {
      var value = array[index];
      if (!contains(value)) {
        result.push(value);
      }
    }
    return result;
  }

  /**
   * Groups the elements of each array at their corresponding indexes. Useful for
   * separate data sources that are coordinated through matching array indexes.
   * For a matrix of nested arrays, `_.zip.apply(...)` can transpose the matrix
   * in a similar fashion.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} [array1, array2, ...] Arrays to process.
   * @returns {Array} Returns a new array of grouped elements.
   * @example
   *
   * _.zip(['moe', 'larry', 'curly'], [30, 40, 50], [true, false, false]);
   * // => [['moe', 30, true], ['larry', 40, false], ['curly', 50, false]]
   */
  function zip(array) {
    var index = -1,
        length = array ? max(pluck(arguments, 'length')) : 0,
        result = Array(length);

    while (++index < length) {
      result[index] = pluck(arguments, index);
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a function that is restricted to executing `func` only after it is
   * called `n` times. The `func` is executed with the `this` binding of the
   * created function.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Number} n The number of times the function must be called before
   * it is executed.
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new restricted function.
   * @example
   *
   * var renderNotes = _.after(notes.length, render);
   * _.forEach(notes, function(note) {
   *   note.asyncSave({ 'success': renderNotes });
   * });
   * // `renderNotes` is run once, after all notes have saved
   */
  function after(n, func) {
    if (n < 1) {
      return func();
    }
    return function() {
      if (--n < 1) {
        return func.apply(this, arguments);
      }
    };
  }

  /**
   * Creates a function that, when called, invokes `func` with the `this`
   * binding of `thisArg` and prepends any additional `bind` arguments to those
   * passed to the bound function.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to bind.
   * @param {Mixed} [thisArg] The `this` binding of `func`.
   * @param {Mixed} [arg1, arg2, ...] Arguments to be partially applied.
   * @returns {Function} Returns the new bound function.
   * @example
   *
   * var func = function(greeting) {
   *   return greeting + ' ' + this.name;
   * };
   *
   * func = _.bind(func, { 'name': 'moe' }, 'hi');
   * func();
   * // => 'hi moe'
   */
  function bind(func, thisArg) {
    // use `Function#bind` if it exists and is fast
    // (in V8 `Function#bind` is slower except when partially applied)
    return isBindFast || (nativeBind && arguments.length > 2)
      ? nativeBind.call.apply(nativeBind, arguments)
      : createBound(func, thisArg, slice(arguments, 2));
  }

  /**
   * Binds methods on `object` to `object`, overwriting the existing method.
   * If no method names are provided, all the function properties of `object`
   * will be bound.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Object} object The object to bind and assign the bound methods to.
   * @param {String} [methodName1, methodName2, ...] Method names on the object to bind.
   * @returns {Object} Returns `object`.
   * @example
   *
   * var buttonView = {
   *  'label': 'lodash',
   *  'onClick': function() { alert('clicked: ' + this.label); }
   * };
   *
   * _.bindAll(buttonView);
   * jQuery('#lodash_button').on('click', buttonView.onClick);
   * // => When the button is clicked, `this.label` will have the correct value
   */
  function bindAll(object) {
    var funcs = arguments,
        index = funcs.length > 1 ? 0 : (funcs = functions(object), -1),
        length = funcs.length;

    while (++index < length) {
      var key = funcs[index];
      object[key] = bind(object[key], object);
    }
    return object;
  }

  /**
   * Creates a function that, when called, invokes the method at `object[key]`
   * and prepends any additional `bindKey` arguments to those passed to the bound
   * function. This method differs from `_.bind` by allowing bound functions to
   * reference methods that will be redefined or don't yet exist.
   * See http://michaux.ca/articles/lazy-function-definition-pattern.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Object} object The object the method belongs to.
   * @param {String} key The key of the method.
   * @param {Mixed} [arg1, arg2, ...] Arguments to be partially applied.
   * @returns {Function} Returns the new bound function.
   * @example
   *
   * var object = {
   *   'name': 'moe',
   *   'greet': function(greeting) {
   *     return greeting + ' ' + this.name;
   *   }
   * };
   *
   * var func = _.bindKey(object, 'greet', 'hi');
   * func();
   * // => 'hi moe'
   *
   * object.greet = function(greeting) {
   *   return greeting + ', ' + this.name + '!';
   * };
   *
   * func();
   * // => 'hi, moe!'
   */
  function bindKey(object, key) {
    return createBound(object, key, slice(arguments, 2));
  }

  /**
   * Creates a function that is the composition of the passed functions,
   * where each function consumes the return value of the function that follows.
   * In math terms, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
   * Each function is executed with the `this` binding of the composed function.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} [func1, func2, ...] Functions to compose.
   * @returns {Function} Returns the new composed function.
   * @example
   *
   * var greet = function(name) { return 'hi: ' + name; };
   * var exclaim = function(statement) { return statement + '!'; };
   * var welcome = _.compose(exclaim, greet);
   * welcome('moe');
   * // => 'hi: moe!'
   */
  function compose() {
    var funcs = arguments;
    return function() {
      var args = arguments,
          length = funcs.length;

      while (length--) {
        args = [funcs[length].apply(this, args)];
      }
      return args[0];
    };
  }

  /**
   * Creates a function that will delay the execution of `func` until after
   * `wait` milliseconds have elapsed since the last time it was invoked. Pass
   * `true` for `immediate` to cause debounce to invoke `func` on the leading,
   * instead of the trailing, edge of the `wait` timeout. Subsequent calls to
   * the debounced function will return the result of the last `func` call.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to debounce.
   * @param {Number} wait The number of milliseconds to delay.
   * @param {Boolean} immediate A flag to indicate execution is on the leading
   *  edge of the timeout.
   * @returns {Function} Returns the new debounced function.
   * @example
   *
   * var lazyLayout = _.debounce(calculateLayout, 300);
   * jQuery(window).on('resize', lazyLayout);
   */
  function debounce(func, wait, immediate) {
    var args,
        result,
        thisArg,
        timeoutId;

    function delayed() {
      timeoutId = null;
      if (!immediate) {
        result = func.apply(thisArg, args);
      }
    }
    return function() {
      var isImmediate = immediate && !timeoutId;
      args = arguments;
      thisArg = this;

      clearTimeout(timeoutId);
      timeoutId = setTimeout(delayed, wait);

      if (isImmediate) {
        result = func.apply(thisArg, args);
      }
      return result;
    };
  }

  /**
   * Executes the `func` function after `wait` milliseconds. Additional arguments
   * will be passed to `func` when it is invoked.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to delay.
   * @param {Number} wait The number of milliseconds to delay execution.
   * @param {Mixed} [arg1, arg2, ...] Arguments to invoke the function with.
   * @returns {Number} Returns the `setTimeout` timeout id.
   * @example
   *
   * var log = _.bind(console.log, console);
   * _.delay(log, 1000, 'logged later');
   * // => 'logged later' (Appears after one second.)
   */
  function delay(func, wait) {
    var args = slice(arguments, 2);
    return setTimeout(function() { func.apply(undefined, args); }, wait);
  }

  /**
   * Defers executing the `func` function until the current call stack has cleared.
   * Additional arguments will be passed to `func` when it is invoked.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to defer.
   * @param {Mixed} [arg1, arg2, ...] Arguments to invoke the function with.
   * @returns {Number} Returns the `setTimeout` timeout id.
   * @example
   *
   * _.defer(function() { alert('deferred'); });
   * // returns from the function before `alert` is called
   */
  function defer(func) {
    var args = slice(arguments, 1);
    return setTimeout(function() { func.apply(undefined, args); }, 1);
  }

  /**
   * Creates a function that memoizes the result of `func`. If `resolver` is
   * passed, it will be used to determine the cache key for storing the result
   * based on the arguments passed to the memoized function. By default, the first
   * argument passed to the memoized function is used as the cache key. The `func`
   * is executed with the `this` binding of the memoized function.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to have its output memoized.
   * @param {Function} [resolver] A function used to resolve the cache key.
   * @returns {Function} Returns the new memoizing function.
   * @example
   *
   * var fibonacci = _.memoize(function(n) {
   *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
   * });
   */
  function memoize(func, resolver) {
    var cache = {};
    return function() {
      var key = resolver ? resolver.apply(this, arguments) : arguments[0];
      return hasOwnProperty.call(cache, key)
        ? cache[key]
        : (cache[key] = func.apply(this, arguments));
    };
  }

  /**
   * Creates a function that is restricted to execute `func` once. Repeat calls to
   * the function will return the value of the first call. The `func` is executed
   * with the `this` binding of the created function.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new restricted function.
   * @example
   *
   * var initialize = _.once(createApplication);
   * initialize();
   * initialize();
   * // Application is only created once.
   */
  function once(func) {
    var result,
        ran = false;

    return function() {
      if (ran) {
        return result;
      }
      ran = true;
      result = func.apply(this, arguments);

      // clear the `func` variable so the function may be garbage collected
      func = null;
      return result;
    };
  }

  /**
   * Creates a function that, when called, invokes `func` with any additional
   * `partial` arguments prepended to those passed to the new function. This
   * method is similar to `bind`, except it does **not** alter the `this` binding.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to partially apply arguments to.
   * @param {Mixed} [arg1, arg2, ...] Arguments to be partially applied.
   * @returns {Function} Returns the new partially applied function.
   * @example
   *
   * var greet = function(greeting, name) { return greeting + ': ' + name; };
   * var hi = _.partial(greet, 'hi');
   * hi('moe');
   * // => 'hi: moe'
   */
  function partial(func) {
    return createBound(func, slice(arguments, 1));
  }

  /**
   * Creates a function that, when executed, will only call the `func`
   * function at most once per every `wait` milliseconds. If the throttled
   * function is invoked more than once during the `wait` timeout, `func` will
   * also be called on the trailing edge of the timeout. Subsequent calls to the
   * throttled function will return the result of the last `func` call.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to throttle.
   * @param {Number} wait The number of milliseconds to throttle executions to.
   * @returns {Function} Returns the new throttled function.
   * @example
   *
   * var throttled = _.throttle(updatePosition, 100);
   * jQuery(window).on('scroll', throttled);
   */
  function throttle(func, wait) {
    var args,
        result,
        thisArg,
        timeoutId,
        lastCalled = 0;

    function trailingCall() {
      lastCalled = new Date;
      timeoutId = null;
      result = func.apply(thisArg, args);
    }
    return function() {
      var now = new Date,
          remaining = wait - (now - lastCalled);

      args = arguments;
      thisArg = this;

      if (remaining <= 0) {
        clearTimeout(timeoutId);
        timeoutId = null;
        lastCalled = now;
        result = func.apply(thisArg, args);
      }
      else if (!timeoutId) {
        timeoutId = setTimeout(trailingCall, remaining);
      }
      return result;
    };
  }

  /**
   * Creates a function that passes `value` to the `wrapper` function as its
   * first argument. Additional arguments passed to the function are appended
   * to those passed to the `wrapper` function. The `wrapper` is executed with
   * the `this` binding of the created function.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Mixed} value The value to wrap.
   * @param {Function} wrapper The wrapper function.
   * @returns {Function} Returns the new function.
   * @example
   *
   * var hello = function(name) { return 'hello ' + name; };
   * hello = _.wrap(hello, function(func) {
   *   return 'before, ' + func('moe') + ', after';
   * });
   * hello();
   * // => 'before, hello moe, after'
   */
  function wrap(value, wrapper) {
    return function() {
      var args = [value];
      push.apply(args, arguments);
      return wrapper.apply(this, args);
    };
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
   * corresponding HTML entities.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {String} string The string to escape.
   * @returns {String} Returns the escaped string.
   * @example
   *
   * _.escape('Moe, Larry & Curly');
   * // => 'Moe, Larry &amp; Curly'
   */
  function escape(string) {
    return string == null ? '' : (string + '').replace(reUnescapedHtml, escapeHtmlChar);
  }

  /**
   * This function returns the first argument passed to it.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Mixed} value Any value.
   * @returns {Mixed} Returns `value`.
   * @example
   *
   * var moe = { 'name': 'moe' };
   * moe === _.identity(moe);
   * // => true
   */
  function identity(value) {
    return value;
  }

  /**
   * Adds functions properties of `object` to the `lodash` function and chainable
   * wrapper.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Object} object The object of function properties to add to `lodash`.
   * @example
   *
   * _.mixin({
   *   'capitalize': function(string) {
   *     return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
   *   }
   * });
   *
   * _.capitalize('larry');
   * // => 'Larry'
   *
   * _('curly').capitalize();
   * // => 'Curly'
   */
  function mixin(object) {
    forEach(functions(object), function(methodName) {
      var func = lodash[methodName] = object[methodName];

      lodash.prototype[methodName] = function() {
        var args = [this.__wrapped__];
        push.apply(args, arguments);

        var result = func.apply(lodash, args);
        return new lodash(result);
      };
    });
  }

  /**
   * Reverts the '_' variable to its previous value and returns a reference to
   * the `lodash` function.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @returns {Function} Returns the `lodash` function.
   * @example
   *
   * var lodash = _.noConflict();
   */
  function noConflict() {
    window._ = oldDash;
    return this;
  }

  /**
   * Produces a random number between `min` and `max` (inclusive). If only one
   * argument is passed, a number between `0` and the given number will be returned.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Number} [min=0] The minimum possible value.
   * @param {Number} [max=1] The maximum possible value.
   * @returns {Number} Returns a random number.
   * @example
   *
   * _.random(0, 5);
   * // => a number between 1 and 5
   *
   * _.random(5);
   * // => also a number between 1 and 5
   */
  function random(min, max) {
    if (min == null && max == null) {
      max = 1;
    }
    min = +min || 0;
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + floor(nativeRandom() * ((+max || 0) - min + 1));
  }

  /**
   * Resolves the value of `property` on `object`. If `property` is a function
   * it will be invoked and its result returned, else the property value is
   * returned. If `object` is falsey, then `null` is returned.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Object} object The object to inspect.
   * @param {String} property The property to get the value of.
   * @returns {Mixed} Returns the resolved value.
   * @example
   *
   * var object = {
   *   'cheese': 'crumpets',
   *   'stuff': function() {
   *     return 'nonsense';
   *   }
   * };
   *
   * _.result(object, 'cheese');
   * // => 'crumpets'
   *
   * _.result(object, 'stuff');
   * // => 'nonsense'
   */
  function result(object, property) {
    // based on Backbone's private `getValue` function
    // https://github.com/documentcloud/backbone/blob/0.9.2/backbone.js#L1419-1424
    var value = object ? object[property] : null;
    return isFunction(value) ? object[property]() : value;
  }

  /**
   * A micro-templating method that handles arbitrary delimiters, preserves
   * whitespace, and correctly escapes quotes within interpolated code.
   *
   * Note: In the development build `_.template` utilizes sourceURLs for easier
   * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
   *
   * Note: Lo-Dash may be used in Chrome extensions by either creating a `lodash csp`
   * build and avoiding `_.template` use, or loading Lo-Dash in a sandboxed page.
   * See http://developer.chrome.com/trunk/extensions/sandboxingEval.html
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {String} text The template text.
   * @param {Obect} data The data object used to populate the text.
   * @param {Object} options The options object.
   *  escape - The "escape" delimiter regexp.
   *  evaluate - The "evaluate" delimiter regexp.
   *  interpolate - The "interpolate" delimiter regexp.
   *  sourceURL - The sourceURL of the template's compiled source.
   *  variable - The data object variable name.
   *
   * @returns {Function|String} Returns a compiled function when no `data` object
   *  is given, else it returns the interpolated text.
   * @example
   *
   * // using a compiled template
   * var compiled = _.template('hello <%= name %>');
   * compiled({ 'name': 'moe' });
   * // => 'hello moe'
   *
   * var list = '<% _.forEach(people, function(name) { %><li><%= name %></li><% }); %>';
   * _.template(list, { 'people': ['moe', 'larry', 'curly'] });
   * // => '<li>moe</li><li>larry</li><li>curly</li>'
   *
   * // using the "escape" delimiter to escape HTML in data property values
   * _.template('<b><%- value %></b>', { 'value': '<script>' });
   * // => '<b>&lt;script&gt;</b>'
   *
   * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
   * _.template('hello ${ name }', { 'name': 'curly' });
   * // => 'hello curly'
   *
   * // using the internal `print` function in "evaluate" delimiters
   * _.template('<% print("hello " + epithet); %>!', { 'epithet': 'stooge' });
   * // => 'hello stooge!'
   *
   * // using custom template delimiters
   * _.templateSettings = {
   *   'interpolate': /{{([\s\S]+?)}}/g
   * };
   *
   * _.template('hello {{ name }}!', { 'name': 'mustache' });
   * // => 'hello mustache!'
   *
   * // using the `sourceURL` option to specify a custom sourceURL for the template
   * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
   * compiled(data);
   * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
   *
   * // using the `variable` option to ensure a with-statement isn't used in the compiled template
   * var compiled = _.template('hello <%= data.name %>!', null, { 'variable': 'data' });
   * compiled.source;
   * // => function(data) {
   *   var __t, __p = '', __e = _.escape;
   *   __p += 'hello ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
   *   return __p;
   * }
   *
   * // using the `source` property to inline compiled templates for meaningful
   * // line numbers in error messages and a stack trace
   * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
   *   var JST = {\
   *     "main": ' + _.template(mainText).source + '\
   *   };\
   * ');
   */
  function template(text, data, options) {
    // based on John Resig's `tmpl` implementation
    // http://ejohn.org/blog/javascript-micro-templating/
    // and Laura Doktorova's doT.js
    // https://github.com/olado/doT
    text || (text = '');
    options || (options = {});

    var isEvaluating,
        result,
        settings = lodash.templateSettings,
        index = 0,
        interpolate = options.interpolate || settings.interpolate || reNoMatch,
        source = "__p += '",
        variable = options.variable || settings.variable,
        hasVariable = variable;

    // compile regexp to match each delimiter
    var reDelimiters = RegExp(
      (options.escape || settings.escape || reNoMatch).source + '|' +
      interpolate.source + '|' +
      (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
      (options.evaluate || settings.evaluate || reNoMatch).source + '|$'
    , 'g');

    text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
      interpolateValue || (interpolateValue = esTemplateValue);

      // escape characters that cannot be included in string literals
      source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);

      // replace delimiters with snippets
      if (escapeValue) {
        source += "' +\n__e(" + escapeValue + ") +\n'";
      }
      if (evaluateValue) {
        source += "';\n" + evaluateValue + ";\n__p += '";
      }
      if (interpolateValue) {
        source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
      }
      isEvaluating || (isEvaluating = evaluateValue || reComplexDelimiter.test(escapeValue || interpolateValue));
      index = offset + match.length;

      // the JS engine embedded in Adobe products requires returning the `match`
      // string in order to produce the correct `offset` value
      return match;
    });

    source += "';\n";

    // if `variable` is not specified and the template contains "evaluate"
    // delimiters, wrap a with-statement around the generated code to add the
    // data object to the top of the scope chain
    if (!hasVariable) {
      variable = 'obj';
      if (isEvaluating) {
        source = 'with (' + variable + ') {\n' + source + '\n}\n';
      }
      else {
        // avoid a with-statement by prepending data object references to property names
        var reDoubleVariable = RegExp('(\\(\\s*)' + variable + '\\.' + variable + '\\b', 'g');
        source = source
          .replace(reInsertVariable, '$&' + variable + '.')
          .replace(reDoubleVariable, '$1__d');
      }
    }

    // cleanup code by stripping empty strings
    source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
      .replace(reEmptyStringMiddle, '$1')
      .replace(reEmptyStringTrailing, '$1;');

    // frame code as the function body
    source = 'function(' + variable + ') {\n' +
      (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
      "var __t, __p = '', __e = _.escape" +
      (isEvaluating
        ? ', __j = Array.prototype.join;\n' +
          "function print() { __p += __j.call(arguments, '') }\n"
        : (hasVariable ? '' : ', __d = ' + variable + '.' + variable + ' || ' + variable) + ';\n'
      ) +
      source +
      'return __p\n}';

    // use a sourceURL for easier debugging
    // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
    var sourceURL = useSourceURL
      ? '\n//@ sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']')
      : '';

    try {
      result = Function('_', 'return ' + source + sourceURL)(lodash);
    } catch(e) {
      e.source = source;
      throw e;
    }

    if (data) {
      return result(data);
    }
    // provide the compiled function's source via its `toString` method, in
    // supported environments, or the `source` property as a convenience for
    // inlining compiled templates during the build process
    result.source = source;
    return result;
  }

  /**
   * Executes the `callback` function `n` times, returning an array of the results
   * of each `callback` execution. The `callback` is bound to `thisArg` and invoked
   * with one argument; (index).
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Number} n The number of times to execute the callback.
   * @param {Function} callback The function called per iteration.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a new array of the results of each `callback` execution.
   * @example
   *
   * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
   * // => [3, 6, 4]
   *
   * _.times(3, function(n) { mage.castSpell(n); });
   * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
   *
   * _.times(3, function(n) { this.cast(n); }, mage);
   * // => also calls `mage.castSpell(n)` three times
   */
  function times(n, callback, thisArg) {
    n = +n || 0;
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = callback.call(thisArg, index);
    }
    return result;
  }

  /**
   * The opposite of `_.escape`, this method converts the HTML entities
   * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#x27;` in `string` to their
   * corresponding characters.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {String} string The string to unescape.
   * @returns {String} Returns the unescaped string.
   * @example
   *
   * _.unescape('Moe, Larry &amp; Curly');
   * // => 'Moe, Larry & Curly'
   */
  function unescape(string) {
    return string == null ? '' : (string + '').replace(reEscapedHtml, unescapeHtmlChar);
  }

  /**
   * Generates a unique ID. If `prefix` is passed, the ID will be appended to it.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {String} [prefix] The value to prefix the ID with.
   * @returns {String} Returns the unique ID.
   * @example
   *
   * _.uniqueId('contact_');
   * // => 'contact_104'
   *
   * _.uniqueId();
   * // => '105'
   */
  function uniqueId(prefix) {
    return (prefix == null ? '' : prefix + '') + (++idCounter);
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Invokes `interceptor` with the `value` as the first argument, and then
   * returns `value`. The purpose of this method is to "tap into" a method chain,
   * in order to perform operations on intermediate results within the chain.
   *
   * @static
   * @memberOf _
   * @category Chaining
   * @param {Mixed} value The value to pass to `interceptor`.
   * @param {Function} interceptor The function to invoke.
   * @returns {Mixed} Returns `value`.
   * @example
   *
   * _.chain([1, 2, 3, 200])
   *  .filter(function(num) { return num % 2 == 0; })
   *  .tap(alert)
   *  .map(function(num) { return num * num; })
   *  .value();
   * // => // [2, 200] (alerted)
   * // => [4, 40000]
   */
  function tap(value, interceptor) {
    interceptor(value);
    return value;
  }

  /**
   * Produces the `toString` result of the wrapped value.
   *
   * @name toString
   * @memberOf _
   * @category Chaining
   * @returns {String} Returns the string result.
   * @example
   *
   * _([1, 2, 3]).toString();
   * // => '1,2,3'
   */
  function wrapperToString() {
    return this.__wrapped__ + '';
  }

  /**
   * Extracts the wrapped value.
   *
   * @name valueOf
   * @memberOf _
   * @alias value
   * @category Chaining
   * @returns {Mixed} Returns the wrapped value.
   * @example
   *
   * _([1, 2, 3]).valueOf();
   * // => [1, 2, 3]
   */
  function wrapperValueOf() {
    return this.__wrapped__;
  }

  /*--------------------------------------------------------------------------*/

  // add functions that return wrapped values when chaining
  lodash.after = after;
  lodash.assign = assign;
  lodash.bind = bind;
  lodash.bindAll = bindAll;
  lodash.bindKey = bindKey;
  lodash.compact = compact;
  lodash.compose = compose;
  lodash.countBy = countBy;
  lodash.debounce = debounce;
  lodash.defaults = defaults;
  lodash.defer = defer;
  lodash.delay = delay;
  lodash.difference = difference;
  lodash.filter = filter;
  lodash.flatten = flatten;
  lodash.forEach = forEach;
  lodash.forIn = forIn;
  lodash.forOwn = forOwn;
  lodash.functions = functions;
  lodash.groupBy = groupBy;
  lodash.initial = initial;
  lodash.intersection = intersection;
  lodash.invert = invert;
  lodash.invoke = invoke;
  lodash.keys = keys;
  lodash.map = map;
  lodash.max = max;
  lodash.memoize = memoize;
  lodash.merge = merge;
  lodash.min = min;
  lodash.object = object;
  lodash.omit = omit;
  lodash.once = once;
  lodash.pairs = pairs;
  lodash.partial = partial;
  lodash.pick = pick;
  lodash.pluck = pluck;
  lodash.range = range;
  lodash.reject = reject;
  lodash.rest = rest;
  lodash.shuffle = shuffle;
  lodash.sortBy = sortBy;
  lodash.tap = tap;
  lodash.throttle = throttle;
  lodash.times = times;
  lodash.toArray = toArray;
  lodash.union = union;
  lodash.uniq = uniq;
  lodash.values = values;
  lodash.where = where;
  lodash.without = without;
  lodash.wrap = wrap;
  lodash.zip = zip;

  // add aliases
  lodash.collect = map;
  lodash.drop = rest;
  lodash.each = forEach;
  lodash.extend = assign;
  lodash.methods = functions;
  lodash.select = filter;
  lodash.tail = rest;
  lodash.unique = uniq;

  // add functions to `lodash.prototype`
  mixin(lodash);

  /*--------------------------------------------------------------------------*/

  // add functions that return unwrapped values when chaining
  lodash.clone = clone;
  lodash.cloneDeep = cloneDeep;
  lodash.contains = contains;
  lodash.escape = escape;
  lodash.every = every;
  lodash.find = find;
  lodash.has = has;
  lodash.identity = identity;
  lodash.indexOf = indexOf;
  lodash.isArguments = isArguments;
  lodash.isArray = isArray;
  lodash.isBoolean = isBoolean;
  lodash.isDate = isDate;
  lodash.isElement = isElement;
  lodash.isEmpty = isEmpty;
  lodash.isEqual = isEqual;
  lodash.isFinite = isFinite;
  lodash.isFunction = isFunction;
  lodash.isNaN = isNaN;
  lodash.isNull = isNull;
  lodash.isNumber = isNumber;
  lodash.isObject = isObject;
  lodash.isPlainObject = isPlainObject;
  lodash.isRegExp = isRegExp;
  lodash.isString = isString;
  lodash.isUndefined = isUndefined;
  lodash.lastIndexOf = lastIndexOf;
  lodash.mixin = mixin;
  lodash.noConflict = noConflict;
  lodash.random = random;
  lodash.reduce = reduce;
  lodash.reduceRight = reduceRight;
  lodash.result = result;
  lodash.size = size;
  lodash.some = some;
  lodash.sortedIndex = sortedIndex;
  lodash.template = template;
  lodash.unescape = unescape;
  lodash.uniqueId = uniqueId;

  // add aliases
  lodash.all = every;
  lodash.any = some;
  lodash.detect = find;
  lodash.foldl = reduce;
  lodash.foldr = reduceRight;
  lodash.include = contains;
  lodash.inject = reduce;

  forOwn(lodash, function(func, methodName) {
    if (!lodash.prototype[methodName]) {
      lodash.prototype[methodName] = function() {
        var args = [this.__wrapped__];
        push.apply(args, arguments);
        return func.apply(lodash, args);
      };
    }
  });

  /*--------------------------------------------------------------------------*/

  // add functions capable of returning wrapped and unwrapped values when chaining
  lodash.first = first;
  lodash.last = last;

  // add aliases
  lodash.take = first;
  lodash.head = first;

  forOwn(lodash, function(func, methodName) {
    if (!lodash.prototype[methodName]) {
      lodash.prototype[methodName]= function(n, guard) {
        var result = func(this.__wrapped__, n, guard);
        return (n == null || guard) ? result : new lodash(result);
      };
    }
  });

  /*--------------------------------------------------------------------------*/

  /**
   * The semantic version number.
   *
   * @static
   * @memberOf _
   * @type String
   */
  lodash.VERSION = '1.0.0-rc.3';

  // add "Chaining" functions to the wrapper
  lodash.prototype.toString = wrapperToString;
  lodash.prototype.value = wrapperValueOf;
  lodash.prototype.valueOf = wrapperValueOf;

  // add `Array` functions that return unwrapped values
  each(['join', 'pop', 'shift'], function(methodName) {
    var func = arrayRef[methodName];
    lodash.prototype[methodName] = function() {
      return func.apply(this.__wrapped__, arguments);
    };
  });

  // add `Array` functions that return the wrapped value
  each(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
    var func = arrayRef[methodName];
    lodash.prototype[methodName] = function() {
      func.apply(this.__wrapped__, arguments);
      return this;
    };
  });

  // add `Array` functions that return new wrapped values
  each(['concat', 'slice', 'splice'], function(methodName) {
    var func = arrayRef[methodName];
    lodash.prototype[methodName] = function() {
      var result = func.apply(this.__wrapped__, arguments);
      return new lodash(result);
    };
  });

  // avoid array-like object bugs with `Array#shift` and `Array#splice`
  // in Firefox < 10 and IE < 9
  if (hasObjectSpliceBug) {
    each(['pop', 'shift', 'splice'], function(methodName) {
      var func = arrayRef[methodName],
          isSplice = methodName == 'splice';

      lodash.prototype[methodName] = function() {
        var value = this.__wrapped__,
            result = func.apply(value, arguments);

        if (value.length === 0) {
          delete value[0];
        }
        return isSplice ? new lodash(result) : result;
      };
    });
  }

  // add pseudo private property to be used and removed during the build process
  lodash._each = each;
  lodash._iteratorTemplate = iteratorTemplate;

  /*--------------------------------------------------------------------------*/

  // expose Lo-Dash
  // some AMD build optimizers, like r.js, check for specific condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lo-Dash to the global object even when an AMD loader is present in
    // case Lo-Dash was injected by a third-party script and not intended to be
    // loaded as a module. The global assignment can be reverted in the Lo-Dash
    // module via its `noConflict()` method.
    window._ = lodash;

    // define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module
    define(function() {
      return lodash;
    });
  }
  // check for `exports` after `define` in case a build optimizer adds an `exports` object
  else if (freeExports) {
    // in Node.js or RingoJS v0.8.0+
    if (typeof module == 'object' && module && module.exports == freeExports) {
      (module.exports = lodash)._ = lodash;
    }
    // in Narwhal or RingoJS v0.7.0-
    else {
      freeExports._ = lodash;
    }
  }
  else {
    // in a browser or Rhino
    window._ = lodash;
  }
}(this));
(function(context) {

var ohauth = {};

ohauth.qsString = function(obj) {
    return Object.keys(obj).sort().map(function(key) {
        return encodeURIComponent(key) + '=' + encodeURIComponent(obj[key]);
    }).join('&');
};

ohauth.sha = sha1();

ohauth.stringQs = function(str) {
    return str.split('&').reduce(function(obj, pair){
        var parts = pair.split('=');
        obj[parts[0]] = (null === parts[1]) ? '' : decodeURIComponent(parts[1]);
        return obj;
    }, {});
};

ohauth.xhr = function(method, url, auth, data, options, callback) {
    var xhr = new XMLHttpRequest(),
        twoHundred = /^20\d$/;
    xhr.onreadystatechange = function() {
        if (4 == xhr.readyState && 0 !== xhr.status) {
            if (twoHundred.test(xhr.status)) {
                callback(null, xhr);
            } else {
                callback(xhr, null);
            }
        }
    };
    xhr.onerror = function(e) { return callback(e, null); };
    var headers = (options && options.header) || { 'Content-Type': 'application/x-www-form-urlencoded' };
    xhr.open(method, url, true);
    xhr.setRequestHeader('Authorization', 'OAuth ' + ohauth.authHeader(auth));
    for (var h in headers) xhr.setRequestHeader(h, headers[h]);
    xhr.send(data);
};

ohauth.nonce = function() {
    for (var o = ''; o.length < 6;) {
        o += '0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz'[Math.floor(Math.random() * 61)];
    }
    return o;
};

ohauth.authHeader = function(obj) {
    return Object.keys(obj).sort().map(function(key) {
        return encodeURIComponent(key) + '="' + encodeURIComponent(obj[key]) + '"';
    }).join(', ');
};

ohauth.timestamp = function() { return ~~((+new Date()) / 1000); };

ohauth.percentEncode = function(s) {
    return encodeURIComponent(s)
    .replace(/\!/g, '%21').replace(/\'/g, '%27')
    .replace(/\*/g, '%2A').replace(/\(/g, '%28').replace(/\)/g, '%29');
};

ohauth.baseString = function(method, url, params) {
    if (params.oauth_signature) delete params.oauth_signature;
    return [
        method,
        ohauth.percentEncode(url),
        ohauth.percentEncode(ohauth.qsString(params))].join('&');
};

ohauth.signature = function(oauth_secret, token_secret, baseString) {
    return ohauth.sha.b64_hmac_sha1(
        ohauth.percentEncode(oauth_secret) + '&' +
        ohauth.percentEncode(token_secret),
        baseString);
};

context.ohauth = ohauth;

})(this);

/******************************************************************************
	rtree.js - General-Purpose Non-Recursive Javascript R-Tree Library
	Version 0.6.2, December 5st 2009

@license Copyright (c) 2009 Jon-Carlos Rivera

  Permission is hereby granted, free of charge, to any person obtaining
  a copy of this software and associated documentation files (the
  "Software"), to deal in the Software without restriction, including
  without limitation the rights to use, copy, modify, merge, publish,
  distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to
  the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

	Jon-Carlos Rivera - imbcmdth@hotmail.com
******************************************************************************/

/**
 * RTree - A simple r-tree structure for great results.
 * @constructor
 */
var RTree = function(width){
	// Variables to control tree-dimensions
	var _Min_Width = 3;  // Minimum width of any node before a merge
	var _Max_Width = 6;  // Maximum width of any node before a split
	if(!isNaN(width)){ _Min_Width = Math.floor(width/2.0); _Max_Width = width;}
	// Start with an empty root-tree
	var _T = {x:0, y:0, w:0, h:0, id:"root", nodes:[] };

	var isArray = function(o) {
		return Object.prototype.toString.call(o) === '[object Array]';
	};

	/**@function
	 * @description Function to generate unique strings for element IDs
	 * @param {String} n			The prefix to use for the IDs generated.
	 * @return {String}				A guarenteed unique ID.
	 */
    var _name_to_id = (function() {
        // hide our idCache inside this closure
        var idCache = {};

        // return the api: our function that returns a unique string with incrementing number appended to given idPrefix
        return function(idPrefix) {
            var idVal = 0;
            if(idPrefix in idCache) {
                idVal = idCache[idPrefix]++;
            } else {
                idCache[idPrefix] = 0;
            }
            return idPrefix + "_" + idVal;
        }
    })();

	// This is my special addition to the world of r-trees
	// every other (simple) method I found produced crap trees
	// this skews insertions to prefering squarer and emptier nodes
	RTree.Rectangle.squarified_ratio = function(l, w, fill) {
	  // Area of new enlarged rectangle
	  var lperi = (l + w) / 2.0; // Average size of a side of the new rectangle
	  var larea = l * w; // Area of new rectangle
	  // return the ratio of the perimeter to the area - the closer to 1 we are,
	  // the more "square" a rectangle is. conversly, when approaching zero the
	  // more elongated a rectangle is
	  var lgeo = larea / (lperi*lperi);
	  return(larea * fill / lgeo);
	};

	/**find the best specific node(s) for object to be deleted from
	 * [ leaf node parent ] = _remove_subtree(rectangle, object, root)
	 * @private
	 */
	var _remove_subtree = function(rect, obj, root) {
		var hit_stack = []; // Contains the elements that overlap
		var count_stack = []; // Contains the elements that overlap
		var ret_array = [];
		var current_depth = 1;

		if(!rect || !RTree.Rectangle.overlap_rectangle(rect, root))
		 return ret_array;

		var ret_obj = {x:rect.x, y:rect.y, w:rect.w, h:rect.h, target:obj};

		count_stack.push(root.nodes.length);
		hit_stack.push(root);

		do {
			var tree = hit_stack.pop();
			var i = count_stack.pop()-1;

		  if("target" in ret_obj) { // We are searching for a target
				while(i >= 0)	{
					var ltree = tree.nodes[i];
					if(RTree.Rectangle.overlap_rectangle(ret_obj, ltree)) {
						if( (ret_obj.target && "leaf" in ltree && ltree.leaf === ret_obj.target)
							||(!ret_obj.target && ("leaf" in ltree || RTree.Rectangle.contains_rectangle(ltree, ret_obj)))) { // A Match !!
				  		// Yup we found a match...
				  		// we can cancel search and start walking up the list
				  		if("nodes" in ltree) {// If we are deleting a node not a leaf...
				  			ret_array = _search_subtree(ltree, true, [], ltree);
				  			tree.nodes.splice(i, 1);
				  		} else {
								ret_array = tree.nodes.splice(i, 1);
							}
							// Resize MBR down...
							RTree.Rectangle.make_MBR(tree.nodes, tree);
							delete ret_obj.target;
							if(tree.nodes.length < _Min_Width) { // Underflow
								ret_obj.nodes = _search_subtree(tree, true, [], tree);
							}
							break;
			  		}/*	else if("load" in ltree) { // A load
				  	}*/	else if("nodes" in ltree) { // Not a Leaf
				  		current_depth += 1;
				  		count_stack.push(i);
				  		hit_stack.push(tree);
				  		tree = ltree;
				  		i = ltree.nodes.length;
				  	}
				  }
					i -= 1;
				}
			} else if("nodes" in ret_obj) { // We are unsplitting
				tree.nodes.splice(i+1, 1); // Remove unsplit node
				// ret_obj.nodes contains a list of elements removed from the tree so far
				if(tree.nodes.length > 0)
					RTree.Rectangle.make_MBR(tree.nodes, tree);
				for(var t = 0;t<ret_obj.nodes.length;t++)
					_insert_subtree(ret_obj.nodes[t], tree);
				ret_obj.nodes.length = 0;
				if(hit_stack.length == 0 && tree.nodes.length <= 1) { // Underflow..on root!
					ret_obj.nodes = _search_subtree(tree, true, ret_obj.nodes, tree);
					tree.nodes.length = 0;
					hit_stack.push(tree);
					count_stack.push(1);
				} else if(hit_stack.length > 0 && tree.nodes.length < _Min_Width) { // Underflow..AGAIN!
					ret_obj.nodes = _search_subtree(tree, true, ret_obj.nodes, tree);
					tree.nodes.length = 0;
				}else {
					delete ret_obj.nodes; // Just start resizing
				}
			} else { // we are just resizing
				RTree.Rectangle.make_MBR(tree.nodes, tree);
			}
			current_depth -= 1;
		}while(hit_stack.length > 0);

		return(ret_array);
	};

	/**choose the best damn node for rectangle to be inserted into
	 * [ leaf node parent ] = _choose_leaf_subtree(rectangle, root to start search at)
	 * @private
	 */
	var _choose_leaf_subtree = function(rect, root) {
		var best_choice_index = -1;
		var best_choice_stack = [];
		var best_choice_area;

		var load_callback = function(local_tree, local_node){
			return(function(data) {
				local_tree._attach_data(local_node, data);
			});
		};

		best_choice_stack.push(root);
		var nodes = root.nodes;

		do {
			if(best_choice_index != -1)	{
				best_choice_stack.push(nodes[best_choice_index]);
				nodes = nodes[best_choice_index].nodes;
				best_choice_index = -1;
			}

			for(var i = nodes.length-1; i >= 0; i--) {
				var ltree = nodes[i];
				if("leaf" in ltree) {
					// Bail out of everything and start inserting
					best_choice_index = -1;
					break;
			  } /*else if(ltree.load) {
  				throw( "Can't insert into partially loaded tree ... yet!");
  				//jQuery.getJSON(ltree.load, load_callback(this, ltree));
  				//delete ltree.load;
  			}*/
			  // Area of new enlarged rectangle
			  var old_lratio = RTree.Rectangle.squarified_ratio(ltree.w, ltree.h, ltree.nodes.length+1);

			  // Enlarge rectangle to fit new rectangle
			  var nw = Math.max(ltree.x+ltree.w, rect.x+rect.w) - Math.min(ltree.x, rect.x);
			  var nh = Math.max(ltree.y+ltree.h, rect.y+rect.h) - Math.min(ltree.y, rect.y);

			  // Area of new enlarged rectangle
			  var lratio = RTree.Rectangle.squarified_ratio(nw, nh, ltree.nodes.length+2);

			  if(best_choice_index < 0 || Math.abs(lratio - old_lratio) < best_choice_area) {
			  	best_choice_area = Math.abs(lratio - old_lratio); best_choice_index = i;
			  }
			}
		}while(best_choice_index != -1);

		return(best_choice_stack);
	};

	/**split a set of nodes into two roughly equally-filled nodes
	 * [ an array of two new arrays of nodes ] = linear_split(array of nodes)
	 * @private
	 */
	var _linear_split = function(nodes) {
		var n = _pick_linear(nodes);
		while(nodes.length > 0)	{
			_pick_next(nodes, n[0], n[1]);
		}
		return(n);
	};

	/**insert the best source rectangle into the best fitting parent node: a or b
	 * [] = pick_next(array of source nodes, target node array a, target node array b)
	 * @private
	 */
	var _pick_next = function(nodes, a, b) {
	  // Area of new enlarged rectangle
		var area_a = RTree.Rectangle.squarified_ratio(a.w, a.h, a.nodes.length+1);
		var area_b = RTree.Rectangle.squarified_ratio(b.w, b.h, b.nodes.length+1);
		var high_area_delta;
		var high_area_node;
		var lowest_growth_group;

		for(var i = nodes.length-1; i>=0;i--) {
			var l = nodes[i];
			var new_area_a = {};
			new_area_a.x = Math.min(a.x, l.x); new_area_a.y = Math.min(a.y, l.y);
			new_area_a.w = Math.max(a.x+a.w, l.x+l.w) - new_area_a.x;	new_area_a.h = Math.max(a.y+a.h, l.y+l.h) - new_area_a.y;
			var change_new_area_a = Math.abs(RTree.Rectangle.squarified_ratio(new_area_a.w, new_area_a.h, a.nodes.length+2) - area_a);

			var new_area_b = {};
			new_area_b.x = Math.min(b.x, l.x); new_area_b.y = Math.min(b.y, l.y);
			new_area_b.w = Math.max(b.x+b.w, l.x+l.w) - new_area_b.x;	new_area_b.h = Math.max(b.y+b.h, l.y+l.h) - new_area_b.y;
			var change_new_area_b = Math.abs(RTree.Rectangle.squarified_ratio(new_area_b.w, new_area_b.h, b.nodes.length+2) - area_b);

			if( !high_area_node || !high_area_delta || Math.abs( change_new_area_b - change_new_area_a ) < high_area_delta ) {
				high_area_node = i;
				high_area_delta = Math.abs(change_new_area_b-change_new_area_a);
				lowest_growth_group = change_new_area_b < change_new_area_a ? b : a;
			}
		}
		var temp_node = nodes.splice(high_area_node, 1)[0];
		if(a.nodes.length + nodes.length + 1 <= _Min_Width)	{
			a.nodes.push(temp_node);
			RTree.Rectangle.expand_rectangle(a, temp_node);
		}	else if(b.nodes.length + nodes.length + 1 <= _Min_Width) {
			b.nodes.push(temp_node);
			RTree.Rectangle.expand_rectangle(b, temp_node);
		}
		else {
			lowest_growth_group.nodes.push(temp_node);
			RTree.Rectangle.expand_rectangle(lowest_growth_group, temp_node);
		}
	};

	/**pick the "best" two starter nodes to use as seeds using the "linear" criteria
	 * [ an array of two new arrays of nodes ] = pick_linear(array of source nodes)
	 * @private
	 */
	var _pick_linear = function(nodes) {
		var lowest_high_x = nodes.length-1;
		var highest_low_x = 0;
		var lowest_high_y = nodes.length-1;
		var highest_low_y = 0;
        var t1, t2;

		for(var i = nodes.length-2; i>=0;i--)	{
			var l = nodes[i];
			if(l.x > nodes[highest_low_x].x ) highest_low_x = i;
			else if(l.x+l.w < nodes[lowest_high_x].x+nodes[lowest_high_x].w) lowest_high_x = i;
			if(l.y > nodes[highest_low_y].y ) highest_low_y = i;
			else if(l.y+l.h < nodes[lowest_high_y].y+nodes[lowest_high_y].h) lowest_high_y = i;
		}
		var dx = Math.abs((nodes[lowest_high_x].x+nodes[lowest_high_x].w) - nodes[highest_low_x].x);
		var dy = Math.abs((nodes[lowest_high_y].y+nodes[lowest_high_y].h) - nodes[highest_low_y].y);
		if( dx > dy )	{
			if(lowest_high_x > highest_low_x)	{
				t1 = nodes.splice(lowest_high_x, 1)[0];
				t2 = nodes.splice(highest_low_x, 1)[0];
			}	else {
				t2 = nodes.splice(highest_low_x, 1)[0];
				t1 = nodes.splice(lowest_high_x, 1)[0];
			}
		}	else {
			if(lowest_high_y > highest_low_y)	{
				t1 = nodes.splice(lowest_high_y, 1)[0];
				t2 = nodes.splice(highest_low_y, 1)[0];
			}	else {
				t2 = nodes.splice(highest_low_y, 1)[0];
				t1 = nodes.splice(lowest_high_y, 1)[0];
			}
		}
		return([{x:t1.x, y:t1.y, w:t1.w, h:t1.h, nodes:[t1]},
			      {x:t2.x, y:t2.y, w:t2.w, h:t2.h, nodes:[t2]} ]);
	};

	var _attach_data = function(node, more_tree){
		node.nodes = more_tree.nodes;
		node.x = more_tree.x; node.y = more_tree.y;
		node.w = more_tree.w; node.h = more_tree.h;
		return(node);
	};

	/**non-recursive internal search function
	 * [ nodes | objects ] = _search_subtree(rectangle, [return node data], [array to fill], root to begin search at)
	 * @private
	 */
	var _search_subtree = function(rect, return_node, return_array, root) {
		var hit_stack = []; // Contains the elements that overlap

		if(!RTree.Rectangle.overlap_rectangle(rect, root))
		 return(return_array);

		var load_callback = function(local_tree, local_node){
			return(function(data) {
				local_tree._attach_data(local_node, data);
			});
		};

		hit_stack.push(root.nodes);

		do {
			var nodes = hit_stack.pop();

			for(var i = nodes.length-1; i >= 0; i--) {
				var ltree = nodes[i];
			  if(RTree.Rectangle.overlap_rectangle(rect, ltree)) {
			  	if("nodes" in ltree) { // Not a Leaf
			  		hit_stack.push(ltree.nodes);
			  	} else if("leaf" in ltree) { // A Leaf !!
			  		if(!return_node)
		  				return_array.push(ltree.leaf);
		  			else
		  				return_array.push(ltree);
		  		}/*	else if("load" in ltree) { // We need to fetch a URL for some more tree data
	  				jQuery.getJSON(ltree.load, load_callback(this, ltree));
	  				delete ltree.load;
	  			//	i++; // Replay this entry
	  			}*/
				}
			}
		}while(hit_stack.length > 0);

		return(return_array);
	};

	/**non-recursive internal insert function
	 * [] = _insert_subtree(rectangle, object to insert, root to begin insertion at)
	 * @private
	 */
	var _insert_subtree = function(node, root) {
		var bc; // Best Current node
		// Initial insertion is special because we resize the Tree and we don't
		// care about any overflow (seriously, how can the first object overflow?)
		if(root.nodes.length == 0) {
			root.x = node.x; root.y = node.y;
			root.w = node.w; root.h = node.h;
			root.nodes.push(node);
			return;
		}

		// Find the best fitting leaf node
		// choose_leaf returns an array of all tree levels (including root)
		// that were traversed while trying to find the leaf
		var tree_stack = _choose_leaf_subtree(node, root);
		var ret_obj = node;//{x:rect.x,y:rect.y,w:rect.w,h:rect.h, leaf:obj};

		// Walk back up the tree resizing and inserting as needed
		do {
			//handle the case of an empty node (from a split)
			if(bc && "nodes" in bc && bc.nodes.length == 0) {
				var pbc = bc; // Past bc
				bc = tree_stack.pop();
				for(var t=0;t<bc.nodes.length;t++)
					if(bc.nodes[t] === pbc || bc.nodes[t].nodes.length == 0) {
						bc.nodes.splice(t, 1);
						break;
				}
			} else {
				bc = tree_stack.pop();
			}

			// If there is data attached to this ret_obj
			if("leaf" in ret_obj || "nodes" in ret_obj || isArray(ret_obj)) {
				// Do Insert
				if(isArray(ret_obj)) {
					for(var ai = 0; ai < ret_obj.length; ai++) {
						RTree.Rectangle.expand_rectangle(bc, ret_obj[ai]);
					}
					bc.nodes = bc.nodes.concat(ret_obj);
				} else {
					RTree.Rectangle.expand_rectangle(bc, ret_obj);
					bc.nodes.push(ret_obj); // Do Insert
				}

				if(bc.nodes.length <= _Max_Width)	{ // Start Resizeing Up the Tree
					ret_obj = {x:bc.x,y:bc.y,w:bc.w,h:bc.h};
				}	else { // Otherwise Split this Node
					// linear_split() returns an array containing two new nodes
					// formed from the split of the previous node's overflow
					var a = _linear_split(bc.nodes);
					ret_obj = a;//[1];

					if(tree_stack.length < 1)	{ // If are splitting the root..
						bc.nodes.push(a[0]);
						tree_stack.push(bc);     // Reconsider the root element
						ret_obj = a[1];
					} /*else {
						delete bc;
					}*/
				}
			}	else { // Otherwise Do Resize
				//Just keep applying the new bounding rectangle to the parents..
				RTree.Rectangle.expand_rectangle(bc, ret_obj);
				ret_obj = {x:bc.x,y:bc.y,w:bc.w,h:bc.h};
			}
		} while(tree_stack.length > 0);
	};

	/**quick 'n' dirty function for plugins or manually drawing the tree
	 * [ tree ] = RTree.get_tree(): returns the raw tree data. useful for adding
	 * @public
	 * !! DEPRECATED !!
	 */
	this.get_tree = function() {
		return _T;
	};

	/**quick 'n' dirty function for plugins or manually loading the tree
	 * [ tree ] = RTree.set_tree(sub-tree, where to attach): returns the raw tree data. useful for adding
	 * @public
	 * !! DEPRECATED !!
	 */
	this.set_tree = function(new_tree, where) {
		if(!where)
			where = _T;
		return(_attach_data(where, new_tree));
	};

	/**non-recursive search function
	 * [ nodes | objects ] = RTree.search(rectangle, [return node data], [array to fill])
	 * @public
	 */
	this.search = function(rect, return_node, return_array) {
		if(arguments.length < 1)
			throw "Wrong number of arguments. RT.Search requires at least a bounding rectangle."

		switch(arguments.length) {
			case 1:
				arguments[1] = false;// Add an "return node" flag - may be removed in future
			case 2:
				arguments[2] = []; // Add an empty array to contain results
			case 3:
				arguments[3] = _T; // Add root node to end of argument list
			default:
				arguments.length = 4;
		}
		return(_search_subtree.apply(this, arguments));
	};

	/**partially-recursive toJSON function
	 * [ string ] = RTree.toJSON([rectangle], [tree])
	 * @public
	 */
	this.toJSON = function(rect, tree) {
		var hit_stack = []; // Contains the elements that overlap
		var count_stack = []; // Contains the elements that overlap
		var return_stack = {}; // Contains the elements that overlap
		var max_depth = 3;  // This triggers recursion and tree-splitting
		var current_depth = 1;
		var return_string = "";

		if(rect && !RTree.Rectangle.overlap_rectangle(rect, _T))
		 return "";

		if(!tree)	{
			count_stack.push(_T.nodes.length);
			hit_stack.push(_T.nodes);
			return_string += "var main_tree = {x:"+_T.x.toFixed()+",y:"+_T.y.toFixed()+",w:"+_T.w.toFixed()+",h:"+_T.h.toFixed()+",nodes:[";
		}	else {
			max_depth += 4;
			count_stack.push(tree.nodes.length);
			hit_stack.push(tree.nodes);
			return_string += "var main_tree = {x:"+tree.x.toFixed()+",y:"+tree.y.toFixed()+",w:"+tree.w.toFixed()+",h:"+tree.h.toFixed()+",nodes:[";
		}

		do {
			var nodes = hit_stack.pop();
			var i = count_stack.pop()-1;

			if(i >= 0 && i < nodes.length-1)
				return_string += ",";

			while(i >= 0)	{
				var ltree = nodes[i];
			  if(!rect || RTree.Rectangle.overlap_rectangle(rect, ltree)) {
			  	if(ltree.nodes) { // Not a Leaf
			  		if(current_depth >= max_depth) {
			  			var len = return_stack.length;
			  			var nam = _name_to_id("saved_subtree");
			  			return_string += "{x:"+ltree.x.toFixed()+",y:"+ltree.y.toFixed()+",w:"+ltree.w.toFixed()+",h:"+ltree.h.toFixed()+",load:'"+nam+".js'}";
			  			return_stack[nam] = this.toJSON(rect, ltree);
							if(i > 0)
								return_string += ","
			  		}	else {
				  		return_string += "{x:"+ltree.x.toFixed()+",y:"+ltree.y.toFixed()+",w:"+ltree.w.toFixed()+",h:"+ltree.h.toFixed()+",nodes:[";
				  		current_depth += 1;
				  		count_stack.push(i);
				  		hit_stack.push(nodes);
				  		nodes = ltree.nodes;
				  		i = ltree.nodes.length;
				  	}
			  	}	else if(ltree.leaf) { // A Leaf !!
			  		var data = ltree.leaf.toJSON ? ltree.leaf.toJSON() : JSON.stringify(ltree.leaf);
		  			return_string += "{x:"+ltree.x.toFixed()+",y:"+ltree.y.toFixed()+",w:"+ltree.w.toFixed()+",h:"+ltree.h.toFixed()+",leaf:" + data + "}";
						if(i > 0)
							return_string += ","
		  		}	else if(ltree.load) { // A load
		  			return_string += "{x:"+ltree.x.toFixed()+",y:"+ltree.y.toFixed()+",w:"+ltree.w.toFixed()+",h:"+ltree.h.toFixed()+",load:'" + ltree.load + "'}";
						if(i > 0)
							return_string += ","
			  	}
				}
				i -= 1;
			}
			if(i < 0)	{
					return_string += "]}"; current_depth -= 1;
			}
		}while(hit_stack.length > 0);

		return_string+=";";

		for(var my_key in return_stack) {
			return_string += "\nvar " + my_key + " = function(){" + return_stack[my_key] + " return(main_tree);};";
		}
		return(return_string);
	};

	/**non-recursive function that deletes a specific
	 * [ number ] = RTree.remove(rectangle, obj)
	 */
	this.remove = function(rect, obj) {
		if(arguments.length < 1)
			throw "Wrong number of arguments. RT.remove requires at least a bounding rectangle."

		switch(arguments.length) {
			case 1:
				arguments[1] = false; // obj == false for conditionals
			case 2:
				arguments[2] = _T; // Add root node to end of argument list
			default:
				arguments.length = 3;
		}
		if(arguments[1] === false) { // Do area-wide delete
			var numberdeleted = 0;
			var ret_array = [];
			do {
				numberdeleted=ret_array.length;
				ret_array = ret_array.concat(_remove_subtree.apply(this, arguments));
			}while( numberdeleted !=  ret_array.length);
			return ret_array;
		}
		else { // Delete a specific item
			return(_remove_subtree.apply(this, arguments));
		}
	};

	/**non-recursive insert function
	 * [] = RTree.insert(rectangle, object to insert)
	 */
	this.insert = function(rect, obj) {
/*		if(arguments.length < 2)
			throw "Wrong number of arguments. RT.Insert requires at least a bounding rectangle and an object."*/

		return(_insert_subtree({x:rect.x,y:rect.y,w:rect.w,h:rect.h,leaf:obj}, _T));
	};

	/**non-recursive delete function
	 * [deleted object] = RTree.remove(rectangle, [object to delete])
	 */

//End of RTree
};

/**Rectangle - Generic rectangle object - Not yet used */

RTree.Rectangle = function(ix, iy, iw, ih) { // new Rectangle(bounds) or new Rectangle(x, y, w, h)
    var x, x2, y, y2, w, h;

    if(ix.x) {
		x = ix.x; y = ix.y;
			if(ix.w !== 0 && !ix.w && ix.x2){
				w = ix.x2-ix.x;	h = ix.y2-ix.y;
			}	else {
				w = ix.w;	h = ix.h;
			}
		x2 = x + w; y2 = y + h; // For extra fastitude
	} else {
		x = ix; y = iy;	w = iw;	h = ih;
		x2 = x + w; y2 = y + h; // For extra fastitude
	}

	this.x1 = this.x = x;
	this.y1 = this.y = y;
	this.x2 = x2;
	this.y2 = y2;
	this.w = w;
	this.h = h;

	this.toJSON = function() {
		return('{"x":'+x.toString()+', "y":'+y.toString()+', "w":'+w.toString()+', "h":'+h.toString()+'}');
	};

	this.overlap = function(a) {
		return(this.x() < a.x2() && this.x2() > a.x() && this.y() < a.y2() && this.y2() > a.y());
	};

	this.expand = function(a) {
		var nx = Math.min(this.x(), a.x());
		var ny = Math.min(this.y(), a.y());
		w = Math.max(this.x2(), a.x2()) - nx;
		h = Math.max(this.y2(), a.y2()) - ny;
		x = nx; y = ny;
		return(this);
	};

	this.setRect = function(ix, iy, iw, ih) {
        var x, x2, y, y2, w, h;
		if(ix.x) {
			x = ix.x; y = ix.y;
			if(ix.w !== 0 && !ix.w && ix.x2) {
				w = ix.x2-ix.x;	h = ix.y2-ix.y;
			}	else {
				w = ix.w;	h = ix.h;
			}
			x2 = x + w; y2 = y + h; // For extra fastitude
		} else {
			x = ix; y = iy;	w = iw;	h = ih;
			x2 = x + w; y2 = y + h; // For extra fastitude
		}
	};
//End of RTree.Rectangle
};


/**returns true if rectangle 1 overlaps rectangle 2
 * [ boolean ] = overlap_rectangle(rectangle a, rectangle b)
 * @static function
 */
RTree.Rectangle.overlap_rectangle = function(a, b) {
	return(a.x < (b.x+b.w) && (a.x+a.w) > b.x && a.y < (b.y+b.h) && (a.y+a.h) > b.y);
};

/**returns true if rectangle a is contained in rectangle b
 * [ boolean ] = contains_rectangle(rectangle a, rectangle b)
 * @static function
 */
RTree.Rectangle.contains_rectangle = function(a, b) {
	return((a.x+a.w) <= (b.x+b.w) && a.x >= b.x && (a.y+a.h) <= (b.y+b.h) && a.y >= b.y);
};

/**expands rectangle A to include rectangle B, rectangle B is untouched
 * [ rectangle a ] = expand_rectangle(rectangle a, rectangle b)
 * @static function
 */
RTree.Rectangle.expand_rectangle = function(a, b)	{
	var nx = Math.min(a.x, b.x);
	var ny = Math.min(a.y, b.y);
	a.w = Math.max(a.x+a.w, b.x+b.w) - nx;
	a.h = Math.max(a.y+a.h, b.y+b.h) - ny;
	a.x = nx; a.y = ny;
	return(a);
};

/**generates a minimally bounding rectangle for all rectangles in
 * array "nodes". If rect is set, it is modified into the MBR. Otherwise,
 * a new rectangle is generated and returned.
 * [ rectangle a ] = make_MBR(rectangle array nodes, rectangle rect)
 * @static function
 */
RTree.Rectangle.make_MBR = function(nodes, rect) {
	if(nodes.length < 1)
		return({x:0, y:0, w:0, h:0});
		//throw "make_MBR: nodes must contain at least one rectangle!";
	if(!rect)
		rect = {x:nodes[0].x, y:nodes[0].y, w:nodes[0].w, h:nodes[0].h};
	else
		rect.x = nodes[0].x; rect.y = nodes[0].y; rect.w = nodes[0].w; rect.h = nodes[0].h;

	for(var i = nodes.length-1; i>0; i--)
		RTree.Rectangle.expand_rectangle(rect, nodes[i]);

	return(rect);
};
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

function sha1() {

    /*
     * Configurable variables. You may need to tweak these to be compatible with
     * the server-side, but the defaults work in most cases.
     */
    var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
    var b64pad  = "="; /* base-64 pad character. "=" for strict RFC compliance   */
    var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

    /*
     * These are the functions you'll usually want to call
     * They take string arguments and return either hex or base-64 encoded strings
     */
    function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}
    function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}
    function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}
    function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}
    function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}
    function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

    /*
     * Perform a simple self-test to see if the VM is working
     */
    function sha1_vm_test() {
      return hex_sha1("abc") == "a9993e364706816aba3e25717850c26c9cd0d89d";
    }

    /*
     * Calculate the SHA-1 of an array of big-endian words, and a bit length
     */
    function core_sha1(x, len) {
      /* append padding */
      x[len >> 5] |= 0x80 << (24 - len % 32);
      x[((len + 64 >> 9) << 4) + 15] = len;

      var w = Array(80);
      var a =  1732584193;
      var b = -271733879;
      var c = -1732584194;
      var d =  271733878;
      var e = -1009589776;

      for(var i = 0; i < x.length; i += 16) {
        var olda = a;
        var oldb = b;
        var oldc = c;
        var oldd = d;
        var olde = e;

        for(var j = 0; j < 80; j++) {
          if(j < 16) w[j] = x[i + j];
          else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
          var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                           safe_add(safe_add(e, w[j]), sha1_kt(j)));
          e = d;
          d = c;
          c = rol(b, 30);
          b = a;
          a = t;
        }

        a = safe_add(a, olda);
        b = safe_add(b, oldb);
        c = safe_add(c, oldc);
        d = safe_add(d, oldd);
        e = safe_add(e, olde);
      }
      return Array(a, b, c, d, e);

    }

    /*
     * Perform the appropriate triplet combination function for the current
     * iteration
     */
    function sha1_ft(t, b, c, d) {
      if(t < 20) return (b & c) | ((~b) & d);
      if(t < 40) return b ^ c ^ d;
      if(t < 60) return (b & c) | (b & d) | (c & d);
      return b ^ c ^ d;
    }

    /*
     * Determine the appropriate additive constant for the current iteration
     */
    function sha1_kt(t) {
      return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
             (t < 60) ? -1894007588 : -899497514;
    }

    /*
     * Calculate the HMAC-SHA1 of a key and some data
     */
    function core_hmac_sha1(key, data) {
      var bkey = str2binb(key);
      if(bkey.length > 16) bkey = core_sha1(bkey, key.length * chrsz);

      var ipad = Array(16), opad = Array(16);
      for(var i = 0; i < 16; i++) {
        ipad[i] = bkey[i] ^ 0x36363636;
        opad[i] = bkey[i] ^ 0x5C5C5C5C;
      }

      var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
      return core_sha1(opad.concat(hash), 512 + 160);
    }

    /*
     * Add integers, wrapping at 2^32. This uses 16-bit operations internally
     * to work around bugs in some JS interpreters.
     */
    function safe_add(x, y) {
      var lsw = (x & 0xFFFF) + (y & 0xFFFF);
      var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
      return (msw << 16) | (lsw & 0xFFFF);
    }

    /*
     * Bitwise rotate a 32-bit number to the left.
     */
    function rol(num, cnt) {
      return (num << cnt) | (num >>> (32 - cnt));
    }

    /*
     * Convert an 8-bit or 16-bit string to an array of big-endian words
     * In 8-bit function, characters >255 have their hi-byte silently ignored.
     */
    function str2binb(str) {
      var bin = Array();
      var mask = (1 << chrsz) - 1;
      for(var i = 0; i < str.length * chrsz; i += chrsz)
        bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (32 - chrsz - i%32);
      return bin;
    }

    /*
     * Convert an array of big-endian words to a string
     */
    function binb2str(bin) {
      var str = "";
      var mask = (1 << chrsz) - 1;
      for(var i = 0; i < bin.length * 32; i += chrsz)
        str += String.fromCharCode((bin[i>>5] >>> (32 - chrsz - i%32)) & mask);
      return str;
    }

    /*
     * Convert an array of big-endian words to a hex string.
     */
    function binb2hex(binarray) {
      var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
      var str = "";
      for(var i = 0; i < binarray.length * 4; i++) {
        str += hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8+4)) & 0xF) +
               hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8  )) & 0xF);
      }
      return str;
    }

    /*
     * Convert an array of big-endian words to a base-64 string
     */
    function binb2b64(binarray) {
      var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var str = "";
      for(var i = 0; i < binarray.length * 4; i += 3) {
        var triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16)
                    | (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 )
                    |  ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);
        for(var j = 0; j < 4; j++) {
          if(i * 8 + j * 6 > binarray.length * 32) str += b64pad;
          else str += tab.charAt((triplet >> 6*(3-j)) & 0x3F);
        }
      }
      return str;
    }

    return { b64_hmac_sha1: b64_hmac_sha1 };
}
(function () {
'use strict';
window.iD = function () {
    locale
        .current('en')
        .current(iD.detect().locale);

    var context = {},
        storage;

    // https://github.com/systemed/iD/issues/772
    // http://mathiasbynens.be/notes/localstorage-pattern#comment-9
    try { storage = localStorage; } catch (e) {}
    storage = storage || {};

    context.storage = function(k, v) {
        if (arguments.length === 1) return storage[k];
        else if (v === null) delete storage[k];
        else storage[k] = v;
    };

    var history = iD.History(context),
        dispatch = d3.dispatch('enter', 'exit'),
        mode,
        container,
        ui = iD.ui(context),
        map = iD.Map(context);

    // the connection requires .storage() to be available on calling.
    var connection = iD.Connection(context)
        .keys(iD.data.keys);

    connection.on('load.context', function loadContext(err, result) {
        history.merge(result);
    });

    /* Straight accessors. Avoid using these if you can. */
    context.ui = function() { return ui; };
    context.connection = function() { return connection; };
    context.history = function() { return history; };
    context.map = function() { return map; };

    /* History */
    context.graph = history.graph;
    context.perform = history.perform;
    context.replace = history.replace;
    context.pop = history.pop;
    context.undo = history.undo;
    context.redo = history.redo;
    context.changes = history.changes;
    context.intersects = history.intersects;

    /* Graph */
    context.entity = function(id) {
        return history.graph().entity(id);
    };

    context.geometry = function(id) {
        return context.entity(id).geometry(history.graph());
    };

    /* Modes */
    context.enter = function(newMode) {
        if (mode) {
            mode.exit();
            dispatch.exit(mode);
        }

        mode = newMode;
        mode.enter();
        dispatch.enter(mode);
    };

    context.mode = function() {
        return mode;
    };

    context.selection = function() {
        if (mode.id === 'select') {
            return mode.selection();
        } else {
            return [];
        }
    };

    /* Behaviors */
    context.install = function(behavior) {
        context.surface().call(behavior);
    };

    context.uninstall = function(behavior) {
        context.surface().call(behavior.off);
    };

    /* Map */
    context.layers = function() { return map.layers; };
    context.background = function() { return map.layers[0]; };
    context.surface = function() { return map.surface; };
    context.projection = map.projection;
    context.tail = map.tail;
    context.redraw = map.redraw;
    context.pan = map.pan;
    context.zoomIn = map.zoomIn;
    context.zoomOut = map.zoomOut;

    /* Background */
    var backgroundSources = iD.data.imagery.map(function(source) {
        if (source.sourcetag === 'Bing') {
            return iD.BackgroundSource.Bing(source, context.background().dispatch);
        } else {
            return iD.BackgroundSource.template(source);
        }
    });
    backgroundSources.push(iD.BackgroundSource.Custom);

    context.backgroundSources = function() {
        return backgroundSources;
    };

    /* Presets */
    var presets = iD.presets(context)
        .load(iD.data.presets);

    context.presets = function() {
        return presets;
    };

    context.container = function(_) {
        if (!arguments.length) return container;
        container = _;
        return context;
    };

    var q = iD.util.stringQs(location.hash.substring(1)), detected = false;
    if (q.layer) {
        context.layers()[0]
           .source(_.find(backgroundSources, function(l) {
               if (l.data.sourcetag === q.layer) {
                   detected = true;
                   return true;
               }
           }));
    }

    if (!detected) {
        context.background()
            .source(_.find(backgroundSources, function(l) {
                return l.data.name === 'Bing aerial imagery';
            }));
    }

    return d3.rebind(context, dispatch, 'on');
};

iD.version = '0.0.0-alpha3';

iD.detect = function() {
    var browser = {};

    var ua = navigator.userAgent,
        msie = new RegExp("MSIE ([0-9]{1,}[\\.0-9]{0,})");

    if (msie.exec(ua) !== null) {
        var rv = parseFloat(RegExp.$1);
        browser.support = !(rv && rv < 9);
    } else {
        browser.support = true;
    }

    // Added due to incomplete svg style support. See #715
    browser.opera = ua.indexOf('Opera') >= 0;

    browser.locale = navigator.language;

    browser.filedrop = (window.FileReader && 'ondrop' in window);

    function nav(x) {
        return navigator.userAgent.indexOf(x) !== -1;
    }

    if (nav('Win')) browser.os = 'win';
    else if (nav('Mac')) browser.os = 'mac';
    else if (nav('X11')) browser.os = 'linux';
    else if (nav('Linux')) browser.os = 'linux';
    else browser.os = 'win';

    return browser;
};
iD.Connection = function(context) {

    var event = d3.dispatch('auth', 'loading', 'load', 'loaded'),
        url = 'http://localhost:3000',
        connection = {},
        user = {},
        keys,
        inflight = {},
        loadedTiles = {},
        oauth = iD.OAuth(context).url(url),
        ndStr = 'nd',
        tagStr = 'tag',
        memberStr = 'member',
        nodeStr = 'node',
        wayStr = 'way',
        relationStr = 'relation';

    connection.changesetUrl = function(changesetId) {
        return url + '/browse/changeset/' + changesetId;
    };

    connection.loadFromURL = function(url, callback) {
        function done(dom) {
            return callback(null, parse(dom));
        }
        return d3.xml(url).get().on('load', done);
    };

    function getNodes(obj) {
        var elems = obj.getElementsByTagName(ndStr),
            nodes = new Array(elems.length);
        for (var i = 0, l = elems.length; i < l; i++) {
            nodes[i] = 'n' + elems[i].attributes.ref.nodeValue;
        }
        return nodes;
    }

    function getTags(obj) {
        var elems = obj.getElementsByTagName(tagStr),
            tags = {};
        for (var i = 0, l = elems.length; i < l; i++) {
            var attrs = elems[i].attributes;
            tags[attrs.k.nodeValue] = attrs.v.nodeValue;
        }
        return tags;
    }

    function getMembers(obj) {
        var elems = obj.getElementsByTagName(memberStr),
            members = new Array(elems.length);
        for (var i = 0, l = elems.length; i < l; i++) {
            var attrs = elems[i].attributes;
            members[i] = {
                id: attrs.type.nodeValue[0] + attrs.ref.nodeValue,
                type: attrs.type.nodeValue,
                role: attrs.role.nodeValue
            };
        }
        return members;
    }

    var parsers = {
        node: function nodeData(obj) {
            var attrs = obj.attributes;
            return new iD.Node({
                id: iD.Entity.id.fromOSM(nodeStr, attrs.id.nodeValue),
                loc: [parseFloat(attrs.lon.nodeValue), parseFloat(attrs.lat.nodeValue)],
                version: attrs.version.nodeValue,
                changeset: attrs.changeset.nodeValue,
                user: attrs.user && attrs.user.nodeValue,
                uid: attrs.uid && attrs.uid.nodeValue,
                visible: attrs.visible.nodeValue,
                timestamp: attrs.timestamp.nodeValue,
                tags: getTags(obj)
            });
        },

        way: function wayData(obj) {
            var attrs = obj.attributes;
            return new iD.Way({
                id: iD.Entity.id.fromOSM(wayStr, attrs.id.nodeValue),
                version: attrs.version.nodeValue,
                changeset: attrs.changeset.nodeValue,
                user: attrs.user && attrs.user.nodeValue,
                uid: attrs.uid && attrs.uid.nodeValue,
                visible: attrs.visible.nodeValue,
                timestamp: attrs.timestamp.nodeValue,
                tags: getTags(obj),
                nodes: getNodes(obj)
            });
        },

        relation: function relationData(obj) {
            var attrs = obj.attributes;
            return new iD.Relation({
                id: iD.Entity.id.fromOSM(relationStr, attrs.id.nodeValue),
                version: attrs.version.nodeValue,
                changeset: attrs.changeset.nodeValue,
                user: attrs.user && attrs.user.nodeValue,
                uid: attrs.uid && attrs.uid.nodeValue,
                visible: attrs.visible.nodeValue,
                timestamp: attrs.timestamp.nodeValue,
                tags: getTags(obj),
                members: getMembers(obj)
            });
        }
    };

    function parse(dom) {
        if (!dom || !dom.childNodes) return new Error('Bad request');

        var root = dom.childNodes[0],
            children = root.childNodes,
            entities = {};

        var i, o, l;
        for (i = 0, l = children.length; i < l; i++) {
            var child = children[i],
                parser = parsers[child.nodeName];
            if (parser) {
                o = parser(child);
                entities[o.id] = o;
            }
        }

        return entities;
    }

    connection.authenticated = function() {
        return oauth.authenticated();
    };

    // Generate Changeset XML. Returns a string.
    connection.changesetJXON = function(tags) {
        return {
            osm: {
                changeset: {
                    tag: _.map(tags, function(value, key) {
                        return { '@k': key, '@v': value };
                    }),
                    '@version': 0.3,
                    '@generator': 'iD'
                }
            }
        };
    };

    // Generate [osmChange](http://wiki.openstreetmap.org/wiki/OsmChange)
    // XML. Returns a string.
    connection.osmChangeJXON = function(userid, changeset_id, changes) {
        function nest(x, order) {
            var groups = {};
            for (var i = 0; i < x.length; i++) {
                var tagName = Object.keys(x[i])[0];
                if (!groups[tagName]) groups[tagName] = [];
                groups[tagName].push(x[i][tagName]);
            }
            var ordered = {};
            order.forEach(function(o) {
                if (groups[o]) ordered[o] = groups[o];
            });
            return ordered;
        }

        function rep(entity) {
            return entity.asJXON(changeset_id);
        }

        return {
            osmChange: {
                '@version': 0.3,
                '@generator': 'iD',
                'create': nest(changes.created.map(rep), ['node', 'way', 'relation']),
                'modify': nest(changes.modified.map(rep), ['node', 'way', 'relation']),
                'delete': _.extend(nest(changes.deleted.map(rep), ['relation', 'way', 'node']), {'@if-unused': true})
            }
        };
    };

    connection.putChangeset = function(changes, comment, imagery_used, callback) {
        oauth.xhr({
                method: 'PUT',
                path: '/api/0.6/changeset/create',
                options: { header: { 'Content-Type': 'text/xml' } },
                content: JXON.stringify(connection.changesetJXON({
                    imagery_used: imagery_used.join(';'),
                    comment: comment,
                    created_by: 'iD ' + iD.version
                }))
            }, function(err, changeset_id) {
                if (err) return callback(err);
                oauth.xhr({
                    method: 'POST',
                    path: '/api/0.6/changeset/' + changeset_id + '/upload',
                    options: { header: { 'Content-Type': 'text/xml' } },
                    content: JXON.stringify(connection.osmChangeJXON(user.id, changeset_id, changes))
                }, function(err) {
                    if (err) return callback(err);
                    oauth.xhr({
                        method: 'PUT',
                        path: '/api/0.6/changeset/' + changeset_id + '/close'
                    }, function(err) {
                        callback(err, changeset_id);
                    });
                });
            });
    };

    connection.userDetails = function(callback) {
        function done(err, user_details) {
            if (err) return callback(err);
            var u = user_details.getElementsByTagName('user')[0],
                img = u.getElementsByTagName('img'),
                image_url = '';
            if (img && img[0].getAttribute('href')) {
                image_url = img[0].getAttribute('href');
            }
            callback(undefined, connection.user({
                display_name: u.attributes.display_name.nodeValue,
                image_url: image_url,
                id: u.attributes.id.nodeValue
            }).user());
        }
        oauth.xhr({ method: 'GET', path: '/api/0.6/user/details' }, done);
    };

    function abortRequest(i) { i.abort(); }

    connection.loadTiles = function(projection, dimensions) {
        var scaleExtent = [16, 16],
            s = projection.scale(),
            tiles = d3.geo.tile()
                .scaleExtent(scaleExtent)
                .scale(s)
                .size(dimensions)
                .translate(projection.translate())(),
            z = Math.max(Math.log(s) / Math.log(2) - 8, 0),
            rz = Math.max(scaleExtent[0], Math.min(scaleExtent[1], Math.floor(z))),
            ts = 256 * Math.pow(2, z - rz),
            tile_origin = [
                s / 2 - projection.translate()[0],
                s / 2 - projection.translate()[1]];

        function bboxUrl(tile) {
            var x = (tile[0] * ts) - tile_origin[0];
            var y = (tile[1] * ts) - tile_origin[1];
            var b = [
                projection.invert([x, y]),
                projection.invert([x + ts, y + ts])];

            return url + '/api/0.6/map?bbox=' + [b[0][0], b[1][1], b[1][0], b[0][1]];
        }

        _.filter(inflight, function(v, i) {
            var wanted = _.find(tiles, function(tile) {
                return i === tile.toString();
            });
            if (!wanted) delete inflight[i];
            return !wanted;
        }).map(abortRequest);

        tiles.forEach(function(tile) {
            var id = tile.toString();

            if (loadedTiles[id] || inflight[id]) return;

            if (_.isEmpty(inflight)) {
                event.loading();
            }

            inflight[id] = connection.loadFromURL(bboxUrl(tile), function(err, parsed) {
                loadedTiles[id] = true;
                delete inflight[id];

                event.load(err, parsed);

                if (_.isEmpty(inflight)) {
                    event.loaded();
                }
            });
        });
    };

    connection.userUrl = function(username) {
        return url + "/user/" + username;
    };

    connection.url = function(_) {
        if (!arguments.length) return url;
        url = _;
        oauth.url(_);
        event.auth();
        connection.flush();
        return connection;
    };

    connection.user = function(_) {
        if (!arguments.length) return user;
        user = _;
        return connection;
    };

    connection.flush = function() {
        _.forEach(inflight, abortRequest);
        loadedTiles = {};
        inflight = {};
        return connection;
    };

    connection.logout = function() {
        oauth.logout();
        event.auth();
        return connection;
    };

    connection.keys = function(_) {
        if (!arguments.length) return keys;
        keys = _;
        oauth.keys(keys);
        return connection;
    };

    connection.authenticate = function(callback) {
        function done(err, res) {
            event.auth();
            if (callback) callback(err, res);
        }
        return oauth.authenticate(done);
    };

    return d3.rebind(connection, event, 'on');
};
iD.OAuth = function(context) {
    var baseurl = 'http://localhost:3000',
        o = {},
        keys,
        oauth = {},
        oauth_secret;

    function timenonce(o) {
        o.oauth_timestamp = ohauth.timestamp();
        o.oauth_nonce = ohauth.nonce();
        return o;
    }

    // token getter/setter, namespaced to the current `apibase` value.
    function token() {
        return context.storage.apply(context, arguments);
    }

    if (token('oauth_token')) {
        o.oauth_token = token('oauth_token');
    }

    oauth.authenticated = function() {
        return token('oauth_token') && token('oauth_token_secret');
    };

    oauth.logout = function() {
        token('oauth_token', '');
        token('oauth_token_secret', '');
        token('oauth_request_token_secret', '');
        return oauth;
    };

    oauth.xhr = function(options, callback) {
        if (token('oauth_token')) {
            o.oauth_token = token('oauth_token');
        }
        o = timenonce(o);
        var url = baseurl + options.path;
        var oauth_token_secret = token('oauth_token_secret');
        o.oauth_signature = ohauth.signature(oauth_secret, oauth_token_secret,
            ohauth.baseString(options.method, url, o));
        function done(err, xhr) {
            if (err) return callback(err);
            if (xhr.responseXML) return callback(err, xhr.responseXML);
            else return callback(err, xhr.response);
        }
        ohauth.xhr(options.method,
            url, o, options.content, options.options, done);
    };

    oauth.authenticate = function(callback) {
        if (oauth.authenticated()) return callback();

        oauth.logout();

        setAuth();
        o = timenonce(o);

        var url = baseurl + '/oauth/request_token';
        o.oauth_signature = ohauth.signature(oauth_secret, '',
            ohauth.baseString('POST', url, o));

        var l = iD.ui.loading(context.container(), 'contacting openstreetmap...');

        // it would make more sense to have this code within the callback
        // to oauth.xhr below. however, it needs to be directly within a
        // browser event handler in order to open a popup without it being
        // blocked.
        var w = 600, h = 550,
            settings = [
                ['width', w], ['height', h],
                ['left', screen.width / 2 - w / 2],
                ['top', screen.height / 2 - h / 2]].map(function(x) {
                    return x.join('=');
                }).join(','),
            popup = window.open("about:blank", 'oauth_window', settings);

        window.authComplete = function(token) {
            var oauth_token = ohauth.stringQs(token);
            get_access_token(oauth_token);
            delete window.authComplete;
        };

        function reqTokenDone(err, xhr) {
            if (err) callback(err);
            l.remove();

            var resp = ohauth.stringQs(xhr.response);
            token('oauth_request_token_secret', resp.oauth_token_secret);

            popup.location = baseurl + '/oauth/authorize?' + ohauth.qsString({
                oauth_token: resp.oauth_token,
                oauth_callback: location.href.replace('index.html', '')
                    .replace(/#.+/, '') + 'land.html'
            });
        }

        ohauth.xhr('POST', url, o, null, {}, reqTokenDone);

        function get_access_token(oauth_token) {
            var url = baseurl + '/oauth/access_token';
            o = timenonce(o);

            o.oauth_token = oauth_token.oauth_token;
            var request_token_secret = token('oauth_request_token_secret');
            o.oauth_signature = ohauth.signature(oauth_secret, request_token_secret,
                ohauth.baseString('POST', url, o));
            var l = iD.ui.loading(context.container(), 'contacting openstreetmap...');

            function accessTokenDone(err, xhr) {
                if (err) callback(err);
                l.remove();
                var access_token = ohauth.stringQs(xhr.response);
                token('oauth_token', access_token.oauth_token);
                token('oauth_token_secret', access_token.oauth_token_secret);
                callback();
            }

            ohauth.xhr('POST', url, o, null, {}, accessTokenDone);
        }

    };

    function setAuth() {
        if (baseurl && keys && keys[baseurl]) {
            o = _.assign({}, _.omit(keys[baseurl], 'oauth_secret'));
            oauth_secret = keys[baseurl].oauth_secret;
        }
    }

    oauth.url = function(_) {
        if (!arguments.length) return baseurl;
        baseurl = _;
        setAuth();
        return oauth;
    };

    oauth.keys = function(_) {
        if (!arguments.length) return keys;
        keys = _;
        setAuth();
        return oauth;
    };

    return oauth;
};
iD.taginfo = function() {
    var taginfo = {},
        endpoint = 'http://localhost:3000/api/4/',
        tag_sorts = {
            point: 'count_nodes',
            vertex: 'count_nodes',
            area: 'count_ways',
            line: 'count_ways'
        },
        tag_filters = {
            point: 'nodes',
            vertex: 'nodes',
            area: 'ways',
            line: 'ways'
        };

    var cache = this.cache = {};

    function sets(parameters, n, o) {
        if (parameters.geometry && o[parameters.geometry]) {
            parameters[n] = o[parameters.geometry];
        }
        return parameters;
    }

    function setFilter(parameters) {
        return sets(parameters, 'filter', tag_filters);
    }

    function setSort(parameters) {
        return sets(parameters, 'sortname', tag_sorts);
    }

    function clean(parameters) {
        return _.omit(parameters, 'geometry', 'debounce');
    }

    function shorten(parameters) {
        if (!parameters.query) {
            delete parameters.query;
        } else {
            parameters.query = parameters.query.slice(0, 3);
        }
        return parameters;
    }

    function popularKeys(parameters) {
        var pop_field = 'count_all';
        if (parameters.filter) pop_field = 'count_' + parameters.filter;
        return function(d) { return parseFloat(d[pop_field]) > 10000; };
    }

    function popularValues() {
        return function(d) { return parseFloat(d.fraction) > 0.01; };
    }

    function valKey(d) { return { value: d.key }; }

    function valKeyDescription(d) {
        return {
            value: d.value,
            title: d.description
        };
    }

    var debounced = _.debounce(d3.json, 100, true);

    function request(url, debounce, callback) {
        if (cache[url]) {
            callback(null, cache[url]);
        } else if (debounce) {
            debounced(url, done);
        } else {
            d3.json(url, done);
        }

        function done(err, data) {
            if (!err) cache[url] = data;
            callback(err, data);
        }
    }

    taginfo.keys = function(parameters, callback) {
        var debounce = parameters.debounce;
        parameters = clean(shorten(setSort(setFilter(parameters))));
        request(endpoint + 'keys/all?' +
            iD.util.qsString(_.extend({
                rp: 10,
                sortname: 'count_all',
                sortorder: 'desc',
                page: 1
            }, parameters)), debounce, function(err, d) {
                if (err) return callback(err);
                callback(null, d.data.filter(popularKeys(parameters)).map(valKey));
            });
    };

    taginfo.values = function(parameters, callback) {
        var debounce = parameters.debounce;
        parameters = clean(shorten(setSort(setFilter(parameters))));
        request(endpoint + 'key/values?' +
            iD.util.qsString(_.extend({
                rp: 20,
                sortname: 'count_all',
                sortorder: 'desc',
                page: 1
            }, parameters)), debounce, function(err, d) {
                if (err) return callback(err);
                callback(null, d.data.filter(popularValues()).map(valKeyDescription), parameters);
            });
    };

    taginfo.docs = function(parameters, callback) {
        var debounce = parameters.debounce;
        parameters = clean(setSort(parameters));
        request(endpoint + (parameters.value ? 'tag/wiki_pages?' : 'key/wiki_pages?') +
            iD.util.qsString(parameters), debounce, callback);
    };

    taginfo.endpoint = function(_) {
        if (!arguments.length) return endpoint;
        endpoint = _;
        return taginfo;
    };

    return taginfo;
};
iD.data = {
    "deprecated": [
        {
            "old": {
                "barrier": "wire_fence"
            },
            "replace": {
                "barrier": "fence",
                "fence_type": "chain"
            }
        },
        {
            "old": {
                "barrier": "wood_fence"
            },
            "replace": {
                "barrier": "fence",
                "fence_type": "wood"
            }
        },
        {
            "old": {
                "highway": "ford"
            },
            "replace": {
                "ford": "yes"
            }
        },
        {
            "old": {
                "highway": "stile"
            },
            "replace": {
                "barrier": "stile"
            }
        },
        {
            "old": {
                "highway": "incline"
            },
            "replace": {
                "highway": "road",
                "incline": "up"
            }
        },
        {
            "old": {
                "highway": "incline_steep"
            },
            "replace": {
                "highway": "road",
                "incline": "up"
            }
        },
        {
            "old": {
                "highway": "unsurfaced"
            },
            "replace": {
                "highway": "road",
                "incline": "unpaved"
            }
        },
        {
            "old": {
                "landuse": "wood"
            },
            "replace": {
                "landuse": "forest",
                "natural": "wood"
            }
        },
        {
            "old": {
                "natural": "marsh"
            },
            "replace": {
                "natural": "wetland",
                "wetland": "marsh"
            }
        },
        {
            "old": {
                "shop": "organic"
            },
            "replace": {
                "shop": "supermarket",
                "organic": "only"
            }
        },
        {
            "old": {
                "power_source": "*"
            },
            "replace": {
                "generator:source": "$1"
            }
        },
        {
            "old": {
                "power_rating": "*"
            },
            "replace": {
                "generator:output": "$1"
            }
        }
    ],
    "discarded": [
        "created_by",
        "tiger:upload_uuid",
        "tiger:tlid",
        "tiger:source",
        "tiger:separated",
        "geobase:datasetName",
        "geobase:uuid",
        "sub_sea:type",
        "odbl",
        "odbl:note",
        "yh:LINE_NAME",
        "yh:LINE_NUM",
        "yh:STRUCTURE",
        "yh:TOTYUMONO",
        "yh:TYPE",
        "yh:WIDTH_RANK"
    ],
    "keys": {
        "http://api.openfloorplan.org": {
            "oauth_consumer_key": "zwQZFivccHkLs3a8Rq5CoS412fE5aPCXDw9DZj7R",
            "oauth_secret": "aMnOOCwExO2XYtRVWJ1bI9QOdqh1cay2UgpbhA6p",
            "oauth_signature_method": "HMAC-SHA1"
        },
        "http://www.openfloorplan.org": {
            "oauth_consumer_key": "5A043yRSEugj4DJ5TljuapfnrflWDte8jTOcWLlT",
            "oauth_secret": "aB3jKq1TRsCOUrfOIZ6oQMEDmv2ptV76PA54NGLL",
            "oauth_signature_method": "HMAC-SHA1"
        }
    },
    "imagery": [
        {
            "name": "Bing aerial imagery",
            "template": "http://ecn.t{t}.tiles.virtualearth.net/tiles/a{u}.jpeg?g=587&mkt=en-gb&n=z",
            "description": "Satellite imagery.",
            "scaleExtent": [
                0,
                20
            ],
            "subdomains": [
                "0",
                "1",
                "2",
                "3"
            ],
            "default": "yes",
            "sourcetag": "Bing",
            "logo": "bing_maps.png",
            "logo_url": "http://www.bing.com/maps",
            "terms_url": "http://opengeodata.org/microsoft-imagery-details"
        },
        {
            "name": "MapBox Satellite",
            "template": "http://{t}.tiles.mapbox.com/v3/openstreetmap.map-4wvf9l0l/{z}/{x}/{y}.png",
            "description": "Satellite and aerial imagery.",
            "scaleExtent": [
                0,
                16
            ],
            "subdomains": [
                "a",
                "b",
                "c"
            ],
            "terms_url": "http://mapbox.com/tos/"
        },
        {
            "name": "OpenStreetMap",
            "template": "http://{t}.tile.openstreetmap.org/{z}/{x}/{y}.png",
            "description": "The default OpenStreetMap layer.",
            "scaleExtent": [
                0,
                18
            ],
            "subdomains": [
                "a",
                "b",
                "c"
            ]
        },
        {
            "name": " TIGER 2012 Roads Overlay",
            "template": "http://{t}.tile.openstreetmap.us/tiger2012_roads_expanded/{z}/{x}/{y}.png",
            "subdomains": [
                "a",
                "b",
                "c"
            ],
            "extent": [
                [
                    -124.81,
                    24.055
                ],
                [
                    -66.865,
                    49.386
                ]
            ]
        },
        {
            "name": " TIGER 2012 Roads Overlay",
            "template": "http://{t}.tile.openstreetmap.us/tiger2012_roads_expanded/{z}/{x}/{y}.png",
            "subdomains": [
                "a",
                "b",
                "c"
            ],
            "extent": [
                [
                    -179.754,
                    50.858
                ],
                [
                    -129.899,
                    71.463
                ]
            ]
        },
        {
            "name": " TIGER 2012 Roads Overlay",
            "template": "http://{t}.tile.openstreetmap.us/tiger2012_roads_expanded/{z}/{x}/{y}.png",
            "subdomains": [
                "a",
                "b",
                "c"
            ],
            "extent": [
                [
                    -174.46,
                    18.702
                ],
                [
                    -154.516,
                    26.501
                ]
            ]
        },
        {
            "name": " USGS Topographic Maps",
            "template": "http://{t}.tile.openstreetmap.us/usgs_scanned_topos/{z}/{x}/{y}.png",
            "subdomains": [
                "a",
                "b",
                "c"
            ],
            "extent": [
                [
                    -125.991,
                    24.005
                ],
                [
                    -65.988,
                    50.009
                ]
            ]
        },
        {
            "name": " USGS Topographic Maps",
            "template": "http://{t}.tile.openstreetmap.us/usgs_scanned_topos/{z}/{x}/{y}.png",
            "subdomains": [
                "a",
                "b",
                "c"
            ],
            "extent": [
                [
                    -160.579,
                    18.902
                ],
                [
                    -154.793,
                    22.508
                ]
            ]
        },
        {
            "name": " USGS Topographic Maps",
            "template": "http://{t}.tile.openstreetmap.us/usgs_scanned_topos/{z}/{x}/{y}.png",
            "subdomains": [
                "a",
                "b",
                "c"
            ],
            "extent": [
                [
                    -178.001,
                    51.255
                ],
                [
                    -130.004,
                    71.999
                ]
            ]
        },
        {
            "name": " USGS Large Scale Aerial Imagery",
            "template": "http://{t}.tile.openstreetmap.us/usgs_large_scale/{z}/{x}/{y}.jpg",
            "subdomains": [
                "a",
                "b",
                "c"
            ],
            "extent": [
                [
                    -124.819,
                    24.496
                ],
                [
                    -66.931,
                    49.443
                ]
            ]
        },
        {
            "name": "British Columbia bc_mosaic",
            "template": "http://{t}.imagery.paulnorman.ca/tiles/bc_mosaic/{z}/{x}/{y}.png",
            "subdomains": [
                "a",
                "b",
                "c",
                "d"
            ],
            "extent": [
                [
                    -123.441,
                    48.995
                ],
                [
                    -121.346,
                    50.426
                ]
            ],
            "sourcetag": "bc_mosaic",
            "terms_url": "http://imagery.paulnorman.ca/tiles/about.html"
        },
        {
            "name": "OS OpenData Streetview",
            "template": "http://os.openstreetmap.org/sv/{z}/{x}/{y}.png",
            "extent": [
                [
                    -8.72,
                    49.86
                ],
                [
                    1.84,
                    60.92
                ]
            ],
            "sourcetag": "OS_OpenData_StreetView"
        },
        {
            "name": "OS OpenData Locator",
            "template": "http://tiles.itoworld.com/os_locator/{z}/{x}/{y}.png",
            "extent": [
                [
                    -9,
                    49.8
                ],
                [
                    1.9,
                    61.1
                ]
            ],
            "sourcetag": "OS_OpenData_Locator"
        },
        {
            "name": "OS 1:25k historic (OSM)",
            "template": "http://ooc.openstreetmap.org/os1/{z}/{x}/{y}.jpg",
            "extent": [
                [
                    -9,
                    49.8
                ],
                [
                    1.9,
                    61.1
                ]
            ],
            "sourcetag": "OS 1:25k"
        },
        {
            "name": "OS 1:25k historic (NLS)",
            "template": "http://geo.nls.uk/mapdata2/os/25000/{z}/{x}/{y}.png",
            "extent": [
                [
                    -9,
                    49.8
                ],
                [
                    1.9,
                    61.1
                ]
            ],
            "sourcetag": "OS 1:25k",
            "logo": "icons/logo_nls70-nq8.png",
            "logo_url": "http://geo.nls.uk/maps/"
        },
        {
            "name": "OS 7th Series historic (OSM)",
            "template": "http://ooc.openstreetmap.org/os7/{z}/{x}/{y}.jpg",
            "extent": [
                [
                    -9,
                    49.8
                ],
                [
                    1.9,
                    61.1
                ]
            ],
            "sourcetag": "OS7"
        },
        {
            "name": "OS 7th Series historic (NLS)",
            "template": "http://geo.nls.uk/mapdata2/os/seventh/{z}/{x}/{y}.png",
            "extent": [
                [
                    -9,
                    49.8
                ],
                [
                    1.9,
                    61.1
                ]
            ],
            "sourcetag": "OS7",
            "logo": "icons/logo_nls70-nq8.png",
            "logo_url": "http://geo.nls.uk/maps/"
        },
        {
            "name": "OS New Popular Edition historic",
            "template": "http://ooc.openstreetmap.org/npe/{z}/{x}/{y}.png",
            "extent": [
                [
                    -5.8,
                    49.8
                ],
                [
                    1.9,
                    55.8
                ]
            ],
            "sourcetag": "NPE"
        },
        {
            "name": "OS Scottish Popular historic",
            "template": "http://ooc.openstreetmap.org/npescotland/tiles/{z}/{x}/{y}.jpg",
            "extent": [
                [
                    -7.8,
                    54.5
                ],
                [
                    -1.1,
                    61.1
                ]
            ],
            "sourcetag": "NPE"
        },
        {
            "name": "Surrey aerial",
            "template": "http://gravitystorm.dev.openstreetmap.org/surrey/{z}/{x}/{y}.png",
            "extent": [
                [
                    -0.856,
                    51.071
                ],
                [
                    0.062,
                    51.473
                ]
            ],
            "sourcetag": "Surrey aerial"
        },
        {
            "name": "Haiti - GeoEye Jan 13",
            "template": "http://gravitystorm.dev.openstreetmap.org/imagery/haiti/{z}/{x}/{y}.jpg",
            "extent": [
                [
                    -74.5,
                    17.95
                ],
                [
                    -71.58,
                    20.12
                ]
            ],
            "sourcetag": "Haiti GeoEye"
        },
        {
            "name": "Haiti - GeoEye Jan 13+",
            "template": "http://maps.nypl.org/tilecache/1/geoeye/{z}/{x}/{y}.jpg",
            "extent": [
                [
                    -74.5,
                    17.95
                ],
                [
                    -71.58,
                    20.12
                ]
            ],
            "sourcetag": "Haiti GeoEye"
        },
        {
            "name": "Haiti - DigitalGlobe",
            "template": "http://maps.nypl.org/tilecache/1/dg_crisis/{z}/{x}/{y}.jpg",
            "extent": [
                [
                    -74.5,
                    17.95
                ],
                [
                    -71.58,
                    20.12
                ]
            ],
            "sourcetag": "Haiti DigitalGlobe"
        },
        {
            "name": "Haiti - Street names",
            "template": "http://hypercube.telascience.org/tiles/1.0.0/haiti-city/{z}/{x}/{y}.jpg",
            "extent": [
                [
                    -74.5,
                    17.95
                ],
                [
                    -71.58,
                    20.12
                ]
            ],
            "sourcetag": "Haiti streetnames"
        },
        {
            "name": "NAIP",
            "template": "http://cube.telascience.org/tilecache/tilecache.py/NAIP_ALL/{z}/{x}/{y}.png",
            "description": "National Agriculture Imagery Program",
            "extent": [
                [
                    -125.8,
                    24.2
                ],
                [
                    -62.3,
                    49.5
                ]
            ],
            "sourcetag": "NAIP"
        },
        {
            "name": "NAIP",
            "template": "http://cube.telascience.org/tilecache/tilecache.py/NAIP_ALL/{z}/{x}/{y}.png",
            "description": "National Agriculture Imagery Program",
            "extent": [
                [
                    -168.5,
                    55.3
                ],
                [
                    -140,
                    71.5
                ]
            ],
            "sourcetag": "NAIP"
        },
        {
            "name": "Ireland - NLS Historic Maps",
            "template": "http://geo.nls.uk/maps/ireland/gsgs4136/{z}/{x}/{y}.png",
            "extent": [
                [
                    -10.71,
                    51.32
                ],
                [
                    -5.37,
                    55.46
                ]
            ],
            "sourcetag": "NLS Historic Maps",
            "logo": "icons/logo_nls70-nq8.png",
            "logo_url": "http://geo.nls.uk/maps/"
        },
        {
            "name": "Denmark - Fugro Aerial Imagery",
            "template": "http://tile.openstreetmap.dk/fugro2005/{z}/{x}/{y}.jpg",
            "extent": [
                [
                    7.81,
                    54.44
                ],
                [
                    15.49,
                    57.86
                ]
            ],
            "sourcetag": "Fugro (2005)"
        },
        {
            "name": "Denmark - Stevns Kommune",
            "template": "http://tile.openstreetmap.dk/stevns/2009/{z}/{x}/{y}.jpg",
            "extent": [
                [
                    12.09144,
                    55.23403
                ],
                [
                    12.47712,
                    55.43647
                ]
            ],
            "sourcetag": "Stevns Kommune (2009)"
        },
        {
            "name": "Austria - geoimage.at",
            "template": "http://geoimage.openstreetmap.at/4d80de696cd562a63ce463a58a61488d/{z}/{x}/{y}.jpg",
            "extent": [
                [
                    9.36,
                    46.33
                ],
                [
                    17.28,
                    49.09
                ]
            ],
            "sourcetag": "geoimage.at"
        },
        {
            "name": "Russia - Kosmosnimki.ru IRS Satellite",
            "template": "http://irs.gis-lab.info/?layers=irs&request=GetTile&z={z}&x={x}&y={y}",
            "extent": [
                [
                    19.02,
                    40.96
                ],
                [
                    77.34,
                    70.48
                ]
            ],
            "sourcetag": "Kosmosnimki.ru IRS"
        },
        {
            "name": "Belarus - Kosmosnimki.ru SPOT4 Satellite",
            "template": "http://irs.gis-lab.info/?layers=spot&request=GetTile&z={z}&x={x}&y={y}",
            "extent": [
                [
                    23.16,
                    51.25
                ],
                [
                    32.83,
                    56.19
                ]
            ],
            "sourcetag": "Kosmosnimki.ru SPOT4"
        },
        {
            "name": "Australia - Geographic Reference Image",
            "template": "http://agri.openstreetmap.org/{z}/{x}/{y}.png",
            "extent": [
                [
                    96,
                    -44
                ],
                [
                    168,
                    -9
                ]
            ],
            "sourcetag": "AGRI"
        },
        {
            "name": "Switzerland - Canton Aargau - AGIS 25cm 2011",
            "template": "http://tiles.poole.ch/AGIS/OF2011/{z}/{x}/{y}.png",
            "extent": [
                [
                    7.69,
                    47.13
                ],
                [
                    8.48,
                    47.63
                ]
            ],
            "sourcetag": "AGIS OF2011"
        },
        {
            "name": "Switzerland - Canton Solothurn - SOGIS 2007",
            "template": "http://mapproxy.sosm.ch:8080/tiles/sogis2007/EPSG900913/{z}/{x}/{y}.png?origin=nw",
            "extent": [
                [
                    7.33,
                    47.06
                ],
                [
                    8.04,
                    47.5
                ]
            ],
            "sourcetag": "Orthofoto 2007 WMS Solothurn"
        },
        {
            "name": "Poland - Media-Lab fleet GPS masstracks",
            "template": "http://masstracks.media-lab.com.pl/{z}/{x}/{y}.png",
            "extent": [
                [
                    14,
                    48.9
                ],
                [
                    24.2,
                    55
                ]
            ],
            "sourcetag": "masstracks"
        },
        {
            "name": "South Africa - CD:NGI Aerial",
            "template": "http://{t}.aerial.openstreetmap.org.za/ngi-aerial/{z}/{x}/{y}.jpg",
            "subdomains": [
                "a",
                "b",
                "c"
            ],
            "extent": [
                [
                    17.64,
                    -34.95
                ],
                [
                    32.87,
                    -22.05
                ]
            ],
            "sourcetag": "ngi-aerial"
        }
    ],
    "docs": [
        {
            "html": "<p>This is an editor for <a href=\"http://www.openstreetmap.org/\">OpenStreetMap</a>, the\nfree and editable map of the world. You can use it to fix and update\ndata in your area, making an open-source and open-data map of the world\nbetter for everyone.</p>\n<p>Edits that you make on this map will be visible to everyone who uses\nOpenStreetMap. In order to make an edit, you&#39;ll need a\n<a href=\"https://www.openstreetmap.org/user/new\">free OpenStreetMap account</a>.</p>\n<p><a href=\"http://ideditor.com/\">iD Editor</a> is a collaborative project with <a href=\"https://github.com/systemed/iD\">source\ncode available on GitHub</a>.</p>\n",
            "title": "Help"
        },
        {
            "html": "<p>This editor is designed to work primarily online, and you&#39;re accessing\nit through a website right now.</p>\n<h2>Selecting Features</h2>\n<p>To select a map feature, like a road or point of interest, simply single-click\non it on the map. This will highlight the selected feature, show a panel of\ndetails, and also show a menu of things you can do with the feature.</p>\n<p>Multiple features can be selected by holding the &#39;Shift&#39; key, clicking,\nand dragging on the map. This will select all features within the box\nthat&#39;s drawn, and you can do certain &#39;batch operations&#39; on all features.</p>\n<h2>Saving Edits</h2>\n<p>When you create changes, like editing roads, buildings, and places, these are\nstored locally until you save them to the server. Don&#39;t worry if you make\na mistake - you can undo changes by clicking the undo button, and redo\nchanges by clicking the redo button.</p>\n<p>Click &#39;Save&#39; to finish a group of edits - for instance, if you&#39;ve completed\nan area of town and would like to start on a new area. You&#39;ll have a chance\nto review what you&#39;ve done, and the editor supplies helpful suggestions\nand warnings if something doesn&#39;t seem right about the changes.</p>\n<p>Clicking &#39;Save&#39; again, on the new dialog, will post the changes\nto <a href=\"http://www.openstreetmap.org/\">OpenStreetMap.org</a>, where they are visible\nto all other users and available for others to build and improve upon.</p>\n<p>If you can&#39;t finish your edits in one sitting, you can leave the editor\nwindow and come back (on the same browser and computer), and the\neditor application will offer to restore your work.</p>\n",
            "title": "Editing & Saving"
        },
        {
            "html": "<p>You can create, fix, and delete roads with this editor. Roads can be all\nkinds: paths, highways, trails, cycleways, and more - any often-crossed\nsegment should be mappable.</p>\n<h3>Selecting</h3>\n<p>Click on a road to select it. An outline should become visible, along\nwith a small tools menu on the map and a sidebar showing more information\nabout the road.</p>\n<h3>Modifying</h3>\n<p>Often you&#39;ll see roads that aren&#39;t aligned to the imagery behind them\nor a GPS track.</p>\n<p>First click on the road you want to change. This will highlight it and show\n&#39;control points along it&#39; that you can drag to better locations. If\nyou want to add new control points for more detail, double-click a part\nof the road without a point, and one will be added.</p>\n<p>If the road connects to another road, but doesn&#39;t properly connect on\nthe map, you can drag one of its control points onto the other road in\norder to join them. Having roads connect is important for the map\nand essential for providing driving directions.</p>\n<p>You can also click the &#39;Move&#39; tool or type <code>M</code> to move the entire road at\none time, and then click again to save that movement.</p>\n<h3>Deleting</h3>\n<p>If a road is entirely incorrect - you can see that it doesn&#39;t exist in satellite\nimagery and ideally have confirmed locally that it&#39;s not present - you can delete\nit, which removes it from the map. Be cautious when deleting features -\nlike any other edit, the results are seen by everyone and satellite imagery\nis often out of date, so the road could simply be newly built.</p>\n<p>You can delete a road by clicking on it to select it, then clicking the\ntrash can icon or pressing the &#39;Delete&#39; key.</p>\n<h3>Creating</h3>\n<p>Found somewhere there should be a road but there isn&#39;t? Click the &#39;Line&#39;\nicon in the top-left of the editor or press the key &#39;2&#39; to start drawing\na line.</p>\n<p>Click on the start of the road on the map to start drawing. If the road\nconnects to another road, first, click on the place where they connect.</p>\n<p>Then click on points along the road so that it follows the right path, according\nto satellite imagery or GPS. When you&#39;re done drawing the road, double-click\nor press &#39;Return&#39; or &#39;Enter&#39; on your keyboard.</p>\n",
            "title": "Roads"
        },
        {
            "html": "<p>GPS data is the most trusted source of data for OpenStreetMap. This editor\nsupports local traces - <code>.gpx</code> files on your local computer. You can collect\nthis kind of GPS trace with a number of smartphone applications as well as\npersonal GPS hardware.</p>\n<p>For information on how to perform a GPS survey, read\n<a href=\"http://learnosm.org/en/beginner/using-gps/\">Surveying with a GPS</a>.</p>\n<p>To use a GPX track for mapping, drag and drop the GPX file onto the map map\neditor. If it&#39;s recognized, it will be added to the map as a bright green\nline. Click on the &#39;Background Settings&#39; menu on the left side to enable,\ndisable, or zoom to this new GPX-powered layer.</p>\n<p>The GPX track isn&#39;t directly uploaded to OpenStreetMap - the best way to\nuse it is to draw on the map, using it as a guide for the new features that\nyou add.</p>\n",
            "title": "GPS"
        },
        {
            "html": "<p>Aerial imagery is an important resource for mapping. A combination of\nairplane flyovers, satellite views, and freely-compiled sources are available\nin the editor under the &#39;Background Settings&#39; menu on the left.</p>\n<p>By default a <a href=\"http://www.bing.com/maps/\">Bing Maps</a> satellite layer is\npresented in the editor, but as you pan and zoom the map to new geographical\nareas, new sources will become available. Some countries, like the United\nStates, France, and Denmark have very high-resolution, high-quality imagery\navailable for smaller geographical coverages.</p>\n<p>Imagery is sometimes offset from the map data because of a mistake on the\nimagery provider&#39;s side - so if you see many roads shifted from the background,\ndon&#39;t immediately go to move them all. You can set an offset for imagery\nby clicking &#39;Fix alignment&#39; at the bottom of the bottom of the Background\nSettings UI.</p>\n",
            "title": "Imagery"
        },
        {
            "html": "<p>Addresses are some of the most useful information for the map.</p>\n<p>Although addresses are often represented as parts of streets, in OpenStreetMap\nthey&#39;re recorded as attributes of buildings and places along streets.</p>\n<p>You can add address information to places mapped as building outlines as well\nas well as those mapped as single points. The optimal source of address\ndata is from an on-the-ground survey or personal knowledge - as with any\nother feature, copying from commercial sources like Google Maps is strictly\nforbidden.</p>\n",
            "title": "Addresses"
        },
        {
            "html": "<p>OpenStreetMap is the world&#39;s largest database of buildings. You can create\nand improve this database.</p>\n<h3>Selecting</h3>\n<p>You can select a building by clicking on its border. This will highlight the\nbuilding and open a small tools menu and a sidebar showing more information\nabout the building.</p>\n<h3>Modifying</h3>\n<p>Sometimes buildings are incorrectly placed or have incorrect tags.</p>\n<p>To move an entire building, select it, then click the &#39;Move&#39; tool. Move your\nmouse to shift the building, and click when it&#39;s correctly placed.</p>\n<p>To fix the specific shape of a building, click and drag the points that form\nits border into better places.</p>\n<h3>Creating</h3>\n<p>One of the main questions around adding buildings to the map is that\nOpenStreetMap records buildings both as shapes and points. The rule of thumb\nis to <em>map a building as a shape whenever possible</em>, and map companies, homes,\namenities, and other things that operate out of buildings as points placed\nwithin the building shape.</p>\n<p>Start drawing a building as a shape by clicking the &#39;Area&#39; button in the top\nleft of the interface, and end it either by pressing &#39;Return&#39; on your keyboard\nor clicking on the first point drawn to close the shape.</p>\n<h3>Deleting</h3>\n<p>If a building is entirely incorrect - you can see that it doesn&#39;t exist in satellite\nimagery and ideally have confirmed locally that it&#39;s not present - you can delete\nit, which removes it from the map. Be cautious when deleting features -\nlike any other edit, the results are seen by everyone and satellite imagery\nis often out of date, so the road could simply be newly built.</p>\n<p>You can delete a building by clicking on it to select it, then clicking the\ntrash can icon or pressing the &#39;Delete&#39; key.</p>\n",
            "title": "Buildings"
        }
    ],
    "presets": {
        "presets": {
            "aeroway": {
                "fields": [
                    "aeroway"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "line",
                    "area"
                ],
                "tags": {
                    "aeroway": "*"
                },
                "name": "Aeroway"
            },
            "aeroway/aerodrome": {
                "icon": "airport",
                "geometry": [
                    "point",
                    "area"
                ],
                "terms": [
                    "airplane",
                    "airport",
                    "aerodrome"
                ],
                "tags": {
                    "aeroway": "aerodrome"
                },
                "name": "Airport"
            },
            "aeroway/helipad": {
                "icon": "heliport",
                "geometry": [
                    "point",
                    "area"
                ],
                "terms": [
                    "helicopter",
                    "helipad",
                    "heliport"
                ],
                "tags": {
                    "aeroway": "helipad"
                },
                "name": "Helipad"
            },
            "amenity": {
                "fields": [
                    "amenity"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "amenity": "*"
                },
                "name": "Amenity"
            },
            "amenity/bank": {
                "icon": "bank",
                "fields": [
                    "atm",
                    "building_area",
                    "address"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "terms": [
                    "coffer",
                    "countinghouse",
                    "credit union",
                    "depository",
                    "exchequer",
                    "fund",
                    "hoard",
                    "investment firm",
                    "repository",
                    "reserve",
                    "reservoir",
                    "safe",
                    "savings",
                    "stock",
                    "stockpile",
                    "store",
                    "storehouse",
                    "thrift",
                    "treasury",
                    "trust company",
                    "vault"
                ],
                "tags": {
                    "amenity": "bank"
                },
                "name": "Bank"
            },
            "amenity/bar": {
                "icon": "bar",
                "fields": [
                    "building_area",
                    "address"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "amenity": "bar"
                },
                "terms": [],
                "name": "Bar"
            },
            "amenity/bench": {
                "geometry": [
                    "point",
                    "vertex",
                    "line"
                ],
                "tags": {
                    "amenity": "bench"
                },
                "name": "Bench"
            },
            "amenity/bicycle_parking": {
                "icon": "bicycle",
                "fields": [
                    "bicycle_parking",
                    "capacity",
                    "operator"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "amenity": "bicycle_parking"
                },
                "name": "Bicycle Parking"
            },
            "amenity/bicycle_rental": {
                "icon": "bicycle",
                "fields": [
                    "capacity",
                    "network",
                    "operator"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "amenity": "bicycle_rental"
                },
                "name": "Bicycle Rental"
            },
            "amenity/cafe": {
                "icon": "cafe",
                "fields": [
                    "cuisine",
                    "internet_access",
                    "building_area",
                    "address"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "terms": [
                    "coffee",
                    "tea",
                    "coffee shop"
                ],
                "tags": {
                    "amenity": "cafe"
                },
                "name": "Cafe"
            },
            "amenity/cinema": {
                "icon": "cinema",
                "fields": [
                    "building_area",
                    "address"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "terms": [
                    "big screen",
                    "bijou",
                    "cine",
                    "drive-in",
                    "film",
                    "flicks",
                    "motion pictures",
                    "movie house",
                    "movie theater",
                    "moving pictures",
                    "nabes",
                    "photoplay",
                    "picture show",
                    "pictures",
                    "playhouse",
                    "show",
                    "silver screen"
                ],
                "tags": {
                    "amenity": "cinema"
                },
                "name": "Cinema"
            },
            "amenity/courthouse": {
                "fields": [
                    "operator",
                    "building_area",
                    "address"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "amenity": "courthouse"
                },
                "name": "Courthouse"
            },
            "amenity/embassy": {
                "geometry": [
                    "area",
                    "point"
                ],
                "tags": {
                    "amenity": "embassy"
                },
                "fields": [
                    "country"
                ],
                "icon": "embassy",
                "name": "Embassy"
            },
            "amenity/fast_food": {
                "icon": "fast-food",
                "fields": [
                    "cuisine",
                    "building_area",
                    "address"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "amenity": "fast_food"
                },
                "terms": [],
                "name": "Fast Food"
            },
            "amenity/fire_station": {
                "icon": "fire-station",
                "fields": [
                    "operator",
                    "building_area",
                    "address"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "amenity": "fire_station"
                },
                "terms": [],
                "name": "Fire Station"
            },
            "amenity/fuel": {
                "icon": "fuel",
                "fields": [
                    "operator",
                    "address"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "amenity": "fuel"
                },
                "name": "Gas Station"
            },
            "amenity/grave_yard": {
                "icon": "cemetery",
                "fields": [
                    "religion"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "amenity": "grave_yard"
                },
                "name": "Graveyard"
            },
            "amenity/hospital": {
                "icon": "hospital",
                "fields": [
                    "emergency",
                    "building_area",
                    "address"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "terms": [
                    "clinic",
                    "emergency room",
                    "health service",
                    "hospice",
                    "infirmary",
                    "institution",
                    "nursing home",
                    "rest home",
                    "sanatorium",
                    "sanitarium",
                    "sick bay",
                    "surgery",
                    "ward"
                ],
                "tags": {
                    "amenity": "hospital"
                },
                "name": "Hospital"
            },
            "amenity/library": {
                "icon": "library",
                "fields": [
                    "operator",
                    "building_area",
                    "address"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "amenity": "library"
                },
                "terms": [],
                "name": "Library"
            },
            "amenity/marketplace": {
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "amenity": "marketplace"
                },
                "name": "Marketplace"
            },
            "amenity/parking": {
                "icon": "parking",
                "fields": [
                    "fee",
                    "access",
                    "address"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "amenity": "parking"
                },
                "terms": [],
                "name": "Parking"
            },
            "amenity/pharmacy": {
                "icon": "pharmacy",
                "fields": [
                    "operator",
                    "building_area",
                    "address"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "amenity": "pharmacy"
                },
                "terms": [],
                "name": "Pharmacy"
            },
            "amenity/place_of_worship": {
                "icon": "place-of-worship",
                "fields": [
                    "religion",
                    "denomination",
                    "building",
                    "address"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "terms": [
                    "abbey",
                    "basilica",
                    "bethel",
                    "cathedral",
                    "chancel",
                    "chantry",
                    "chapel",
                    "church",
                    "fold",
                    "house of God",
                    "house of prayer",
                    "house of worship",
                    "minster",
                    "mission",
                    "mosque",
                    "oratory",
                    "parish",
                    "sacellum",
                    "sanctuary",
                    "shrine",
                    "synagogue",
                    "tabernacle",
                    "temple"
                ],
                "tags": {
                    "amenity": "place_of_worship"
                },
                "name": "Place of Worship"
            },
            "amenity/place_of_worship/christian": {
                "icon": "religious-christian",
                "fields": [
                    "denomination",
                    "building",
                    "address"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "terms": [
                    "christian",
                    "abbey",
                    "basilica",
                    "bethel",
                    "cathedral",
                    "chancel",
                    "chantry",
                    "chapel",
                    "church",
                    "fold",
                    "house of God",
                    "house of prayer",
                    "house of worship",
                    "minster",
                    "mission",
                    "oratory",
                    "parish",
                    "sacellum",
                    "sanctuary",
                    "shrine",
                    "tabernacle",
                    "temple"
                ],
                "tags": {
                    "amenity": "place_of_worship",
                    "religion": "christian"
                },
                "name": "Church"
            },
            "amenity/place_of_worship/jewish": {
                "icon": "religious-jewish",
                "fields": [
                    "denomination",
                    "building",
                    "address"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "terms": [
                    "jewish",
                    "synagogue"
                ],
                "tags": {
                    "amenity": "place_of_worship",
                    "religion": "jewish"
                },
                "name": "Synagogue"
            },
            "amenity/place_of_worship/muslim": {
                "icon": "religious-muslim",
                "fields": [
                    "denomination",
                    "building",
                    "address"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "terms": [
                    "muslim",
                    "mosque"
                ],
                "tags": {
                    "amenity": "place_of_worship",
                    "religion": "muslim"
                },
                "name": "Mosque"
            },
            "amenity/police": {
                "icon": "police",
                "fields": [
                    "operator",
                    "building_area",
                    "address"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "terms": [
                    "badge",
                    "bear",
                    "blue",
                    "bluecoat",
                    "bobby",
                    "boy scout",
                    "bull",
                    "constable",
                    "constabulary",
                    "cop",
                    "copper",
                    "corps",
                    "county mounty",
                    "detective",
                    "fed",
                    "flatfoot",
                    "force",
                    "fuzz",
                    "gendarme",
                    "gumshoe",
                    "heat",
                    "law",
                    "law enforcement",
                    "man",
                    "narc",
                    "officers",
                    "patrolman",
                    "police"
                ],
                "tags": {
                    "amenity": "police"
                },
                "name": "Police"
            },
            "amenity/post_box": {
                "icon": "post",
                "fields": [
                    "operator",
                    "collection_times"
                ],
                "geometry": [
                    "point",
                    "vertex"
                ],
                "tags": {
                    "amenity": "post_box"
                },
                "terms": [
                    "letter drop",
                    "letterbox",
                    "mail drop",
                    "mailbox",
                    "pillar box",
                    "postbox"
                ],
                "name": "Mailbox"
            },
            "amenity/post_office": {
                "icon": "post",
                "fields": [
                    "operator",
                    "collection_times"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "amenity": "post_office"
                },
                "name": "Post Office"
            },
            "amenity/pub": {
                "icon": "beer",
                "fields": [
                    "building_area",
                    "address"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "amenity": "pub"
                },
                "terms": [],
                "name": "Pub"
            },
            "amenity/restaurant": {
                "icon": "restaurant",
                "fields": [
                    "cuisine",
                    "building_area",
                    "address"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "terms": [
                    "bar",
                    "cafeteria",
                    "café",
                    "canteen",
                    "chophouse",
                    "coffee shop",
                    "diner",
                    "dining room",
                    "dive*",
                    "doughtnut shop",
                    "drive-in",
                    "eatery",
                    "eating house",
                    "eating place",
                    "fast-food place",
                    "greasy spoon",
                    "grill",
                    "hamburger stand",
                    "hashery",
                    "hideaway",
                    "hotdog stand",
                    "inn",
                    "joint*",
                    "luncheonette",
                    "lunchroom",
                    "night club",
                    "outlet*",
                    "pizzeria",
                    "saloon",
                    "soda fountain",
                    "watering hole"
                ],
                "tags": {
                    "amenity": "restaurant"
                },
                "name": "Restaurant"
            },
            "amenity/school": {
                "icon": "school",
                "fields": [
                    "operator",
                    "building",
                    "address"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "terms": [
                    "academy",
                    "alma mater",
                    "blackboard",
                    "college",
                    "department",
                    "discipline",
                    "establishment",
                    "faculty",
                    "hall",
                    "halls of ivy",
                    "institute",
                    "institution",
                    "jail*",
                    "schoolhouse",
                    "seminary",
                    "university"
                ],
                "tags": {
                    "amenity": "school"
                },
                "name": "School"
            },
            "amenity/swimming_pool": {
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "amenity": "swimming_pool"
                },
                "icon": "swimming",
                "searchable": false,
                "name": "Swimming Pool"
            },
            "amenity/telephone": {
                "geometry": [
                    "point",
                    "vertex"
                ],
                "tags": {
                    "amenity": "telephone"
                },
                "name": "Telephone"
            },
            "amenity/theatre": {
                "icon": "theatre",
                "fields": [
                    "operator",
                    "building_area",
                    "address"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "terms": [
                    "theatre",
                    "performance",
                    "play",
                    "musical"
                ],
                "tags": {
                    "amenity": "theatre"
                },
                "name": "Theater"
            },
            "amenity/toilets": {
                "fields": [
                    "operator",
                    "building"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "terms": [],
                "tags": {
                    "amenity": "toilets"
                },
                "icon": "toilets",
                "name": "Toilets"
            },
            "amenity/townhall": {
                "icon": "town-hall",
                "fields": [
                    "building_area",
                    "address"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "terms": [
                    "village hall",
                    "city government",
                    "courthouse",
                    "municipal building",
                    "municipal center"
                ],
                "tags": {
                    "amenity": "townhall"
                },
                "name": "Town Hall"
            },
            "amenity/university": {
                "icon": "college",
                "fields": [
                    "operator",
                    "address"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "amenity": "university"
                },
                "terms": [],
                "name": "University"
            },
            "barrier": {
                "geometry": [
                    "point",
                    "vertex",
                    "line",
                    "area"
                ],
                "tags": {
                    "barrier": "*"
                },
                "fields": [
                    "barrier"
                ],
                "name": "Barrier"
            },
            "barrier/block": {
                "geometry": [
                    "point",
                    "vertex"
                ],
                "tags": {
                    "barrier": "block"
                },
                "name": "Block"
            },
            "barrier/bollard": {
                "geometry": [
                    "point",
                    "vertex",
                    "line"
                ],
                "tags": {
                    "barrier": "bollard"
                },
                "name": "Bollard"
            },
            "barrier/cattle_grid": {
                "geometry": [
                    "vertex"
                ],
                "tags": {
                    "barrier": "cattle_grid"
                },
                "name": "Cattle Grid"
            },
            "barrier/city_wall": {
                "geometry": [
                    "line",
                    "area"
                ],
                "tags": {
                    "barrier": "city_wall"
                },
                "name": "City Wall"
            },
            "barrier/cycle_barrier": {
                "geometry": [
                    "vertex"
                ],
                "tags": {
                    "barrier": "cycle_barrier"
                },
                "name": "Cycle Barrier"
            },
            "barrier/ditch": {
                "geometry": [
                    "line",
                    "area"
                ],
                "tags": {
                    "barrier": "ditch"
                },
                "name": "Ditch"
            },
            "barrier/entrance": {
                "geometry": [
                    "vertex"
                ],
                "tags": {
                    "barrier": "entrance"
                },
                "name": "Entrance"
            },
            "barrier/fence": {
                "geometry": [
                    "line",
                    "area"
                ],
                "tags": {
                    "barrier": "fence"
                },
                "name": "Fence"
            },
            "barrier/gate": {
                "geometry": [
                    "point",
                    "vertex",
                    "line"
                ],
                "tags": {
                    "barrier": "gate"
                },
                "name": "Gate"
            },
            "barrier/hedge": {
                "geometry": [
                    "line",
                    "area"
                ],
                "tags": {
                    "barrier": "hedge"
                },
                "name": "Hedge"
            },
            "barrier/kissing_gate": {
                "geometry": [
                    "vertex"
                ],
                "tags": {
                    "barrier": "kissing_gate"
                },
                "name": "Kissing Gate"
            },
            "barrier/lift_gate": {
                "geometry": [
                    "point",
                    "vertex"
                ],
                "tags": {
                    "barrier": "lift_gate"
                },
                "name": "Lift Gate"
            },
            "barrier/retaining_wall": {
                "geometry": [
                    "line",
                    "area"
                ],
                "tags": {
                    "barrier": "retaining_wall"
                },
                "name": "Retaining Wall"
            },
            "barrier/stile": {
                "geometry": [
                    "point",
                    "vertex"
                ],
                "tags": {
                    "barrier": "stile"
                },
                "name": "Stile"
            },
            "barrier/toll_booth": {
                "geometry": [
                    "vertex"
                ],
                "tags": {
                    "barrier": "toll_booth"
                },
                "name": "Toll Booth"
            },
            "barrier/wall": {
                "geometry": [
                    "line",
                    "area"
                ],
                "tags": {
                    "barrier": "wall"
                },
                "name": "Wall"
            },
            "building": {
                "icon": "warehouse",
                "fields": [
                    "building_yes",
                    "levels"
                ],
                "geometry": [
                    "area"
                ],
                "tags": {
                    "building": "*"
                },
                "terms": [],
                "name": "Building"
            },
            "building/entrance": {
                "geometry": [
                    "vertex"
                ],
                "tags": {
                    "building": "entrance"
                },
                "name": "Entrance",
                "searchable": false
            },
            "entrance": {
                "geometry": [
                    "vertex"
                ],
                "tags": {
                    "entrance": "*"
                },
                "fields": [
                    "entrance"
                ],
                "name": "Entrance"
            },
            "highway": {
                "fields": [
                    "highway"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "line",
                    "area"
                ],
                "tags": {
                    "highway": "*"
                },
                "name": "Highway"
            },
            "highway/bridleway": {
                "fields": [
                    "access",
                    "surface",
                    "structure"
                ],
                "icon": "highway-bridleway",
                "geometry": [
                    "line"
                ],
                "tags": {
                    "highway": "bridleway"
                },
                "terms": [
                    "bridleway",
                    "equestrian trail",
                    "horse riding path",
                    "bridle road",
                    "horse trail"
                ],
                "name": "Bridle Path"
            },
            "highway/bus_stop": {
                "icon": "bus",
                "fields": [
                    "operator",
                    "shelter"
                ],
                "geometry": [
                    "point",
                    "vertex"
                ],
                "tags": {
                    "highway": "bus_stop"
                },
                "terms": [],
                "name": "Bus Stop"
            },
            "highway/crossing": {
                "fields": [
                    "crossing"
                ],
                "geometry": [
                    "vertex"
                ],
                "tags": {
                    "highway": "crossing"
                },
                "terms": [
                    "crosswalk",
                    "zebra crossing"
                ],
                "name": "Crossing"
            },
            "highway/cycleway": {
                "icon": "highway-cycleway",
                "fields": [
                    "oneway",
                    "structure",
                    "access",
                    "surface"
                ],
                "geometry": [
                    "line"
                ],
                "tags": {
                    "highway": "cycleway"
                },
                "terms": [],
                "name": "Cycle Path"
            },
            "highway/footway": {
                "icon": "highway-footway",
                "fields": [
                    "structure",
                    "access",
                    "surface"
                ],
                "geometry": [
                    "line"
                ],
                "terms": [
                    "beaten path",
                    "boulevard",
                    "clearing",
                    "course",
                    "cut*",
                    "drag*",
                    "footpath",
                    "highway",
                    "lane",
                    "line",
                    "orbit",
                    "passage",
                    "pathway",
                    "rail",
                    "rails",
                    "road",
                    "roadway",
                    "route",
                    "street",
                    "thoroughfare",
                    "trackway",
                    "trail",
                    "trajectory",
                    "walk"
                ],
                "tags": {
                    "highway": "footway"
                },
                "name": "Foot Path"
            },
            "highway/motorway": {
                "icon": "highway-motorway",
                "fields": [
                    "oneway",
                    "structure",
                    "access",
                    "maxspeed",
                    "surface",
                    "ref"
                ],
                "geometry": [
                    "line"
                ],
                "tags": {
                    "highway": "motorway"
                },
                "terms": [],
                "name": "Motorway"
            },
            "highway/motorway_link": {
                "icon": "highway-motorway-link",
                "fields": [
                    "oneway_yes",
                    "structure",
                    "access",
                    "maxspeed",
                    "surface",
                    "ref"
                ],
                "geometry": [
                    "line"
                ],
                "tags": {
                    "highway": "motorway_link"
                },
                "terms": [
                    "ramp",
                    "on ramp",
                    "off ramp"
                ],
                "name": "Motorway Link"
            },
            "highway/path": {
                "icon": "highway-path",
                "fields": [
                    "oneway",
                    "structure",
                    "access",
                    "maxspeed",
                    "surface"
                ],
                "geometry": [
                    "line"
                ],
                "tags": {
                    "highway": "path"
                },
                "terms": [],
                "name": "Path"
            },
            "highway/primary": {
                "icon": "highway-primary",
                "fields": [
                    "oneway",
                    "structure",
                    "access",
                    "maxspeed",
                    "surface",
                    "ref"
                ],
                "geometry": [
                    "line"
                ],
                "tags": {
                    "highway": "primary"
                },
                "terms": [],
                "name": "Primary Road"
            },
            "highway/primary_link": {
                "icon": "highway-primary-link",
                "fields": [
                    "oneway",
                    "structure",
                    "access",
                    "maxspeed",
                    "surface",
                    "ref"
                ],
                "geometry": [
                    "line"
                ],
                "tags": {
                    "highway": "primary_link"
                },
                "terms": [
                    "ramp",
                    "on ramp",
                    "off ramp"
                ],
                "name": "Primary Link"
            },
            "highway/residential": {
                "icon": "highway-residential",
                "fields": [
                    "oneway",
                    "structure",
                    "access",
                    "maxspeed",
                    "surface"
                ],
                "geometry": [
                    "line"
                ],
                "tags": {
                    "highway": "residential"
                },
                "terms": [],
                "name": "Residential Road"
            },
            "highway/road": {
                "icon": "highway-road",
                "fields": [
                    "oneway",
                    "structure",
                    "access",
                    "maxspeed",
                    "surface"
                ],
                "geometry": [
                    "line"
                ],
                "tags": {
                    "highway": "road"
                },
                "terms": [],
                "name": "Unknown Road"
            },
            "highway/secondary": {
                "icon": "highway-secondary",
                "fields": [
                    "oneway",
                    "structure",
                    "access",
                    "maxspeed",
                    "surface",
                    "ref"
                ],
                "geometry": [
                    "line"
                ],
                "tags": {
                    "highway": "secondary"
                },
                "terms": [],
                "name": "Secondary Road"
            },
            "highway/secondary_link": {
                "icon": "highway-secondary-link",
                "fields": [
                    "oneway",
                    "structure",
                    "access",
                    "maxspeed",
                    "surface",
                    "ref"
                ],
                "geometry": [
                    "line"
                ],
                "tags": {
                    "highway": "secondary_link"
                },
                "terms": [
                    "ramp",
                    "on ramp",
                    "off ramp"
                ],
                "name": "Secondary Link"
            },
            "highway/service": {
                "icon": "highway-service",
                "fields": [
                    "service",
                    "oneway",
                    "structure",
                    "access",
                    "maxspeed",
                    "surface"
                ],
                "geometry": [
                    "line"
                ],
                "tags": {
                    "highway": "service"
                },
                "terms": [],
                "name": "Service Road"
            },
            "highway/steps": {
                "fields": [
                    "access",
                    "surface"
                ],
                "icon": "highway-steps",
                "geometry": [
                    "line"
                ],
                "tags": {
                    "highway": "steps"
                },
                "terms": [
                    "stairs",
                    "staircase"
                ],
                "name": "Steps"
            },
            "highway/tertiary": {
                "icon": "highway-tertiary",
                "fields": [
                    "oneway",
                    "structure",
                    "access",
                    "maxspeed",
                    "surface",
                    "ref"
                ],
                "geometry": [
                    "line"
                ],
                "tags": {
                    "highway": "tertiary"
                },
                "terms": [],
                "name": "Tertiary Road"
            },
            "highway/tertiary_link": {
                "icon": "highway-tertiary-link",
                "fields": [
                    "oneway",
                    "structure",
                    "access",
                    "maxspeed",
                    "surface",
                    "ref"
                ],
                "geometry": [
                    "line"
                ],
                "tags": {
                    "highway": "tertiary_link"
                },
                "terms": [
                    "ramp",
                    "on ramp",
                    "off ramp"
                ],
                "name": "Tertiary Link"
            },
            "highway/track": {
                "icon": "highway-track",
                "fields": [
                    "oneway",
                    "structure",
                    "access",
                    "maxspeed",
                    "surface"
                ],
                "geometry": [
                    "line"
                ],
                "tags": {
                    "highway": "track"
                },
                "terms": [],
                "name": "Track"
            },
            "highway/traffic_signals": {
                "geometry": [
                    "vertex"
                ],
                "tags": {
                    "highway": "traffic_signals"
                },
                "terms": [
                    "light",
                    "stoplight",
                    "traffic light"
                ],
                "name": "Traffic Signals"
            },
            "highway/trunk": {
                "icon": "highway-trunk",
                "fields": [
                    "oneway",
                    "structure",
                    "access",
                    "maxspeed",
                    "surface",
                    "ref"
                ],
                "geometry": [
                    "line"
                ],
                "tags": {
                    "highway": "trunk"
                },
                "terms": [],
                "name": "Trunk Road"
            },
            "highway/trunk_link": {
                "icon": "highway-trunk-link",
                "fields": [
                    "oneway",
                    "structure",
                    "access",
                    "maxspeed",
                    "surface",
                    "ref"
                ],
                "geometry": [
                    "line"
                ],
                "tags": {
                    "highway": "trunk_link"
                },
                "terms": [
                    "ramp",
                    "on ramp",
                    "off ramp"
                ],
                "name": "Trunk Link"
            },
            "highway/turning_circle": {
                "icon": "circle",
                "geometry": [
                    "vertex"
                ],
                "tags": {
                    "highway": "turning_circle"
                },
                "terms": [],
                "name": "Turning Circle"
            },
            "highway/unclassified": {
                "icon": "highway-unclassified",
                "fields": [
                    "oneway",
                    "structure",
                    "access",
                    "maxspeed",
                    "surface"
                ],
                "geometry": [
                    "line"
                ],
                "tags": {
                    "highway": "unclassified"
                },
                "terms": [],
                "name": "Unclassified Road"
            },
            "historic": {
                "fields": [
                    "historic"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "historic": "*"
                },
                "name": "Historic Site"
            },
            "historic/archaeological_site": {
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "historic": "archaeological_site"
                },
                "name": "Archaeological Site"
            },
            "historic/boundary_stone": {
                "geometry": [
                    "point",
                    "vertex"
                ],
                "tags": {
                    "historic": "boundary_stone"
                },
                "name": "Boundary Stone"
            },
            "historic/castle": {
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "historic": "castle"
                },
                "name": "Castle"
            },
            "historic/memorial": {
                "icon": "monument",
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "historic": "memorial"
                },
                "name": "Memorial"
            },
            "historic/monument": {
                "icon": "monument",
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "historic": "monument"
                },
                "name": "Monument"
            },
            "historic/ruins": {
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "historic": "ruins"
                },
                "name": "Ruins"
            },
            "historic/wayside_cross": {
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "historic": "wayside_cross"
                },
                "name": "Wayside Cross"
            },
            "historic/wayside_shrine": {
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "historic": "wayside_shrine"
                },
                "name": "Wayside Shrine"
            },
            "landuse": {
                "fields": [
                    "landuse"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "landuse": "*"
                },
                "name": "Landuse"
            },
            "landuse/allotments": {
                "geometry": [
                    "point",
                    "area"
                ],
                "tags": {
                    "landuse": "allotments"
                },
                "terms": [],
                "name": "Allotments"
            },
            "landuse/basin": {
                "geometry": [
                    "point",
                    "area"
                ],
                "tags": {
                    "landuse": "basin"
                },
                "terms": [],
                "name": "Basin"
            },
            "landuse/cemetery": {
                "icon": "cemetery",
                "geometry": [
                    "point",
                    "area"
                ],
                "tags": {
                    "landuse": "cemetery"
                },
                "terms": [],
                "name": "Cemetery"
            },
            "landuse/commercial": {
                "geometry": [
                    "point",
                    "area"
                ],
                "tags": {
                    "landuse": "commercial"
                },
                "terms": [],
                "name": "Commercial"
            },
            "landuse/construction": {
                "fields": [
                    "construction",
                    "operator"
                ],
                "geometry": [
                    "point",
                    "area"
                ],
                "tags": {
                    "landuse": "construction"
                },
                "terms": [],
                "name": "Construction"
            },
            "landuse/farm": {
                "geometry": [
                    "point",
                    "area"
                ],
                "tags": {
                    "landuse": "farm"
                },
                "terms": [],
                "name": "Farm"
            },
            "landuse/farmyard": {
                "geometry": [
                    "point",
                    "area"
                ],
                "tags": {
                    "landuse": "farmyard"
                },
                "terms": [],
                "name": "Farmyard"
            },
            "landuse/forest": {
                "fields": [
                    "wood"
                ],
                "icon": "park2",
                "geometry": [
                    "point",
                    "area"
                ],
                "tags": {
                    "landuse": "forest"
                },
                "terms": [],
                "name": "Forest"
            },
            "landuse/grass": {
                "geometry": [
                    "point",
                    "area"
                ],
                "tags": {
                    "landuse": "grass"
                },
                "terms": [],
                "name": "Grass"
            },
            "landuse/industrial": {
                "geometry": [
                    "point",
                    "area"
                ],
                "tags": {
                    "landuse": "industrial"
                },
                "terms": [],
                "name": "Industrial"
            },
            "landuse/meadow": {
                "geometry": [
                    "point",
                    "area"
                ],
                "tags": {
                    "landuse": "meadow"
                },
                "terms": [],
                "name": "Meadow"
            },
            "landuse/orchard": {
                "geometry": [
                    "point",
                    "area"
                ],
                "tags": {
                    "landuse": "orchard"
                },
                "terms": [],
                "name": "Orchard"
            },
            "landuse/quarry": {
                "geometry": [
                    "point",
                    "area"
                ],
                "tags": {
                    "landuse": "quarry"
                },
                "terms": [],
                "name": "Quarry"
            },
            "landuse/residential": {
                "geometry": [
                    "point",
                    "area"
                ],
                "tags": {
                    "landuse": "residential"
                },
                "terms": [],
                "name": "Residential"
            },
            "landuse/vineyard": {
                "geometry": [
                    "point",
                    "area"
                ],
                "tags": {
                    "landuse": "vineyard"
                },
                "terms": [],
                "name": "Vineyard"
            },
            "leisure": {
                "fields": [
                    "leisure"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "leisure": "*"
                },
                "name": "Leisure"
            },
            "leisure/garden": {
                "icon": "garden",
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "leisure": "garden"
                },
                "name": "Garden"
            },
            "leisure/golf_course": {
                "icon": "golf",
                "fields": [
                    "operator",
                    "address"
                ],
                "geometry": [
                    "point",
                    "area"
                ],
                "tags": {
                    "leisure": "golf_course"
                },
                "terms": [],
                "name": "Golf Course"
            },
            "leisure/marina": {
                "icon": "marina",
                "geometry": [
                    "point",
                    "vertex",
                    "line",
                    "area"
                ],
                "tags": {
                    "leisure": "marina"
                },
                "name": "Marina"
            },
            "leisure/park": {
                "icon": "park",
                "geometry": [
                    "point",
                    "area"
                ],
                "terms": [
                    "esplanade",
                    "estate",
                    "forest",
                    "garden",
                    "grass",
                    "green",
                    "grounds",
                    "lawn",
                    "lot",
                    "meadow",
                    "parkland",
                    "place",
                    "playground",
                    "plaza",
                    "pleasure garden",
                    "recreation area",
                    "square",
                    "tract",
                    "village green",
                    "woodland"
                ],
                "tags": {
                    "leisure": "park"
                },
                "name": "Park"
            },
            "leisure/pitch": {
                "icon": "pitch",
                "fields": [
                    "sport",
                    "surface"
                ],
                "geometry": [
                    "point",
                    "area"
                ],
                "tags": {
                    "leisure": "pitch"
                },
                "terms": [],
                "name": "Sport Pitch"
            },
            "leisure/pitch/american_football": {
                "icon": "america-football",
                "fields": [
                    "surface"
                ],
                "geometry": [
                    "point",
                    "area"
                ],
                "tags": {
                    "leisure": "pitch",
                    "sport": "american_football"
                },
                "terms": [],
                "name": "American Football Field"
            },
            "leisure/pitch/baseball": {
                "icon": "baseball",
                "geometry": [
                    "point",
                    "area"
                ],
                "tags": {
                    "leisure": "pitch",
                    "sport": "baseball"
                },
                "terms": [],
                "name": "Baseball Diamond"
            },
            "leisure/pitch/basketball": {
                "icon": "basketball",
                "fields": [
                    "surface"
                ],
                "geometry": [
                    "point",
                    "area"
                ],
                "tags": {
                    "leisure": "pitch",
                    "sport": "basketball"
                },
                "terms": [],
                "name": "Basketball Court"
            },
            "leisure/pitch/soccer": {
                "icon": "soccer",
                "fields": [
                    "surface"
                ],
                "geometry": [
                    "point",
                    "area"
                ],
                "tags": {
                    "leisure": "pitch",
                    "sport": "soccer"
                },
                "terms": [],
                "name": "Soccer Field"
            },
            "leisure/pitch/tennis": {
                "icon": "tennis",
                "fields": [
                    "surface"
                ],
                "geometry": [
                    "point",
                    "area"
                ],
                "tags": {
                    "leisure": "pitch",
                    "sport": "tennis"
                },
                "terms": [],
                "name": "Tennis Court"
            },
            "leisure/playground": {
                "geometry": [
                    "point",
                    "area"
                ],
                "tags": {
                    "leisure": "playground"
                },
                "name": "Playground"
            },
            "leisure/slipway": {
                "geometry": [
                    "point",
                    "line"
                ],
                "tags": {
                    "leisure": "slipway"
                },
                "name": "Slipway"
            },
            "leisure/stadium": {
                "geometry": [
                    "point",
                    "area"
                ],
                "tags": {
                    "leisure": "stadium"
                },
                "fields": [
                    "sport"
                ],
                "name": "Stadium"
            },
            "leisure/swimming_pool": {
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "leisure": "swimming_pool"
                },
                "icon": "swimming",
                "name": "Swimming Pool"
            },
            "man_made": {
                "fields": [
                    "man_made"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "line",
                    "area"
                ],
                "tags": {
                    "man_made": "*"
                },
                "name": "Man Made"
            },
            "man_made/lighthouse": {
                "geometry": [
                    "point",
                    "area"
                ],
                "tags": {
                    "man_made": "lighthouse"
                },
                "name": "Lighthouse"
            },
            "man_made/pier": {
                "geometry": [
                    "line",
                    "area"
                ],
                "tags": {
                    "man_made": "pier"
                },
                "name": "Pier"
            },
            "man_made/survey_point": {
                "icon": "monument",
                "geometry": [
                    "point",
                    "vertex"
                ],
                "tags": {
                    "man_made": "survey_point"
                },
                "fields": [
                    "ref"
                ],
                "name": "Survey Point"
            },
            "man_made/water_tower": {
                "icon": "water",
                "geometry": [
                    "point",
                    "area"
                ],
                "tags": {
                    "man_made": "water_tower"
                },
                "name": "Water Tower"
            },
            "natural": {
                "fields": [
                    "natural"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "natural": "*"
                },
                "name": "Natural"
            },
            "natural/bay": {
                "geometry": [
                    "point",
                    "area"
                ],
                "terms": [],
                "tags": {
                    "natural": "bay"
                },
                "name": "Bay"
            },
            "natural/beach": {
                "fields": [
                    "surface"
                ],
                "geometry": [
                    "point",
                    "area"
                ],
                "terms": [],
                "tags": {
                    "natural": "beach"
                },
                "name": "Beach"
            },
            "natural/cliff": {
                "geometry": [
                    "point",
                    "vertex",
                    "line",
                    "area"
                ],
                "terms": [],
                "tags": {
                    "natural": "cliff"
                },
                "name": "Cliff"
            },
            "natural/coastline": {
                "geometry": [
                    "line"
                ],
                "terms": [
                    "shore"
                ],
                "tags": {
                    "natural": "coastline"
                },
                "name": "Coastline"
            },
            "natural/glacier": {
                "geometry": [
                    "area"
                ],
                "terms": [],
                "tags": {
                    "natural": "glacier"
                },
                "name": "Glacier"
            },
            "natural/grassland": {
                "geometry": [
                    "point",
                    "area"
                ],
                "terms": [],
                "tags": {
                    "natural": "grassland"
                },
                "name": "Grassland"
            },
            "natural/heath": {
                "geometry": [
                    "area"
                ],
                "terms": [],
                "tags": {
                    "natural": "heath"
                },
                "name": "Heath"
            },
            "natural/peak": {
                "icon": "triangle",
                "fields": [
                    "elevation"
                ],
                "geometry": [
                    "point",
                    "vertex"
                ],
                "tags": {
                    "natural": "peak"
                },
                "terms": [
                    "acme",
                    "aiguille",
                    "alp",
                    "climax",
                    "crest",
                    "crown",
                    "hill",
                    "mount",
                    "mountain",
                    "pinnacle",
                    "summit",
                    "tip",
                    "top"
                ],
                "name": "Peak"
            },
            "natural/scrub": {
                "geometry": [
                    "area"
                ],
                "tags": {
                    "natural": "scrub"
                },
                "terms": [],
                "name": "Scrub"
            },
            "natural/spring": {
                "geometry": [
                    "point",
                    "vertex"
                ],
                "terms": [],
                "tags": {
                    "natural": "spring"
                },
                "name": "Spring"
            },
            "natural/tree": {
                "fields": [
                    "denotation"
                ],
                "icon": "park",
                "geometry": [
                    "point",
                    "vertex"
                ],
                "terms": [],
                "tags": {
                    "natural": "tree"
                },
                "name": "Tree"
            },
            "natural/water": {
                "fields": [
                    "water"
                ],
                "geometry": [
                    "area"
                ],
                "tags": {
                    "natural": "water"
                },
                "icon": "water",
                "name": "Water"
            },
            "natural/water/lake": {
                "geometry": [
                    "area"
                ],
                "tags": {
                    "natural": "water",
                    "water": "lake"
                },
                "terms": [
                    "lakelet",
                    "loch",
                    "mere"
                ],
                "icon": "water",
                "name": "Lake"
            },
            "natural/water/pond": {
                "geometry": [
                    "area"
                ],
                "tags": {
                    "natural": "water",
                    "water": "pond"
                },
                "terms": [
                    "lakelet",
                    "millpond",
                    "tarn",
                    "pool",
                    "mere"
                ],
                "icon": "water",
                "name": "Pond"
            },
            "natural/water/reservoir": {
                "geometry": [
                    "area"
                ],
                "tags": {
                    "natural": "water",
                    "water": "reservoir"
                },
                "icon": "water",
                "name": "Reservoir"
            },
            "natural/wetland": {
                "icon": "wetland",
                "fields": [
                    "wetland"
                ],
                "geometry": [
                    "point",
                    "area"
                ],
                "tags": {
                    "natural": "wetland"
                },
                "terms": [],
                "name": "Wetland"
            },
            "natural/wood": {
                "fields": [
                    "wood"
                ],
                "icon": "park2",
                "geometry": [
                    "point",
                    "area"
                ],
                "tags": {
                    "natural": "wood"
                },
                "terms": [],
                "name": "Wood"
            },
            "office": {
                "icon": "commercial",
                "fields": [
                    "office",
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "office": "*"
                },
                "terms": [],
                "name": "Office"
            },
            "place": {
                "fields": [
                    "place"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "place": "*"
                },
                "name": "Place"
            },
            "place/hamlet": {
                "icon": "triangle-stroked",
                "geometry": [
                    "point",
                    "area"
                ],
                "tags": {
                    "place": "hamlet"
                },
                "name": "Hamlet"
            },
            "place/island": {
                "geometry": [
                    "point",
                    "area"
                ],
                "terms": [
                    "archipelago",
                    "atoll",
                    "bar",
                    "cay",
                    "isle",
                    "islet",
                    "key",
                    "reef"
                ],
                "tags": {
                    "place": "island"
                },
                "name": "Island"
            },
            "place/locality": {
                "icon": "marker",
                "geometry": [
                    "point",
                    "area"
                ],
                "tags": {
                    "place": "locality"
                },
                "name": "Locality"
            },
            "place/village": {
                "icon": "square-stroked",
                "geometry": [
                    "point",
                    "area"
                ],
                "tags": {
                    "place": "village"
                },
                "name": "Village"
            },
            "power": {
                "geometry": [
                    "point",
                    "vertex",
                    "line",
                    "area"
                ],
                "tags": {
                    "power": "*"
                },
                "fields": [
                    "power"
                ],
                "name": "Power"
            },
            "power/generator": {
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "power": "generator"
                },
                "name": "Power Plant"
            },
            "power/line": {
                "geometry": [
                    "line"
                ],
                "tags": {
                    "power": "line"
                },
                "name": "Power Line",
                "icon": "power-line"
            },
            "power/pole": {
                "geometry": [
                    "vertex"
                ],
                "tags": {
                    "power": "pole"
                },
                "name": "Power Pole"
            },
            "power/sub_station": {
                "fields": [
                    "operator"
                ],
                "geometry": [
                    "point",
                    "area"
                ],
                "tags": {
                    "power": "substation"
                },
                "name": "Substation"
            },
            "power/tower": {
                "geometry": [
                    "vertex"
                ],
                "tags": {
                    "power": "tower"
                },
                "name": "High-Voltage Tower"
            },
            "power/transformer": {
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "power": "transformer"
                },
                "name": "Transformer"
            },
            "railway": {
                "fields": [
                    "railway"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "line",
                    "area"
                ],
                "tags": {
                    "railway": "*"
                },
                "name": "Railway"
            },
            "railway/abandoned": {
                "icon": "railway-abandoned",
                "geometry": [
                    "line"
                ],
                "tags": {
                    "railway": "abandoned"
                },
                "fields": [
                    "structure"
                ],
                "terms": [],
                "name": "Abandoned Railway"
            },
            "railway/disused": {
                "icon": "railway-disused",
                "geometry": [
                    "line"
                ],
                "tags": {
                    "railway": "disused"
                },
                "fields": [
                    "structure"
                ],
                "terms": [],
                "name": "Disused Railway"
            },
            "railway/level_crossing": {
                "icon": "cross",
                "geometry": [
                    "vertex"
                ],
                "tags": {
                    "railway": "level_crossing"
                },
                "terms": [
                    "crossing",
                    "railroad crossing",
                    "railway crossing",
                    "grade crossing",
                    "road through railroad",
                    "train crossing"
                ],
                "name": "Level Crossing"
            },
            "railway/monorail": {
                "icon": "railway-monorail",
                "geometry": [
                    "line"
                ],
                "tags": {
                    "railway": "monorail"
                },
                "fields": [
                    "structure"
                ],
                "terms": [],
                "name": "Monorail"
            },
            "railway/rail": {
                "icon": "railway-rail",
                "geometry": [
                    "line"
                ],
                "tags": {
                    "railway": "rail"
                },
                "fields": [
                    "structure"
                ],
                "terms": [],
                "name": "Rail"
            },
            "railway/subway": {
                "icon": "railway-subway",
                "fields": [
                    "structure"
                ],
                "geometry": [
                    "line"
                ],
                "tags": {
                    "railway": "subway"
                },
                "terms": [],
                "name": "Subway"
            },
            "railway/subway_entrance": {
                "icon": "rail-underground",
                "geometry": [
                    "point"
                ],
                "tags": {
                    "railway": "subway_entrance"
                },
                "terms": [],
                "name": "Subway Entrance"
            },
            "railway/tram": {
                "icon": "railway-light_rail",
                "geometry": [
                    "line"
                ],
                "tags": {
                    "railway": "tram"
                },
                "fields": [
                    "structure"
                ],
                "terms": [
                    "streetcar"
                ],
                "name": "Tram"
            },
            "shop": {
                "icon": "shop",
                "fields": [
                    "shop",
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "*"
                },
                "terms": [],
                "name": "Shop"
            },
            "shop/alcohol": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "alcohol"
                },
                "name": "Liquor Store"
            },
            "shop/bakery": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "bakery"
                },
                "name": "Bakery"
            },
            "shop/beauty": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "beauty"
                },
                "name": "Beauty Shop"
            },
            "shop/beverages": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "beverages"
                },
                "name": "Beverage Store"
            },
            "shop/bicycle": {
                "icon": "bicycle",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "bicycle"
                },
                "name": "Bicycle Shop"
            },
            "shop/books": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "books"
                },
                "name": "Bookstore"
            },
            "shop/boutique": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "boutique"
                },
                "name": "Boutique"
            },
            "shop/butcher": {
                "icon": "slaughterhouse",
                "fields": [
                    "building_area",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "terms": [],
                "tags": {
                    "shop": "butcher"
                },
                "name": "Butcher"
            },
            "shop/car": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "car"
                },
                "name": "Car Dealership"
            },
            "shop/car_parts": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "car_parts"
                },
                "name": "Car Parts Store"
            },
            "shop/car_repair": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "car_repair"
                },
                "name": "Car Repair Shop"
            },
            "shop/chemist": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "chemist"
                },
                "name": "Chemist"
            },
            "shop/clothes": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "clothes"
                },
                "name": "Clothing Store"
            },
            "shop/computer": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "computer"
                },
                "name": "Computer Store"
            },
            "shop/confectionery": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "confectionery"
                },
                "name": "Confectionery"
            },
            "shop/convenience": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "convenience"
                },
                "name": "Convenience Store"
            },
            "shop/deli": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "deli"
                },
                "name": "Deli"
            },
            "shop/department_store": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "department_store"
                },
                "name": "Department Store"
            },
            "shop/doityourself": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "doityourself"
                },
                "name": "DIY Store"
            },
            "shop/dry_cleaning": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "dry_cleaning"
                },
                "name": "Dry Cleaners"
            },
            "shop/electronics": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "electronics"
                },
                "name": "Electronics Store"
            },
            "shop/fishmonger": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "fishmonger"
                },
                "name": "Fishmonger"
            },
            "shop/florist": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "florist"
                },
                "name": "Florist"
            },
            "shop/furniture": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "furniture"
                },
                "name": "Furniture Store"
            },
            "shop/garden_centre": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "garden_centre"
                },
                "name": "Garden Center"
            },
            "shop/gift": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "gift"
                },
                "name": "Gift Shop"
            },
            "shop/greengrocer": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "greengrocer"
                },
                "name": "Greengrocer"
            },
            "shop/hairdresser": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "hairdresser"
                },
                "name": "Hairdresser"
            },
            "shop/hardware": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "hardware"
                },
                "name": "Hardware Store"
            },
            "shop/hifi": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "hifi"
                },
                "name": "Hifi Store"
            },
            "shop/jewelry": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "jewelry"
                },
                "name": "Jeweler"
            },
            "shop/kiosk": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "kiosk"
                },
                "name": "Kiosk"
            },
            "shop/laundry": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "laundry"
                },
                "name": "Laundry"
            },
            "shop/mall": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "mall"
                },
                "name": "Mall"
            },
            "shop/mobile_phone": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "mobile_phone"
                },
                "name": "Mobile Phone Store"
            },
            "shop/motorcycle": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "motorcycle"
                },
                "name": "Motorcycle Dealership"
            },
            "shop/music": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "music"
                },
                "name": "Music Store"
            },
            "shop/newsagent": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "newsagent"
                },
                "name": "Newsagent"
            },
            "shop/optician": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "optician"
                },
                "name": "Optician"
            },
            "shop/outdoor": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "outdoor"
                },
                "name": "Outdoor Store"
            },
            "shop/pet": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "pet"
                },
                "name": "Pet Store"
            },
            "shop/shoes": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "shoes"
                },
                "name": "Shoe Store"
            },
            "shop/sports": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "sports"
                },
                "name": "Sporting Goods Store"
            },
            "shop/stationery": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "stationery"
                },
                "name": "Stationery Store"
            },
            "shop/supermarket": {
                "icon": "grocery",
                "fields": [
                    "operator",
                    "building_area",
                    "address"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "terms": [
                    "bazaar",
                    "boutique",
                    "chain",
                    "co-op",
                    "cut-rate store",
                    "discount store",
                    "five-and-dime",
                    "flea market",
                    "galleria",
                    "mall",
                    "mart",
                    "outlet",
                    "outlet store",
                    "shop",
                    "shopping center",
                    "shopping plaza",
                    "stand",
                    "store",
                    "supermarket",
                    "thrift shop"
                ],
                "tags": {
                    "shop": "supermarket"
                },
                "name": "Supermarket"
            },
            "shop/toys": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "toys"
                },
                "name": "Toy Store"
            },
            "shop/travel_agency": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "travel_agency"
                },
                "name": "Travel Agency"
            },
            "shop/tyres": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "tyres"
                },
                "name": "Tire Store"
            },
            "shop/vacant": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "vacant"
                },
                "name": "Vacant Shop"
            },
            "shop/variety_store": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "variety_store"
                },
                "name": "Variety Store"
            },
            "shop/video": {
                "icon": "shop",
                "fields": [
                    "address",
                    "opening_hours"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "shop": "video"
                },
                "name": "Video Store"
            },
            "tourism": {
                "fields": [
                    "tourism"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "tourism": "*"
                },
                "name": "Tourism"
            },
            "tourism/alpine_hut": {
                "icon": "lodging",
                "fields": [
                    "operator",
                    "address"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "tourism": "alpine_hut"
                },
                "name": "Alpine Hut"
            },
            "tourism/artwork": {
                "geometry": [
                    "point",
                    "vertex",
                    "line",
                    "area"
                ],
                "tags": {
                    "tourism": "artwork"
                },
                "name": "Artwork"
            },
            "tourism/attraction": {
                "fields": [
                    "operator",
                    "address"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "tourism": "attraction"
                },
                "name": "Tourist Attraction"
            },
            "tourism/camp_site": {
                "icon": "campsite",
                "fields": [
                    "operator",
                    "address"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "terms": [],
                "tags": {
                    "tourism": "camp_site"
                },
                "name": "Camp Site"
            },
            "tourism/caravan_site": {
                "fields": [
                    "operator",
                    "address"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "tourism": "caravan_site"
                },
                "name": "RV Park"
            },
            "tourism/chalet": {
                "icon": "lodging",
                "fields": [
                    "operator",
                    "building_area",
                    "address"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "tourism": "chalet"
                },
                "name": "Chalet"
            },
            "tourism/guest_house": {
                "icon": "lodging",
                "fields": [
                    "operator",
                    "address"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "tourism": "guest_house"
                },
                "terms": [
                    "B&B",
                    "Bed & Breakfast",
                    "Bed and Breakfast"
                ],
                "name": "Guest House"
            },
            "tourism/hostel": {
                "icon": "lodging",
                "fields": [
                    "operator",
                    "building_area",
                    "address"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "tourism": "hostel"
                },
                "name": "Hostel"
            },
            "tourism/hotel": {
                "icon": "lodging",
                "fields": [
                    "operator",
                    "building_area",
                    "address"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "terms": [],
                "tags": {
                    "tourism": "hotel"
                },
                "name": "Hotel"
            },
            "tourism/information": {
                "fields": [
                    "building_area",
                    "address"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "tourism": "information"
                },
                "name": "Information"
            },
            "tourism/motel": {
                "icon": "lodging",
                "fields": [
                    "operator",
                    "building_area",
                    "address"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "tourism": "motel"
                },
                "name": "Motel"
            },
            "tourism/museum": {
                "icon": "museum",
                "fields": [
                    "operator",
                    "building_area",
                    "address"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "terms": [
                    "exhibition",
                    "exhibits archive",
                    "foundation",
                    "gallery",
                    "hall",
                    "institution",
                    "library",
                    "menagerie",
                    "repository",
                    "salon",
                    "storehouse",
                    "treasury",
                    "vault"
                ],
                "tags": {
                    "tourism": "museum"
                },
                "name": "Museum"
            },
            "tourism/picnic_site": {
                "fields": [
                    "operator",
                    "building_area",
                    "address"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "terms": [],
                "tags": {
                    "tourism": "picnic_site"
                },
                "name": "Picnic Site"
            },
            "tourism/theme_park": {
                "fields": [
                    "operator",
                    "building_area",
                    "address"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "tourism": "theme_park"
                },
                "name": "Theme Park"
            },
            "tourism/viewpoint": {
                "geometry": [
                    "point",
                    "vertex"
                ],
                "tags": {
                    "tourism": "viewpoint"
                },
                "name": "Viewpoint"
            },
            "tourism/zoo": {
                "icon": "zoo",
                "fields": [
                    "operator",
                    "address"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "area"
                ],
                "tags": {
                    "tourism": "zoo"
                },
                "name": "Zoo"
            },
            "waterway": {
                "fields": [
                    "waterway"
                ],
                "geometry": [
                    "point",
                    "vertex",
                    "line",
                    "area"
                ],
                "tags": {
                    "waterway": "*"
                },
                "name": "Waterway"
            },
            "waterway/canal": {
                "icon": "waterway-canal",
                "geometry": [
                    "line"
                ],
                "tags": {
                    "waterway": "canal"
                },
                "name": "Canal"
            },
            "waterway/dam": {
                "icon": "dam",
                "geometry": [
                    "point",
                    "vertex",
                    "line",
                    "area"
                ],
                "tags": {
                    "waterway": "dam"
                },
                "name": "Dam"
            },
            "waterway/ditch": {
                "icon": "waterway-ditch",
                "geometry": [
                    "line"
                ],
                "tags": {
                    "waterway": "ditch"
                },
                "name": "Ditch"
            },
            "waterway/drain": {
                "icon": "waterway-river",
                "geometry": [
                    "line"
                ],
                "tags": {
                    "waterway": "drain"
                },
                "name": "Drain"
            },
            "waterway/river": {
                "icon": "waterway-river",
                "geometry": [
                    "line"
                ],
                "terms": [
                    "beck",
                    "branch",
                    "brook",
                    "course",
                    "creek",
                    "estuary",
                    "rill",
                    "rivulet",
                    "run",
                    "runnel",
                    "stream",
                    "tributary",
                    "watercourse"
                ],
                "tags": {
                    "waterway": "river"
                },
                "name": "River"
            },
            "waterway/riverbank": {
                "icon": "water",
                "geometry": [
                    "area"
                ],
                "tags": {
                    "waterway": "riverbank"
                },
                "name": "Riverbank"
            },
            "waterway/stream": {
                "icon": "waterway-stream",
                "fields": [
                    "layer"
                ],
                "geometry": [
                    "line"
                ],
                "terms": [
                    "beck",
                    "branch",
                    "brook",
                    "burn",
                    "course",
                    "creek",
                    "current",
                    "drift",
                    "flood",
                    "flow",
                    "freshet",
                    "race",
                    "rill",
                    "rindle",
                    "rivulet",
                    "run",
                    "runnel",
                    "rush",
                    "spate",
                    "spritz",
                    "surge",
                    "tide",
                    "torrent",
                    "tributary",
                    "watercourse"
                ],
                "tags": {
                    "waterway": "stream"
                },
                "name": "Stream"
            },
            "waterway/weir": {
                "icon": "dam",
                "geometry": [
                    "vertex",
                    "line"
                ],
                "tags": {
                    "waterway": "weir"
                },
                "name": "Weir"
            }
        },
        "defaults": {
            "area": [
                "building",
                "leisure/park",
                "natural/water",
                "amenity/parking",
                "amenity/hospital",
                "amenity/place_of_worship",
                "amenity/cafe",
                "amenity/restaurant",
                "amenity/bar",
                "amenity/fast_food",
                "amenity/bank",
                "other"
            ],
            "line": [
                "Road",
                "Rail",
                "Path",
                "Water",
                "power/line",
                "other"
            ],
            "point": [
                "highway/bus_stop",
                "leisure/park",
                "amenity/hospital",
                "amenity/place_of_worship",
                "amenity/cafe",
                "amenity/restaurant",
                "amenity/bar",
                "amenity/fast_food",
                "amenity/bank",
                "amenity/cinema",
                "shop/supermarket",
                "other"
            ],
            "vertex": [
                "highway/crossing",
                "highway/turning_circle",
                "other"
            ]
        },
        "categories": [
            {
                "geometry": "line",
                "id": "Road",
                "icon": "category-roads",
                "members": [
                    "highway/residential",
                    "highway/motorway",
                    "highway/trunk",
                    "highway/primary",
                    "highway/secondary",
                    "highway/tertiary",
                    "highway/unclassified",
                    "highway/motorway_link",
                    "highway/trunk_link",
                    "highway/primary_link",
                    "highway/secondary_link",
                    "highway/tertiary_link",
                    "highway/service",
                    "highway/track",
                    "highway/road"
                ]
            },
            {
                "geometry": "line",
                "id": "Rail",
                "icon": "railway-rail",
                "members": [
                    "railway/rail",
                    "railway/subway",
                    "railway/tram",
                    "railway/monorail",
                    "railway/disused",
                    "railway/abandoned"
                ]
            },
            {
                "geometry": "line",
                "id": "Path",
                "icon": "highway-path",
                "members": [
                    "highway/footway",
                    "highway/cycleway",
                    "highway/bridleway",
                    "highway/path",
                    "highway/steps"
                ]
            },
            {
                "geometry": "line",
                "id": "Water",
                "icon": "waterway-river",
                "members": [
                    "waterway/river",
                    "waterway/stream",
                    "waterway/canal",
                    "waterway/ditch"
                ]
            }
        ],
        "fields": {
            "access": {
                "key": "access",
                "type": "combo",
                "label": "Access"
            },
            "address": {
                "type": "address",
                "keys": [
                    "addr:housename",
                    "addr:housenumber",
                    "addr:street",
                    "addr:city"
                ],
                "icon": "address",
                "universal": true,
                "label": "Address",
                "strings": {
                    "placeholders": {
                        "housename": "Housename",
                        "number": "123",
                        "street": "Street",
                        "city": "City"
                    }
                }
            },
            "aeroway": {
                "key": "aeroway",
                "type": "combo",
                "label": "Type"
            },
            "amenity": {
                "key": "amenity",
                "type": "combo",
                "label": "Type"
            },
            "atm": {
                "key": "atm",
                "type": "check",
                "label": "ATM"
            },
            "barrier": {
                "key": "barrier",
                "type": "combo",
                "label": "Type"
            },
            "bicycle_parking": {
                "key": "bicycle_parking",
                "type": "combo",
                "label": "Type"
            },
            "building": {
                "key": "building",
                "type": "combo",
                "label": "Building"
            },
            "building_area": {
                "key": "building",
                "type": "check",
                "default": "yes",
                "geometry": "area",
                "label": "Building"
            },
            "building_yes": {
                "key": "building",
                "type": "combo",
                "default": "yes",
                "label": "Building"
            },
            "capacity": {
                "key": "capacity",
                "type": "text",
                "label": "Capacity"
            },
            "collection_times": {
                "key": "collection_times",
                "type": "text",
                "label": "Collection Times"
            },
            "construction": {
                "key": "construction",
                "type": "combo",
                "label": "Type"
            },
            "country": {
                "key": "country",
                "type": "combo",
                "label": "Country"
            },
            "crossing": {
                "key": "crossing",
                "type": "combo",
                "label": "Type"
            },
            "cuisine": {
                "key": "cuisine",
                "type": "combo",
                "indexed": true,
                "label": "Cuisine"
            },
            "denomination": {
                "key": "denomination",
                "type": "combo",
                "label": "Denomination"
            },
            "denotation": {
                "key": "denotation",
                "type": "combo",
                "label": "Denotation"
            },
            "elevation": {
                "key": "ele",
                "type": "number",
                "icon": "elevation",
                "universal": true,
                "label": "Elevation"
            },
            "emergency": {
                "key": "emergency",
                "type": "check",
                "label": "Emergency"
            },
            "entrance": {
                "key": "entrance",
                "type": "combo",
                "label": "Type"
            },
            "fax": {
                "key": "fax",
                "type": "tel",
                "label": "Fax"
            },
            "fee": {
                "key": "fee",
                "type": "check",
                "label": "Fee"
            },
            "highway": {
                "key": "highway",
                "type": "combo",
                "label": "Type"
            },
            "historic": {
                "key": "historic",
                "type": "combo",
                "label": "Type"
            },
            "internet_access": {
                "key": "internet_access",
                "type": "combo",
                "options": [
                    "yes",
                    "no",
                    "wlan",
                    "wired",
                    "terminal"
                ],
                "label": "Internet Access",
                "strings": {
                    "options": {
                        "yes": "Yes",
                        "no": "No",
                        "wlan": "Wifi",
                        "wired": "Wired",
                        "terminal": "Terminal"
                    }
                }
            },
            "landuse": {
                "key": "landuse",
                "type": "combo",
                "label": "Type"
            },
            "layer": {
                "key": "layer",
                "type": "combo",
                "label": "Layer"
            },
            "leisure": {
                "key": "leisure",
                "type": "combo",
                "label": "Type"
            },
            "levels": {
                "key": "building:levels",
                "type": "number",
                "label": "Levels"
            },
            "man_made": {
                "key": "man_made",
                "type": "combo",
                "label": "Type"
            },
            "maxspeed": {
                "key": "maxspeed",
                "type": "combo",
                "label": "Speed Limit"
            },
            "name": {
                "key": "name",
                "type": "text",
                "label": "Name"
            },
            "natural": {
                "key": "natural",
                "type": "combo",
                "label": "Natural"
            },
            "network": {
                "key": "network",
                "type": "text",
                "label": "Network"
            },
            "note": {
                "key": "note",
                "type": "textarea",
                "universal": true,
                "icon": "note",
                "label": "Note"
            },
            "office": {
                "key": "office",
                "type": "combo",
                "label": "Type"
            },
            "oneway": {
                "key": "oneway",
                "type": "check",
                "label": "One Way"
            },
            "oneway_yes": {
                "key": "oneway",
                "type": "check",
                "default": "yes",
                "label": "One Way"
            },
            "opening_hours": {
                "key": "opening_hours",
                "type": "text",
                "label": "Hours"
            },
            "operator": {
                "key": "operator",
                "type": "text",
                "label": "Operator"
            },
            "phone": {
                "key": "phone",
                "type": "tel",
                "icon": "telephone",
                "universal": true,
                "label": "Phone"
            },
            "place": {
                "key": "place",
                "type": "combo",
                "label": "Type"
            },
            "power": {
                "key": "power",
                "type": "combo",
                "label": "Type"
            },
            "railway": {
                "key": "railway",
                "type": "combo",
                "label": "Type"
            },
            "ref": {
                "key": "ref",
                "type": "text",
                "label": "Reference"
            },
            "religion": {
                "key": "religion",
                "type": "combo",
                "options": [
                    "christian",
                    "muslim",
                    "buddhist",
                    "jewish",
                    "hindu",
                    "shinto",
                    "taoist"
                ],
                "label": "Religion",
                "strings": {
                    "options": {
                        "christian": "Christian",
                        "muslim": "Muslim",
                        "buddhist": "Buddhist",
                        "jewish": "Jewish",
                        "hindu": "Hindu",
                        "shinto": "Shinto",
                        "taoist": "Taoist"
                    }
                }
            },
            "service": {
                "key": "service",
                "type": "combo",
                "options": [
                    "parking_aisle",
                    "driveway",
                    "alley",
                    "drive-through",
                    "emergency_access"
                ],
                "label": "Type"
            },
            "shelter": {
                "key": "shelter",
                "type": "check",
                "label": "Shelter"
            },
            "shop": {
                "key": "shop",
                "type": "combo",
                "label": "Type"
            },
            "source": {
                "key": "source",
                "type": "text",
                "icon": "source",
                "universal": true,
                "label": "Source"
            },
            "sport": {
                "key": "sport",
                "type": "combo",
                "label": "Sport"
            },
            "structure": {
                "type": "radio",
                "keys": [
                    "bridge",
                    "tunnel",
                    "embankment",
                    "cutting"
                ],
                "label": "Structure",
                "strings": {
                    "options": {
                        "bridge": "Bridge",
                        "tunnel": "Tunnel",
                        "embankment": "Embankment",
                        "cutting": "Cutting"
                    }
                }
            },
            "surface": {
                "key": "surface",
                "type": "combo",
                "label": "Surface"
            },
            "tourism": {
                "key": "tourism",
                "type": "combo",
                "label": "Type"
            },
            "water": {
                "key": "water",
                "type": "combo",
                "label": "Type"
            },
            "waterway": {
                "key": "waterway",
                "type": "combo",
                "label": "Type"
            },
            "website": {
                "key": "website",
                "type": "url",
                "icon": "website",
                "placeholder": "http://example.com/",
                "universal": true,
                "label": "Website"
            },
            "wetland": {
                "key": "wetland",
                "type": "combo",
                "label": "Type"
            },
            "wheelchair": {
                "key": "wheelchair",
                "type": "radio",
                "options": [
                    "yes",
                    "limited",
                    "no"
                ],
                "icon": "wheelchair",
                "universal": true,
                "label": "Wheelchair Access"
            },
            "wikipedia": {
                "key": "wikipedia",
                "type": "text",
                "icon": "wikipedia",
                "universal": true,
                "label": "Wikipedia"
            },
            "wood": {
                "key": "wood",
                "type": "combo",
                "label": "Type"
            }
        }
    }
};iD.util = {};

iD.util.tagText = function(entity) {
    return d3.entries(entity.tags).map(function(e) {
        return e.key + '=' + e.value;
    }).join(', ');
};

iD.util.stringQs = function(str) {
    return str.split('&').reduce(function(obj, pair){
        var parts = pair.split('=');
        if (parts.length === 2) {
            obj[parts[0]] = (null === parts[1]) ? '' : decodeURIComponent(parts[1]);
        }
        return obj;
    }, {});
};

iD.util.qsString = function(obj, noencode) {
    return Object.keys(obj).sort().map(function(key) {
        return encodeURIComponent(key) + '=' + (
            noencode ? obj[key] : encodeURIComponent(obj[key]));
    }).join('&');
};

iD.util.prefixDOMProperty = function(property) {
    var prefixes = ['webkit', 'ms', 'moz', 'o'],
        i = -1,
        n = prefixes.length,
        s = document.body;

    if (property in s)
        return property;

    property = property.substr(0, 1).toUpperCase() + property.substr(1);

    while (++i < n)
        if (prefixes[i] + property in s)
            return prefixes[i] + property;

    return false;
};

iD.util.prefixCSSProperty = function(property) {
    var prefixes = ['webkit', 'ms', 'Moz', 'O'],
        i = -1,
        n = prefixes.length,
        s = document.body.style;

    if (property.toLowerCase() in s)
        return property.toLowerCase();

    while (++i < n)
        if (prefixes[i] + property in s)
            return '-' + prefixes[i].toLowerCase() + '-' + property.toLowerCase();

    return false;
};

iD.util.getStyle = function(selector) {
    for (var i = 0; i < document.styleSheets.length; i++) {
        var rules = document.styleSheets[i].rules || document.styleSheets[i].cssRules;
        for (var k = 0; k < rules.length; k++) {
            var selectorText = rules[k].selectorText && rules[k].selectorText.split(', ');
            if (_.contains(selectorText, selector)) {
                return rules[k];
            }
        }
    }
};

iD.util.editDistance = function(a, b) {
    if (a.length === 0) return b.length;
    if (b.length === 0) return a.length;
    var matrix = [];
    for (var i = 0; i <= b.length; i++) { matrix[i] = [i]; }
    for (var j = 0; j <= a.length; j++) { matrix[0][j] = j; }
    for (i = 1; i <= b.length; i++) {
        for (j = 1; j <= a.length; j++) {
            if (b.charAt(i-1) == a.charAt(j-1)) {
                matrix[i][j] = matrix[i-1][j-1];
            } else {
                matrix[i][j] = Math.min(matrix[i-1][j-1] + 1, // substitution
                    Math.min(matrix[i][j-1] + 1, // insertion
                    matrix[i-1][j] + 1)); // deletion
            }
        }
    }
    return matrix[b.length][a.length];
};

// a d3.mouse-alike which
// 1. Only works on HTML elements, not SVG
// 2. Does not cause style recalculation
iD.util.fastMouse = function(container) {
    var rect = _.clone(container.getBoundingClientRect()),
        rectLeft = rect.left,
        rectTop = rect.top,
        clientLeft = +container.clientLeft,
        clientTop = +container.clientTop;
    return function(e) {
        return [
            e.clientX - rectLeft - clientLeft,
            e.clientY - rectTop - clientTop];
    };
};

iD.util.getPrototypeOf = Object.getPrototypeOf || function(obj) { return obj.__proto__; };

iD.util.asyncMap = function(inputs, func, callback) {
    var remaining = inputs.length,
        results = [],
        errors = [];

    inputs.forEach(function(d, i) {
        func(d, function done(err, data) {
            errors[i] = err;
            results[i] = data;
            remaining --;
            if (!remaining) callback(errors, results);
        });
    });
};
iD.geo = {};

iD.geo.roundCoords = function(c) {
    return [Math.floor(c[0]), Math.floor(c[1])];
};

iD.geo.interp = function(p1, p2, t) {
    return [p1[0] + (p2[0] - p1[0]) * t,
            p1[1] + (p2[1] - p1[1]) * t];
};

// http://jsperf.com/id-dist-optimization
iD.geo.dist = function(a, b) {
    var x = a[0] - b[0], y = a[1] - b[1];
    return Math.sqrt((x * x) + (y * y));
};

iD.geo.chooseIndex = function(way, point, context) {
    var dist = iD.geo.dist,
        graph = context.graph(),
        nodes = graph.childNodes(way),
        projNodes = nodes.map(function(n) { return context.projection(n.loc); });

    for (var i = 0, changes = []; i < projNodes.length - 1; i++) {
        changes[i] =
            (dist(projNodes[i], point) + dist(point, projNodes[i + 1])) /
            dist(projNodes[i], projNodes[i + 1]);
    }

    var idx = _.indexOf(changes, _.min(changes)),
        ratio = dist(projNodes[idx], point) / dist(projNodes[idx], projNodes[idx + 1]),
        loc = iD.geo.interp(nodes[idx].loc, nodes[idx + 1].loc, ratio);

    return {
        index: idx + 1,
        loc: loc
    };
};

// Return whether point is contained in polygon.
//
// `point` should be a 2-item array of coordinates.
// `polygon` should be an array of 2-item arrays of coordinates.
//
// From https://github.com/substack/point-in-polygon.
// ray-casting algorithm based on
// http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
//
iD.geo.pointInPolygon = function(point, polygon) {
    var x = point[0],
        y = point[1],
        inside = false;

    for (var i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        var xi = polygon[i][0], yi = polygon[i][1];
        var xj = polygon[j][0], yj = polygon[j][1];

        var intersect = ((yi > y) != (yj > y)) &&
            (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
    }

    return inside;
};

iD.geo.polygonContainsPolygon = function(outer, inner) {
    return _.every(inner, function(point) {
        return iD.geo.pointInPolygon(point, outer);
    });
};

iD.geo.polygonIntersectsPolygon = function(outer, inner) {
    return _.some(inner, function(point) {
        return iD.geo.pointInPolygon(point, outer);
    });
};

iD.geo.pathLength = function(path) {
    var length = 0,
        dx, dy;
    for (var i = 0; i < path.length - 1; i++) {
        dx = path[i][0] - path[i + 1][0];
        dy = path[i][1] - path[i + 1][1];
        length += Math.sqrt(dx * dx + dy * dy);
    }
    return length;
};

iD.geo.metersToCoordinates = function(loc, vector) {
    return [vector[1] / 111200, vector[0] / 111200 / Math.abs(Math.cos(loc[1]))];
};
iD.geo.Extent = function geoExtent(min, max) {
    if (!(this instanceof iD.geo.Extent)) return new iD.geo.Extent(min, max);
    if (min instanceof iD.geo.Extent) {
        return min;
    } else if (min && min.length === 2 && min[0].length === 2 && min[1].length === 2) {
        this[0] = min[0];
        this[1] = min[1];
    } else {
        this[0] = min        || [ Infinity,  Infinity];
        this[1] = max || min || [-Infinity, -Infinity];
    }
};

iD.geo.Extent.prototype = [[], []];

_.extend(iD.geo.Extent.prototype, {
    extend: function(obj) {
        if (!(obj instanceof iD.geo.Extent)) obj = new iD.geo.Extent(obj);
        return iD.geo.Extent([Math.min(obj[0][0], this[0][0]),
                              Math.min(obj[0][1], this[0][1])],
                             [Math.max(obj[1][0], this[1][0]),
                              Math.max(obj[1][1], this[1][1])]);
    },

    center: function() {
        return [(this[0][0] + this[1][0]) / 2,
                (this[0][1] + this[1][1]) / 2];
    },

    intersects: function(obj) {
        if (!(obj instanceof iD.geo.Extent)) obj = new iD.geo.Extent(obj);
        return obj[0][0] <= this[1][0] &&
               obj[0][1] <= this[1][1] &&
               obj[1][0] >= this[0][0] &&
               obj[1][1] >= this[0][1];
    }
});
iD.actions = {};
iD.actions.AddEntity = function(way) {
    return function(graph) {
        return graph.replace(way);
    };
};
iD.actions.AddMidpoint = function(midpoint, node) {
    return function(graph) {
        graph = graph.replace(node.move(midpoint.loc));

        var parents = _.intersection(
            graph.parentWays(graph.entity(midpoint.edge[0])),
            graph.parentWays(graph.entity(midpoint.edge[1])));

        parents.forEach(function(way) {
            for (var i = 0; i < way.nodes.length - 1; i++) {
                if ((way.nodes[i]     === midpoint.edge[0] &&
                     way.nodes[i + 1] === midpoint.edge[1]) ||
                    (way.nodes[i]     === midpoint.edge[1] &&
                     way.nodes[i + 1] === midpoint.edge[0])) {
                    graph = graph.replace(graph.entity(way.id).addNode(node.id, i + 1));
                }
            }
        });

        return graph;
    };
};
// https://github.com/openstreetmap/potlatch2/blob/master/net/systemeD/halcyon/connection/actions/AddNodeToWayAction.as
iD.actions.AddVertex = function(wayId, nodeId, index) {
    return function(graph) {
        return graph.replace(graph.entity(wayId).addNode(nodeId, index));
    };
};
iD.actions.ChangeTags = function(entityId, tags) {
    return function(graph) {
        var entity = graph.entity(entityId);
        return graph.replace(entity.update({tags: tags}));
    };
};
iD.actions.Circularize = function(wayId, projection, count) {
    count = count || 12;

    function closestIndex(nodes, loc) {
        var idx, min = Infinity, dist;
        for (var i = 0; i < nodes.length; i++) {
            dist = iD.geo.dist(nodes[i].loc, loc);
            if (dist < min) {
                min = dist;
                idx = i;
            }
        }
        return idx;
    }

    var action = function(graph) {
        var way = graph.entity(wayId),
            nodes = _.uniq(graph.childNodes(way)),
            points = nodes.map(function(n) { return projection(n.loc); }),
            centroid = d3.geom.polygon(points).centroid(),
            radius = d3.median(points, function(p) {
                return iD.geo.dist(centroid, p);
            }),
            ids = [],
            sign = d3.geom.polygon(points).area() > 0 ? -1 : 1;

        for (var i = 0; i < count; i++) {
            var node,
                loc = projection.invert([
                    centroid[0] + Math.cos(sign * (i / 12) * Math.PI * 2) * radius,
                    centroid[1] + Math.sin(sign * (i / 12) * Math.PI * 2) * radius]);

            if (nodes.length) {
                var idx = closestIndex(nodes, loc);
                node = nodes[idx];
                nodes.splice(idx, 1);
            } else {
                node = iD.Node();
            }

            ids.push(node.id);
            graph = graph.replace(node.move(loc));
        }

        ids.push(ids[0]);
        way = way.update({nodes: ids});
        graph = graph.replace(way);

        for (i = 0; i < nodes.length; i++) {
            graph.parentWays(nodes[i]).forEach(function(parent) {
                graph = graph.replace(parent.replaceNode(nodes[i].id,
                    ids[closestIndex(graph.childNodes(way), nodes[i].loc)]));
            });

            graph = iD.actions.DeleteNode(nodes[i].id)(graph);
        }

        return graph;
    };

    action.enabled = function(graph) {
        return graph.entity(wayId).isClosed();
    };

    return action;
};
// Connect the ways at the given nodes.
//
// The last node will survive. All other nodes will be replaced with
// the surviving node in parent ways, and then removed.
//
// Tags and relation memberships of of non-surviving nodes are merged
// to the survivor.
//
// This is the inverse of `iD.actions.Disconnect`.
//
// Reference:
//   https://github.com/openstreetmap/potlatch2/blob/master/net/systemeD/halcyon/connection/actions/MergeNodesAction.as
//   https://github.com/openstreetmap/josm/blob/mirror/src/org/openstreetmap/josm/actions/MergeNodesAction.java
//
iD.actions.Connect = function(nodeIds) {
    var action = function(graph) {
        var survivor = graph.entity(_.last(nodeIds));

        for (var i = 0; i < nodeIds.length - 1; i++) {
            var node = graph.entity(nodeIds[i]);

            graph.parentWays(node).forEach(function(parent) {
                if (!parent.areAdjacent(node.id, survivor.id)) {
                    graph = graph.replace(parent.replaceNode(node.id, survivor.id));
                }
            });

            graph.parentRelations(node).forEach(function(parent) {
                graph = graph.replace(parent.replaceMember(node, survivor));
            });

            survivor = survivor.mergeTags(node.tags);
            graph = iD.actions.DeleteNode(node.id)(graph);
        }

        graph = graph.replace(survivor);

        return graph;
    };

    action.enabled = function() {
        return nodeIds.length > 1;
    };

    return action;
};
iD.actions.DeleteMultiple = function(ids) {
    return function(graph) {
        var actions = {
            way: iD.actions.DeleteWay,
            node: iD.actions.DeleteNode,
            relation: iD.actions.DeleteRelation
        };

        ids.forEach(function(id) {
            var entity = graph.entity(id);
            if (entity) { // It may have been deleted aready.
                graph = actions[entity.type](id)(graph);
            }
        });

        return graph;
    };
};
// https://github.com/openstreetmap/potlatch2/blob/master/net/systemeD/halcyon/connection/actions/DeleteNodeAction.as
iD.actions.DeleteNode = function(nodeId) {
    return function(graph) {
        var node = graph.entity(nodeId);

        graph.parentWays(node)
            .forEach(function(parent) {
                parent = parent.removeNode(nodeId);
                graph = graph.replace(parent);

                if (parent.isDegenerate()) {
                    graph = iD.actions.DeleteWay(parent.id)(graph);
                }
            });

        graph.parentRelations(node)
            .forEach(function(parent) {
                graph = graph.replace(parent.removeMember(nodeId));
            });

        return graph.remove(node);
    };
};
// https://github.com/openstreetmap/potlatch2/blob/master/net/systemeD/halcyon/connection/actions/DeleteRelationAction.as
iD.actions.DeleteRelation = function(relationId) {
    function deleteEntity(entity, graph) {
        return !graph.parentWays(entity).length &&
            !graph.parentRelations(entity).length &&
            !entity.hasInterestingTags();
    }

    return function(graph) {
        var relation = graph.entity(relationId);

        graph.parentRelations(relation)
            .forEach(function(parent) {
                graph = graph.replace(parent.removeMember(relationId));
            });

        _.uniq(_.pluck(relation.members, 'id')).forEach(function(memberId) {
            graph = graph.replace(relation.removeMember(memberId));

            var entity = graph.entity(memberId);
            if (deleteEntity(entity, graph)) {
                graph = iD.actions.DeleteMultiple([memberId])(graph);
            }
        });

        return graph.remove(relation);
    };
};
// https://github.com/openstreetmap/potlatch2/blob/master/net/systemeD/halcyon/connection/actions/DeleteWayAction.as
iD.actions.DeleteWay = function(wayId) {
    function deleteNode(node, graph) {
        return !graph.parentWays(node).length &&
            !graph.parentRelations(node).length &&
            !node.hasInterestingTags();
    }

    return function(graph) {
        var way = graph.entity(wayId);

        graph.parentRelations(way)
            .forEach(function(parent) {
                graph = graph.replace(parent.removeMember(wayId));
            });

        _.uniq(way.nodes).forEach(function(nodeId) {
            graph = graph.replace(way.removeNode(nodeId));

            var node = graph.entity(nodeId);
            if (deleteNode(node, graph)) {
                graph = graph.remove(node);
            }
        });

        return graph.remove(way);
    };
};
iD.actions.DeprecateTags = function(entityId) {
    return function(graph) {
        var entity = graph.entity(entityId),
            newtags = _.clone(entity.tags),
            change = false,
            rule;

        // This handles deprecated tags with a single condition
        for (var i = 0; i < iD.data.deprecated.length; i++) {

            rule = iD.data.deprecated[i];
            var match = _.pairs(rule.old)[0],
                replacements = rule.replace ? _.pairs(rule.replace) : null;

            if (entity.tags[match[0]] && match[1] === '*') {

                var value = entity.tags[match[0]];
                if (replacements && !newtags[replacements[0][0]]) {
                    newtags[replacements[0][0]] = value;
                }
                delete newtags[match[0]];
                change = true;

            } else if (entity.tags[match[0]] === match[1]) {
                newtags = _.assign({}, rule.replace || {}, _.omit(newtags, match[0]));
                change = true;
            }
        }

        if (change) {
            return graph.replace(entity.update({tags: newtags}));
        } else {
            return graph;
        }
    };
};
// Disconect the ways at the given node.
//
// For testing convenience, accepts an ID to assign to the (first) new node.
// Normally, this will be undefined and the way will automatically
// be assigned a new ID.
//
// This is the inverse of `iD.actions.Connect`.
//
// Reference:
//   https://github.com/openstreetmap/potlatch2/blob/master/net/systemeD/halcyon/connection/actions/UnjoinNodeAction.as
//   https://github.com/openstreetmap/josm/blob/mirror/src/org/openstreetmap/josm/actions/UnGlueAction.java
//
iD.actions.Disconnect = function(nodeId, newNodeId) {
    var action = function(graph) {
        if (!action.enabled(graph))
            return graph;

        var node = graph.entity(nodeId);

        graph.parentWays(node).forEach(function(parent, i) {
            if (i === 0)
                return;

            var index = parent.nodes.indexOf(nodeId),
                newNode = iD.Node({id: newNodeId, loc: node.loc, tags: node.tags});

            graph = graph.replace(newNode);
            graph = graph.replace(parent.updateNode(newNode.id, index));
        });

        return graph;
    };

    action.enabled = function(graph) {
        return graph.parentWays(graph.entity(nodeId)).length >= 2;
    };

    return action;
};
// Join ways at the end node they share.
//
// This is the inverse of `iD.actions.Split`.
//
// Reference:
//   https://github.com/systemed/potlatch2/blob/master/net/systemeD/halcyon/connection/actions/MergeWaysAction.as
//   https://github.com/openstreetmap/josm/blob/mirror/src/org/openstreetmap/josm/actions/CombineWayAction.java
//
iD.actions.Join = function(ids) {
    var idA = ids[0],
        idB = ids[1];

    function groupEntitiesByGeometry(graph) {
        var entities = ids.map(function(id) { return graph.entity(id); });
        return _.extend({line: []}, _.groupBy(entities, function(entity) { return entity.geometry(graph); }));
    }

    var action = function(graph) {
        var a = graph.entity(idA),
            b = graph.entity(idB),
            nodes;

        if (a.first() === b.first()) {
            // a <-- b ==> c
            // Expected result:
            // a <-- b <-- c
            b = iD.actions.Reverse(idB)(graph).entity(idB);
            nodes = b.nodes.slice().concat(a.nodes.slice(1));

        } else if (a.first() === b.last()) {
            // a <-- b <== c
            // Expected result:
            // a <-- b <-- c
            nodes = b.nodes.concat(a.nodes.slice(1));

        } else if (a.last()  === b.first()) {
            // a --> b ==> c
            // Expected result:
            // a --> b --> c
            nodes = a.nodes.concat(b.nodes.slice(1));

        } else if (a.last()  === b.last()) {
            // a --> b <== c
            // Expected result:
            // a --> b --> c
            b = iD.actions.Reverse(idB)(graph).entity(idB);
            nodes = a.nodes.concat(b.nodes.slice().slice(1));
        }

        graph.parentRelations(b).forEach(function(parent) {
            graph = graph.replace(parent.replaceMember(b, a));
        });

        graph = graph.replace(a.mergeTags(b.tags).update({ nodes: nodes }));
        graph = iD.actions.DeleteWay(idB)(graph);

        return graph;
    };

    action.enabled = function(graph) {
        var geometries = groupEntitiesByGeometry(graph);

        if (ids.length !== 2 || ids.length !== geometries.line.length)
            return false;

        var a = graph.entity(idA),
            b = graph.entity(idB);

        return a.first() === b.first() ||
               a.first() === b.last()  ||
               a.last()  === b.first() ||
               a.last()  === b.last();
    };

    return action;
};
iD.actions.Merge = function(ids) {
    function groupEntitiesByGeometry(graph) {
        var entities = ids.map(function(id) { return graph.entity(id); });
        return _.extend({point: [], area: [], line: [], relation: []},
            _.groupBy(entities, function(entity) { return entity.geometry(graph); }));
    }

    var action = function(graph) {
        var geometries = groupEntitiesByGeometry(graph),
            target = geometries.area[0] || geometries.line[0],
            points = geometries.point;

        points.forEach(function(point) {
            target = target.mergeTags(point.tags);

            graph.parentRelations(point).forEach(function(parent) {
                graph = graph.replace(parent.replaceMember(point, target));
            });

            graph = graph.remove(point);
        });

        graph = graph.replace(target);

        return graph;
    };

    action.enabled = function(graph) {
        var geometries = groupEntitiesByGeometry(graph);
        return geometries.point.length > 0 &&
            (geometries.area.length + geometries.line.length) === 1 &&
            geometries.relation.length === 0;
    };

    return action;
};
// https://github.com/openstreetmap/josm/blob/mirror/src/org/openstreetmap/josm/command/MoveCommand.java
// https://github.com/openstreetmap/potlatch2/blob/master/net/systemeD/halcyon/connection/actions/MoveNodeAction.as
iD.actions.Move = function(ids, delta, projection) {
    function addNodes(ids, nodes, graph) {
        ids.forEach(function(id) {
            var entity = graph.entity(id);
            if (entity.type === 'node') {
                nodes.push(id);
            } else if (entity.type === 'way') {
                nodes.push.apply(nodes, entity.nodes);
            } else {
                addNodes(_.pluck(entity.members, 'id'), nodes, graph);
            }
        });
    }

    var action = function(graph) {
        var nodes = [];

        addNodes(ids, nodes, graph);

        _.uniq(nodes).forEach(function(id) {
            var node = graph.entity(id),
                start = projection(node.loc),
                end = projection.invert([start[0] + delta[0], start[1] + delta[1]]);
            graph = graph.replace(node.move(end));
        });

        return graph;
    };

    action.enabled = function(graph) {
        return _.every(ids, function(id) {
            var entity = graph.entity(id);
            return entity.type !== 'relation' || entity.isComplete(graph);
        });
    };

    return action;
};
// https://github.com/openstreetmap/josm/blob/mirror/src/org/openstreetmap/josm/command/MoveCommand.java
// https://github.com/openstreetmap/potlatch2/blob/master/net/systemeD/halcyon/connection/actions/MoveNodeAction.as
iD.actions.MoveNode = function(nodeId, loc) {
    return function(graph) {
        return graph.replace(graph.entity(nodeId).move(loc));
    };
};
iD.actions.Noop = function() {
    return function(graph) {
        return graph;
    };
};
/*
 * Based on https://github.com/openstreetmap/potlatch2/blob/master/net/systemeD/potlatch2/tools/Quadrilateralise.as
 */

iD.actions.Orthogonalize = function(wayId, projection) {
    var action = function(graph) {
        var way = graph.entity(wayId),
            nodes = graph.childNodes(way),
            points = nodes.map(function(n) { return projection(n.loc); }),
            best, i, j;

        var score = squareness();
        for (i = 0; i < 1000; i++) {
            var motions = points.map(stepMap);
            for (j = 0; j < motions.length; j++) {
                points[j] = addPoints(points[j],motions[j]);
            }
            var newScore = squareness();
            if (newScore < score) {
                best = _.clone(points);
                score = newScore;
            }
            if (score < 1.0e-8) {
                break;
            }
        }
        points = best;

        for (i = 0; i < points.length - 1; i++) {
            graph = graph.replace(graph.entity(nodes[i].id)
                .move(projection.invert(points[i])));
        }

        return graph;

        function stepMap(b, i, array) {
            var a = array[(i - 1 + array.length) % array.length],
                c = array[(i + 1) % array.length],
                p = subtractPoints(a, b),
                q = subtractPoints(c, b);

            var scale = iD.geo.dist(p, [0, 0]) + iD.geo.dist(q, [0, 0]);
            p = normalizePoint(p, 1.0);
            q = normalizePoint(q, 1.0);

            var dotp = p[0] * q[0] + p[1] * q[1];
            // nasty hack to deal with almost-straight segments (angle is closer to 180 than to 90/270).
            if (dotp < -0.707106781186547) {
                dotp += 1.0;
            }

            return normalizePoint(addPoints(p, q), 0.1 * dotp * scale);
        }

        function squareness() {
            var g = 0.0;
            for (var i = 1; i < points.length - 1; i++) {
                var score = scoreOfPoints(points[i - 1], points[i], points[i + 1]);
                g += score;
            }
            var startScore = scoreOfPoints(points[points.length - 1], points[0], points[1]);
            var endScore = scoreOfPoints(points[points.length - 2], points[points.length - 1], points[0]);
            g += startScore;
            g += endScore;
            return g;
        }

        function scoreOfPoints(a, b, c) {
            var p = subtractPoints(a, b),
                q = subtractPoints(c, b);

            p = normalizePoint(p, 1.0);
            q = normalizePoint(q, 1.0);

            var dotp = p[0] * q[0] + p[1] * q[1];
            // score is constructed so that +1, -1 and 0 are all scored 0, any other angle
            // is scored higher.
            return 2.0 * Math.min(Math.abs(dotp - 1.0), Math.min(Math.abs(dotp), Math.abs(dotp + 1)));
        }

        function subtractPoints(a, b) {
            return [a[0] - b[0], a[1] - b[1]];
        }

        function addPoints(a, b) {
            return [a[0] + b[0], a[1] + b[1]];
        }

        function normalizePoint(point, thickness) {
            var vector = [0, 0];
            var length = Math.sqrt(point[0] * point[0] + point[1] * point[1]);
            if (length !== 0) {
                vector[0] = point[0] / length;
                vector[1] = point[1] / length;
            }

            vector[0] *= thickness;
            vector[1] *= thickness;

            return vector;
        }
    };

    action.enabled = function(graph) {
        return graph.entity(wayId).isClosed();
    };

    return action;
};
/*
  Order the nodes of a way in reverse order and reverse any direction dependent tags
  other than `oneway`. (We assume that correcting a backwards oneway is the primary
  reason for reversing a way.)

  The following transforms are performed:

    Keys:
          *:right=* ⟺ *:left=*
        *:forward=* ⟺ *:backward=*
       direction=up ⟺ direction=down
         incline=up ⟺ incline=down
            *=right ⟺ *=left

    Relation members:
       role=forward ⟺ role=backward

   In addition, numeric-valued `incline` tags are negated.

   The JOSM implementation was used as a guide, but transformations that were of unclear benefit
   or adjusted tags that don't seem to be used in practice were omitted.

   References:
      http://wiki.openstreetmap.org/wiki/Forward_%26_backward,_left_%26_right
      http://wiki.openstreetmap.org/wiki/Key:direction#Steps
      http://wiki.openstreetmap.org/wiki/Key:incline
      http://wiki.openstreetmap.org/wiki/Route#Members
      http://josm.openstreetmap.de/browser/josm/trunk/src/org/openstreetmap/josm/corrector/ReverseWayTagCorrector.java
 */
iD.actions.Reverse = function(wayId) {
    var replacements = [
        [/:right$/, ':left'], [/:left$/, ':right'],
        [/:forward$/, ':backward'], [/:backward$/, ':forward']
    ], numeric = /^([+\-]?)(?=[\d.])/;

    function reverseKey(key) {
        for (var i = 0; i < replacements.length; ++i) {
            var replacement = replacements[i];
            if (replacement[0].test(key)) {
                return key.replace(replacement[0], replacement[1]);
            }
        }
        return key;
    }

    function reverseValue(key, value) {
        if (key === "incline" && numeric.test(value)) {
            return value.replace(numeric, function(_, sign) { return sign === '-' ? '' : '-'; });
        } else if (key === "incline" || key === "direction") {
            return {up: 'down', down: 'up'}[value] || value;
        } else {
            return {left: 'right', right: 'left'}[value] || value;
        }
    }

    return function(graph) {
        var way = graph.entity(wayId),
            nodes = way.nodes.slice().reverse(),
            tags = {}, key, role;

        for (key in way.tags) {
            tags[reverseKey(key)] = reverseValue(key, way.tags[key]);
        }

        graph.parentRelations(way).forEach(function(relation) {
            relation.members.forEach(function(member, index) {
                if (member.id === way.id && (role = {forward: 'backward', backward: 'forward'}[member.role])) {
                    relation = relation.updateMember({role: role}, index);
                    graph = graph.replace(relation);
                }
            });
        });

        return graph.replace(way.update({nodes: nodes, tags: tags}));
    };
};
iD.actions.RotateWay = function(wayId, pivot, angle, projection) {
    return function(graph) {
        return graph.update(function(graph) {
            var way = graph.entity(wayId);

            _.unique(way.nodes).forEach(function(id) {

                var node = graph.entity(id),
                    point = projection(node.loc),
                    radial = [0,0];

                radial[0] = point[0] - pivot[0];
                radial[1] = point[1] - pivot[1];

                point = [
                    radial[0] * Math.cos(angle) - radial[1] * Math.sin(angle) + pivot[0],
                    radial[0] * Math.sin(angle) + radial[1] * Math.cos(angle) + pivot[1]
                ];

                graph = graph.replace(node.move(projection.invert(point)));

            });

        });
    };
};
// Split a way at the given node.
//
// This is the inverse of `iD.actions.Join`.
//
// For testing convenience, accepts an ID to assign to the new way.
// Normally, this will be undefined and the way will automatically
// be assigned a new ID.
//
// Reference:
//   https://github.com/systemed/potlatch2/blob/master/net/systemeD/halcyon/connection/actions/SplitWayAction.as
//
iD.actions.Split = function(nodeId, newWayId) {
    function candidateWays(graph) {
        var node = graph.entity(nodeId),
            parents = graph.parentWays(node);

        return parents.filter(function(parent) {
            return parent.isClosed() ||
                (parent.first() !== nodeId &&
                 parent.last()  !== nodeId);
        });
    }

    var action = function(graph) {
        var wayA = candidateWays(graph)[0],
            wayB = iD.Way({id: newWayId, tags: wayA.tags}),
            nodesA,
            nodesB,
            isArea = wayA.isArea();

        if (wayA.isClosed()) {
            var nodes = wayA.nodes.slice(0, -1),
                idxA = _.indexOf(nodes, nodeId),
                idxB = idxA + Math.floor(nodes.length / 2);

            if (idxB >= nodes.length) {
                idxB %= nodes.length;
                nodesA = nodes.slice(idxA).concat(nodes.slice(0, idxB + 1));
                nodesB = nodes.slice(idxB, idxA + 1);
            } else {
                nodesA = nodes.slice(idxA, idxB + 1);
                nodesB = nodes.slice(idxB).concat(nodes.slice(0, idxA + 1));
            }
        } else {
            var idx = _.indexOf(wayA.nodes, nodeId);
            nodesA = wayA.nodes.slice(0, idx + 1);
            nodesB = wayA.nodes.slice(idx);
        }

        wayA = wayA.update({nodes: nodesA});
        wayB = wayB.update({nodes: nodesB});

        graph = graph.replace(wayA);
        graph = graph.replace(wayB);

        graph.parentRelations(wayA).forEach(function(relation) {
            if (relation.isRestriction()) {
                var via = relation.memberByRole('via');
                if (via && wayB.contains(via.id)) {
                    relation = relation.updateMember({id: wayB.id}, relation.memberById(wayA.id).index);
                    graph = graph.replace(relation);
                }
            } else {
                var role = relation.memberById(wayA.id).role,
                    last = wayB.last(),
                    i = relation.memberById(wayA.id).index,
                    j;

                for (j = 0; j < relation.members.length; j++) {
                    var entity = graph.entity(relation.members[j].id);
                    if (entity && entity.type === 'way' && entity.contains(last)) {
                        break;
                    }
                }

                relation = relation.addMember({id: wayB.id, type: 'way', role: role}, i <= j ? i + 1 : i);
                graph = graph.replace(relation);
            }
        });

        if (isArea) {
            var multipolygon = iD.Relation({
                tags: _.extend({}, wayA.tags, {type: 'multipolygon'}),
                members: [
                    {id: wayA.id, role: 'outer', type: 'way'},
                    {id: wayB.id, role: 'outer', type: 'way'}
                ]});

            graph = graph.replace(multipolygon);
            graph = graph.replace(wayA.update({tags: {}}));
            graph = graph.replace(wayB.update({tags: {}}));
        }

        return graph;
    };

    action.enabled = function(graph) {
        return candidateWays(graph).length === 1;
    };

    return action;
};
iD.behavior = {};
iD.behavior.accept = function() {
    var event = d3.dispatch('accept'),
        keybinding = d3.keybinding('accept');

    function accept(selection) {
        keybinding.on('↩', function() {
            event.accept();
        })(selection);
    }

    return d3.rebind(accept, event, "on");
};
iD.behavior.AddWay = function(context) {
    var event = d3.dispatch('start', 'startFromWay', 'startFromNode'),
        draw = iD.behavior.Draw(context);

    var addWay = function(surface) {
        draw.on('click', event.start)
            .on('clickWay', event.startFromWay)
            .on('clickNode', event.startFromNode)
            .on('cancel', addWay.cancel)
            .on('finish', addWay.cancel);

        context.map()
            .minzoom(16)
            .dblclickEnable(false);

        surface.call(draw);
    };

    addWay.off = function(surface) {
        context.map()
            .minzoom(0)
            .tail(false);

        surface.call(draw.off);
    };

    addWay.cancel = function() {

        window.setTimeout(function() {
            context.map().dblclickEnable(true);
        }, 1000);

        context.enter(iD.modes.Browse(context));
    };

    return d3.rebind(addWay, event, 'on');
};
/*
    `iD.behavior.drag` is like `d3.behavior.drag`, with the following differences:

    * The `origin` function is expected to return an [x, y] tuple rather than an
      {x, y} object.
    * The events are `start`, `move`, and `end`.
      (https://github.com/mbostock/d3/issues/563)
    * The `start` event is not dispatched until the first cursor movement occurs.
      (https://github.com/mbostock/d3/pull/368)
    * The `move` event has a `point` and `delta` [x, y] tuple properties rather
      than `x`, `y`, `dx`, and `dy` properties.
    * The `end` event is not dispatched if no movement occurs.
    * An `off` function is available that unbinds the drag's internal event handlers.
    * Delegation is supported via the `delegate` function.

 */
iD.behavior.drag = function() {
    function d3_eventCancel() {
      d3.event.stopPropagation();
      d3.event.preventDefault();
    }

    var event = d3.dispatch("start", "move", "end"),
        origin = null,
        selector = '',
        filter = null,
        event_, target, surface;

    event.of = function(thiz, argumentz) {
      return function(e1) {
        try {
          var e0 = e1.sourceEvent = d3.event;
          e1.target = drag;
          d3.event = e1;
          event[e1.type].apply(thiz, argumentz);
        } finally {
          d3.event = e0;
        }
      };
    };

    function mousedown() {
        target = this,
        event_ = event.of(target, arguments);
        var eventTarget = d3.event.target,
            touchId = d3.event.touches ? d3.event.changedTouches[0].identifier : null,
            offset,
            origin_ = point(),
            moved = 0;

        var w = d3.select(window)
            .on(touchId !== null ? "touchmove.drag-" + touchId : "mousemove.drag", dragmove)
            .on(touchId !== null ? "touchend.drag-" + touchId : "mouseup.drag", dragend, true);

        if (origin) {
            offset = origin.apply(target, arguments);
            offset = [offset[0] - origin_[0], offset[1] - origin_[1]];
        } else {
            offset = [0, 0];
        }

        if (touchId === null) d3_eventCancel();

        function point() {
            var p = target.parentNode || surface;
            return touchId !== null ? d3.touches(p).filter(function(p) {
                return p.identifier === touchId;
            })[0] : d3.mouse(p);
        }

        function dragmove() {

            var p = point(),
                dx = p[0] - origin_[0],
                dy = p[1] - origin_[1];

            if (!moved) {
                event_({
                    type: "start"
                });
            }

            moved |= dx | dy;
            origin_ = p;
            d3_eventCancel();

            event_({
                type: "move",
                point: [p[0] + offset[0],  p[1] + offset[1]],
                delta: [dx, dy]
            });
        }

        function dragend() {
            if (moved) {
                event_({
                    type: "end"
                });

                d3_eventCancel();
                if (d3.event.target === eventTarget) w.on("click.drag", click, true);
            }

            w.on(touchId !== null ? "touchmove.drag-" + touchId : "mousemove.drag", null)
                .on(touchId !== null ? "touchend.drag-" + touchId : "mouseup.drag", null);
        }

        function click() {
            d3_eventCancel();
            w.on("click.drag", null);
        }
    }

    function drag(selection) {
        var matchesSelector = iD.util.prefixDOMProperty('matchesSelector'),
            delegate = mousedown;

        if (selector) {
            delegate = function() {
                var root = this,
                    target = d3.event.target;
                for (; target && target !== root; target = target.parentNode) {
                    if (target[matchesSelector](selector) &&
                            (!filter || filter(target.__data__))) {
                        return mousedown.call(target, target.__data__);
                    }
                }
            };
        }

        selection.on("mousedown.drag" + selector, delegate)
            .on("touchstart.drag" + selector, delegate);
    }

    drag.off = function(selection) {
        selection.on("mousedown.drag" + selector, null)
            .on("touchstart.drag" + selector, null);
    };

    drag.delegate = function(_) {
        if (!arguments.length) return selector;
        selector = _;
        return drag;
    };

    drag.filter = function(_) {
        if (!arguments.length) return origin;
        filter = _;
        return drag;
    };

    drag.origin = function (_) {
        if (!arguments.length) return origin;
        origin = _;
        return drag;
    };

    drag.cancel = function() {
        d3.select(window)
            .on("mousemove.drag", null)
            .on("mouseup.drag", null);
        return drag;
    };

    drag.target = function() {
        if (!arguments.length) return target;
        target = arguments[0];
        event_ = event.of(target, Array.prototype.slice.call(arguments, 1));
        return drag;
    };

    drag.surface = function() {
        if (!arguments.length) return surface;
        surface = arguments[0];
        return drag;
    };

    return d3.rebind(drag, event, "on");
};
iD.behavior.Draw = function(context) {
    var event = d3.dispatch('move', 'click', 'clickWay',
        'clickNode', 'undo', 'cancel', 'finish'),
        keybinding = d3.keybinding('draw'),
        hover = iD.behavior.Hover().altDisables(true),
        closeTolerance = 4,
        tolerance = 12;

    function datum() {
        if (d3.event.altKey) return {};
        else return d3.event.target.__data__ || {};
    }

    function mousedown() {

        function point() {
            var p = element.node().parentNode;
            return touchId !== null ? d3.touches(p).filter(function(p) {
                return p.identifier === touchId;
            })[0] : d3.mouse(p);
        }

        var eventTarget = d3.event.target,
            element = d3.select(this),
            touchId = d3.event.touches ? d3.event.changedTouches[0].identifier : null,
            time = +new Date(),
            pos = point();

        element.on('mousemove.draw', null);

        d3.select(window).on('mouseup.draw', function() {
            element.on('mousemove.draw', mousemove);
            if (iD.geo.dist(pos, point()) < closeTolerance ||
                (iD.geo.dist(pos, point()) < tolerance &&
                (+new Date() - time) < 500)) {
                click();
            }
            if (eventTarget === d3.event.target)  {
                d3.select(window).on('click.draw', function() {
                    d3.select(window).on('click.draw', null);
                    d3.event.stopPropagation();
                }, true);
            }
        });
    }

    function mousemove() {
        event.move(datum());
    }

    function click() {
        var d = datum();
        if (d.type === 'way') {
            var choice = iD.geo.chooseIndex(d, d3.mouse(context.surface().node()), context);
            event.clickWay(d, choice.loc, choice.index);

        } else if (d.type === 'node') {
            event.clickNode(d);

        } else {
            event.click(context.map().mouseCoordinates());
        }
    }

    function backspace() {
        d3.event.preventDefault();
        event.undo();
    }

    function del() {
        d3.event.preventDefault();
        event.cancel();
    }

    function ret() {
        d3.event.preventDefault();
        event.finish();
    }

    function draw(selection) {
        context.install(hover);

        keybinding
            .on('⌫', backspace)
            .on('⌦', del)
            .on('⎋', ret)
            .on('↩', ret);

        selection
            .on('mousedown.draw', mousedown)
            .on('mousemove.draw', mousemove);

        d3.select(document)
            .call(keybinding);

        return draw;
    }

    draw.off = function(selection) {
        context.uninstall(hover);

        selection
            .on('mousedown.draw', null)
            .on('mousemove.draw', null);

        d3.select(window)
            .on('mouseup.draw', null);

        d3.select(document)
            .call(keybinding.off);
    };

    return d3.rebind(draw, event, 'on');
};
iD.behavior.DrawWay = function(context, wayId, index, mode, baseGraph) {
    var way = context.entity(wayId),
        isArea = way.geometry() === 'area',
        finished = false,
        annotation = t((way.isDegenerate() ?
            'operations.start.annotation.' :
            'operations.continue.annotation.') + context.geometry(wayId)),
        draw = iD.behavior.Draw(context);

    var startIndex = typeof index === 'undefined' ? way.nodes.length - 1 : 0,
        start = iD.Node({loc: context.graph().entity(way.nodes[startIndex]).loc}),
        end = iD.Node({loc: context.map().mouseCoordinates()}),
        segment = iD.Way({
            nodes: [start.id, end.id],
            tags: _.clone(way.tags)
        });

    var f = context[way.isDegenerate() ? 'replace' : 'perform'];
    if (isArea) {
        f(iD.actions.AddEntity(end),
            iD.actions.AddVertex(wayId, end.id, index));
    } else {
        f(iD.actions.AddEntity(start),
            iD.actions.AddEntity(end),
            iD.actions.AddEntity(segment));
    }

    function move(datum) {
        var loc = context.map().mouseCoordinates();

        if (datum.id === end.id || datum.id === segment.id) {
            context.surface().selectAll('.way, .node')
                .filter(function(d) {
                    return d.id === end.id || d.id === segment.id;
                })
                .classed('active', true);
        } else if (datum.type === 'node') {
            loc = datum.loc;
        } else if (datum.type === 'way') {
            loc = iD.geo.chooseIndex(datum, d3.mouse(context.surface().node()), context).loc;
        }

        context.replace(iD.actions.MoveNode(end.id, loc));
    }

    function undone() {
        context.enter(iD.modes.Browse(context));
    }

    function lineActives(d) {
        return d.id === segment.id || d.id === start.id || d.id === end.id;
    }

    function areaActives(d) {
        return d.id === wayId || d.id === end.id;
    }

    var drawWay = function(surface) {
        draw.on('move', move)
            .on('click', drawWay.add)
            .on('clickWay', drawWay.addWay)
            .on('clickNode', drawWay.addNode)
            .on('undo', context.undo)
            .on('cancel', drawWay.cancel)
            .on('finish', drawWay.finish);

        context.map()
            .minzoom(16)
            .dblclickEnable(false);

        surface.call(draw)
          .selectAll('.way, .node')
            .filter(isArea ? areaActives : lineActives)
            .classed('active', true);

        context.history()
            .on('undone.draw', undone);
    };

    drawWay.off = function(surface) {
        if (!finished)
            context.pop();

        context.map()
            .minzoom(0)
            .tail(false);

        surface.call(draw.off)
          .selectAll('.way, .node')
            .classed('active', false);

        context.history()
            .on('undone.draw', null);
    };

    function ReplaceTemporaryNode(newNode) {
        return function(graph) {
            if (isArea) {
                return graph
                    .replace(way.removeNode(end.id).addNode(newNode.id, index))
                    .remove(end);

            } else {
                return graph
                    .replace(graph.entity(wayId).addNode(newNode.id, index))
                    .remove(end)
                    .remove(segment)
                    .remove(start);
            }
        };
    }

    // Accept the current position of the temporary node and continue drawing.
    drawWay.add = function(loc) {
        var newNode = iD.Node({loc: loc});

        context.replace(
            iD.actions.AddEntity(newNode),
            ReplaceTemporaryNode(newNode),
            annotation);

        finished = true;
        context.enter(mode);
    };

    // Connect the way to an existing way.
    drawWay.addWay = function(way, loc, wayIndex) {
        var newNode = iD.Node({loc: loc});

        context.perform(
            iD.actions.AddEntity(newNode),
            iD.actions.AddVertex(way.id, newNode.id, wayIndex),
            ReplaceTemporaryNode(newNode),
            annotation);

        finished = true;
        context.enter(mode);
    };

    // Connect the way to an existing node and continue drawing.
    drawWay.addNode = function(node) {

        // Avoid creating duplicate segments
        if (way.areAdjacent(node.id, way.nodes[way.nodes.length - 1])) return;

        context.perform(
            ReplaceTemporaryNode(node),
            annotation);

        finished = true;
        context.enter(mode);
    };

    // Finish the draw operation, removing the temporary node. If the way has enough
    // nodes to be valid, it's selected. Otherwise, return to browse mode.
    drawWay.finish = function() {
        context.pop();
        finished = true;

        window.setTimeout(function() {
            context.map().dblclickEnable(true);
        }, 1000);

        var way = context.entity(wayId);
        if (way) {
            context.enter(iD.modes.Select(context, [way.id], true));
        } else {
            context.enter(iD.modes.Browse(context));
        }
    };

    // Cancel the draw operation and return to browse, deleting everything drawn.
    drawWay.cancel = function() {
        context.perform(
            d3.functor(baseGraph),
            t('operations.cancel_draw.annotation'));

        window.setTimeout(function() {
            context.map().dblclickEnable(true);
        }, 1000);

        finished = true;
        context.enter(iD.modes.Browse(context));
    };

    return drawWay;
};
iD.behavior.Hash = function(context) {
    var s0 = null, // cached location.hash
        lat = 90 - 1e-8; // allowable latitude range

    var parser = function(map, s) {
        var q = iD.util.stringQs(s);
        var args = (q.map || '').split("/").map(Number);
        if (args.length < 3 || args.some(isNaN)) {
            return true; // replace bogus hash
        } else if (s !== formatter(map).slice(1)) {
            map.centerZoom([args[1],
                Math.min(lat, Math.max(-lat, args[2]))], args[0]);
        }
    };

    var formatter = function(map) {
        var center = map.center(),
            zoom = map.zoom(),
            precision = Math.max(0, Math.ceil(Math.log(zoom) / Math.LN2));
        var q = iD.util.stringQs(location.hash.substring(1));
        return '#' + iD.util.qsString(_.assign(q, {
                map: zoom.toFixed(2) +
                    '/' + center[0].toFixed(precision) +
                    '/' + center[1].toFixed(precision)
            }), true);
    };

    var move = _.throttle(function() {
        var s1 = formatter(context.map());
        if (s0 !== s1) location.replace(s0 = s1); // don't recenter the map!
    }, 500);

    function hashchange() {
        if (location.hash === s0) return; // ignore spurious hashchange events
        if (parser(context.map(), (s0 = location.hash).substring(1))) {
            move(); // replace bogus hash
        }
    }

    // the hash can declare that the map should select a feature, but it can
    // do so before any features are loaded. thus wait for the feature to
    // be loaded and then select
    function willselect(id) {
        context.map().on('drawn.hash', function() {
            if (!context.entity(id)) return;
            selectoff();
            context.enter(iD.modes.Select(context, [id]));
        });

        context.on('enter.hash', function() {
            if (context.mode().id !== 'browse') selectoff();
        });
    }

    function selectoff() {
        context.map().on('drawn.hash', null);
    }

    function hash() {
        context.map()
            .on('move.hash', move);

        d3.select(window)
            .on('hashchange.hash', hashchange);

        if (location.hash) {
            var q = iD.util.stringQs(location.hash.substring(1));
            if (q.id) willselect(q.id);
            hashchange();
            if (q.map) hash.hadHash = true;
        }
    }

    hash.off = function() {
        context.map()
            .on('move.hash', null);

        d3.select(window)
            .on('hashchange.hash', null);

        location.hash = "";
    };

    return hash;
};
/*
   The hover behavior adds the `.hover` class on mouseover to all elements to which
   the identical datum is bound, and removes it on mouseout.

   The :hover pseudo-class is insufficient for iD's purposes because a datum's visual
   representation may consist of several elements scattered throughout the DOM hierarchy.
   Only one of these elements can have the :hover pseudo-class, but all of them will
   have the .hover class.
 */
iD.behavior.Hover = function() {
    var selection,
        altDisables;

    function keydown() {
        if (altDisables && d3.event.keyCode === d3.keybinding.modifierCodes.alt) {
            selection.classed('behavior-hover', false);
        }
    }

    function keyup() {
        if (altDisables && d3.event.keyCode === d3.keybinding.modifierCodes.alt) {
            selection.classed('behavior-hover', true);
        }
    }

    var hover = function(_) {
        selection = _;

        if (!altDisables || !d3.event || !d3.event.altKey) {
            selection.classed('behavior-hover', true);
        }

        function mouseover() {
            var datum = d3.event.target.__data__;
            if (datum) {
                selection.selectAll('*')
                    .filter(function(d) { return d === datum; })
                    .classed('hover', true);
            }
        }

        selection.on('mouseover.hover', mouseover);

        selection.on('mouseout.hover', function() {
            selection.selectAll('.hover')
                .classed('hover', false);
        });

        d3.select(document)
            .on('keydown.hover', keydown)
            .on('keyup.hover', keyup);
    };

    hover.off = function(selection) {
        selection.classed('behavior-hover', false)
            .on('mouseover.hover', null)
            .on('mouseout.hover', null);

        selection.selectAll('.hover')
            .classed('hover', false);

        d3.select(document)
            .on('keydown.hover', null)
            .on('keyup.hover', null);
    };

    hover.altDisables = function(_) {
        if (!arguments.length) return altDisables;
        altDisables = _;
        return hover;
    };

    return hover;
};
iD.behavior.Lasso = function(context) {

    var behavior = function(selection) {

        var mouse = null,
            lasso;

        function mousedown() {
            if (d3.event.shiftKey === true) {

                mouse = d3.mouse(context.surface().node());
                lasso = null;

                selection
                    .on('mousemove.lasso', mousemove)
                    .on('mouseup.lasso', mouseup);

                d3.event.stopPropagation();
                d3.event.preventDefault();

            }
        }

        function mousemove() {
            if (!lasso) {
                lasso = iD.ui.Lasso().a(mouse);
                context.surface().call(lasso);
            }

            lasso.b(d3.mouse(context.surface().node()));
        }

        function normalize(a, b) {
            return [
                [Math.min(a[0], b[0]), Math.min(a[1], b[1])],
                [Math.max(a[0], b[0]), Math.max(a[1], b[1])]];
        }

        function mouseup() {

            selection
                .on('mousemove.lasso', null)
                .on('mouseup.lasso', null);

            if (!lasso) return;

            var extent = iD.geo.Extent(
                normalize(context.projection.invert(lasso.a()),
                context.projection.invert(lasso.b())));

            lasso.close();

            var selected = context.intersects(extent).filter(function (entity) {
                return entity.type === 'node';
            });

            if (selected.length) {
                context.enter(iD.modes.Select(context, _.pluck(selected, 'id')));
            }
        }

        selection
            .on('mousedown.lasso', mousedown);
    };

    behavior.off = function(selection) {
        selection.on('mousedown.lasso', null);
    };

    return behavior;
};
iD.behavior.Select = function(context) {
    function keydown() {
        if (d3.event && d3.event.shiftKey) {
            context.surface()
                .classed('behavior-multiselect', true);
        }
    }

    function keyup() {
        if (!d3.event || !d3.event.shiftKey) {
            context.surface()
                .classed('behavior-multiselect', false);
        }
    }

    function click() {
        var datum = d3.event.target.__data__;
        if (!(datum instanceof iD.Entity)) {
            if (!d3.event.shiftKey)
                context.enter(iD.modes.Browse(context));

        } else if (!d3.event.shiftKey) {
            // Avoid re-entering Select mode with same entity.
            if (context.selection().length !== 1 || context.selection()[0] !== datum.id) {
                context.enter(iD.modes.Select(context, [datum.id]));
            } else {
                context.mode().reselect();
            }
        } else if (context.selection().indexOf(datum.id) >= 0) {
            var selection = _.without(context.selection(), datum.id);
            context.enter(selection.length ?
                iD.modes.Select(context, selection) :
                iD.modes.Browse(context));

        } else {
            context.enter(iD.modes.Select(context, context.selection().concat([datum.id])));
        }
    }

    var behavior = function(selection) {
        d3.select(window)
            .on('keydown.select', keydown)
            .on('keyup.select', keyup);

        selection.on('click.select', click);

        keydown();
    };

    behavior.off = function(selection) {
        d3.select(window)
            .on('keydown.select', null)
            .on('keyup.select', null);

        selection.on('click.select', null);

        keyup();
    };

    return behavior;
};
iD.modes = {};
iD.modes.AddArea = function(context) {
    var mode = {
        id: 'add-area',
        button: 'area',
        title: t('modes.add_area.title'),
        description: t('modes.add_area.description'),
        key: '3'
    };

    var behavior = iD.behavior.AddWay(context)
            .on('start', start)
            .on('startFromWay', startFromWay)
            .on('startFromNode', startFromNode),
        defaultTags = {area: 'yes'};

    function start(loc) {
        var graph = context.graph(),
            node = iD.Node({loc: loc}),
            way = iD.Way({tags: defaultTags});

        context.perform(
            iD.actions.AddEntity(node),
            iD.actions.AddEntity(way),
            iD.actions.AddVertex(way.id, node.id),
            iD.actions.AddVertex(way.id, node.id));

        context.enter(iD.modes.DrawArea(context, way.id, graph));
    }

    function startFromWay(other, loc, index) {
        var graph = context.graph(),
            node = iD.Node({loc: loc}),
            way = iD.Way({tags: defaultTags});

        context.perform(
            iD.actions.AddEntity(node),
            iD.actions.AddEntity(way),
            iD.actions.AddVertex(way.id, node.id),
            iD.actions.AddVertex(way.id, node.id),
            iD.actions.AddVertex(other.id, node.id, index));

        context.enter(iD.modes.DrawArea(context, way.id, graph));
    }

    function startFromNode(node) {
        var graph = context.graph(),
            way = iD.Way({tags: defaultTags});

        context.perform(
            iD.actions.AddEntity(way),
            iD.actions.AddVertex(way.id, node.id),
            iD.actions.AddVertex(way.id, node.id));

        context.enter(iD.modes.DrawArea(context, way.id, graph));
    }

    mode.enter = function() {
        context.install(behavior);
        context.tail(t('modes.add_area.tail'));
    };

    mode.exit = function() {
        context.uninstall(behavior);
    };

    return mode;
};
iD.modes.AddLine = function(context) {
    var mode = {
        id: 'add-line',
        button: 'line',
        title: t('modes.add_line.title'),
        description: t('modes.add_line.description'),
        key: '2'
    };

    var behavior = iD.behavior.AddWay(context)
            .on('start', start)
            .on('startFromWay', startFromWay)
            .on('startFromNode', startFromNode);

    function start(loc) {
        var graph = context.graph(),
            node = iD.Node({loc: loc}),
            way = iD.Way();

        context.perform(
            iD.actions.AddEntity(node),
            iD.actions.AddEntity(way),
            iD.actions.AddVertex(way.id, node.id));

        context.enter(iD.modes.DrawLine(context, way.id, 'forward', graph));
    }

    function startFromWay(other, loc, index) {
        var graph = context.graph(),
            node = iD.Node({loc: loc}),
            way = iD.Way();

        context.perform(
            iD.actions.AddEntity(node),
            iD.actions.AddEntity(way),
            iD.actions.AddVertex(way.id, node.id),
            iD.actions.AddVertex(other.id, node.id, index));

        context.enter(iD.modes.DrawLine(context, way.id, 'forward', graph));
    }

    function startFromNode(node) {
        var graph = context.graph(),
            parent = graph.parentWays(node)[0],
            isLine = parent && parent.geometry(graph) === 'line';

        if (isLine && parent.first() === node.id) {
            context.enter(iD.modes.DrawLine(context, parent.id, 'backward', graph));

        } else if (isLine && parent.last() === node.id) {
            context.enter(iD.modes.DrawLine(context, parent.id, 'forward', graph));

        } else {
            var way = iD.Way();

            context.perform(
                iD.actions.AddEntity(way),
                iD.actions.AddVertex(way.id, node.id));

            context.enter(iD.modes.DrawLine(context, way.id, 'forward', graph));
        }
    }

    mode.enter = function() {
        context.install(behavior);
        context.tail(t('modes.add_line.tail'));
    };

    mode.exit = function() {
        context.uninstall(behavior);
    };

    return mode;
};
iD.modes.AddPoint = function(context) {
    var mode = {
        id: 'add-point',
        title: t('modes.add_point.title'),
        description: t('modes.add_point.description'),
        key: '1'
    };

    var behavior = iD.behavior.Draw(context)
        .on('click', add)
        .on('clickWay', addWay)
        .on('clickNode', addNode)
        .on('cancel', cancel)
        .on('finish', cancel);

    function add(loc) {
        var node = iD.Node({loc: loc});

        context.perform(
            iD.actions.AddEntity(node),
            t('operations.add.annotation.point'));

        context.enter(iD.modes.Select(context, [node.id], true));
    }

    function addWay(way, loc, index) {
        add(loc);
    }

    function addNode(node) {
        add(node.loc);
    }

    function cancel() {
        context.enter(iD.modes.Browse(context));
    }

    mode.enter = function() {
        context.install(behavior);
        context.tail(t('modes.add_point.tail'));
    };

    mode.exit = function() {
        context.uninstall(behavior);
        context.tail(false);
    };

    return mode;
};
iD.modes.Browse = function(context) {
    var mode = {
        button: 'browse',
        id: 'browse',
        title: t('modes.browse.title'),
        description: t('modes.browse.description'),
        key: '1'
    };

    var behaviors = [
        iD.behavior.Hover(),
        iD.behavior.Select(context),
        iD.behavior.Lasso(context),
        iD.modes.DragNode(context).behavior];

    mode.enter = function() {
        behaviors.forEach(function(behavior) {
            context.install(behavior);
        });
    };

    mode.exit = function() {
        behaviors.forEach(function(behavior) {
            context.uninstall(behavior);
        });
    };

    return mode;
};
iD.modes.DragNode = function(context) {
    var mode = {
        id: 'drag-node',
        button: 'browse'
    };

    var nudgeInterval,
        activeIDs,
        wasMidpoint,
        cancelled,
        hover = iD.behavior.Hover().altDisables(true);

    function edge(point, size) {
        var pad = [30, 100, 30, 100];
        if (point[0] > size[0] - pad[0]) return [-10, 0];
        else if (point[0] < pad[2]) return [10, 0];
        else if (point[1] > size[1] - pad[1]) return [0, -10];
        else if (point[1] < pad[3]) return [0, 10];
        return null;
    }

    function startNudge(nudge) {
        if (nudgeInterval) window.clearInterval(nudgeInterval);
        nudgeInterval = window.setInterval(function() {
            context.pan(nudge);
        }, 50);
    }

    function stopNudge() {
        if (nudgeInterval) window.clearInterval(nudgeInterval);
        nudgeInterval = null;
    }

    function moveAnnotation(entity) {
        return t('operations.move.annotation.' + entity.geometry(context.graph()));
    }

    function connectAnnotation(datum) {
        return t('operations.connect.annotation.' + datum.geometry(context.graph()));
    }

    function origin(entity) {
        return context.projection(entity.loc);
    }

    function start(entity) {
        cancelled = d3.event.sourceEvent.shiftKey;
        if (cancelled) return behavior.cancel();

        wasMidpoint = entity.type === 'midpoint';
        if (wasMidpoint) {
            var midpoint = entity;
            entity = iD.Node();
            context.perform(iD.actions.AddMidpoint(midpoint, entity));

             var vertex = context.surface()
                .selectAll('.vertex')
                .filter(function(d) { return d.id === entity.id; });
             behavior.target(vertex.node(), entity);

        } else {
            context.perform(
                iD.actions.Noop());
        }

        activeIDs = _.pluck(context.graph().parentWays(entity), 'id');
        activeIDs.push(entity.id);

        context.enter(mode);
    }

    function datum() {
        if (d3.event.sourceEvent.altKey) {
            return {};
        }

        return d3.event.sourceEvent.target.__data__ || {};
    }

    function move(entity) {
        if (cancelled) return;
        d3.event.sourceEvent.stopPropagation();

        var nudge = edge(d3.event.point, context.map().size());
        if (nudge) startNudge(nudge);
        else stopNudge();

        var loc = context.map().mouseCoordinates();

        var d = datum();
        if (d.type === 'node' && d.id !== entity.id) {
            loc = d.loc;
        } else if (d.type === 'way') {
            loc = iD.geo.chooseIndex(d, d3.mouse(context.surface().node()), context).loc;
        }

        context.replace(
            iD.actions.MoveNode(entity.id, loc),
            t('operations.move.annotation.' + entity.geometry(context.graph())));
    }

    function end(entity) {
        if (cancelled) return;

        var d = datum();

        if (d.type === 'way') {
            var choice = iD.geo.chooseIndex(d, d3.mouse(context.surface().node()), context);
            context.replace(
                iD.actions.MoveNode(entity.id, choice.loc),
                iD.actions.AddVertex(d.id, entity.id, choice.index),
                connectAnnotation(d));

        } else if (d.type === 'node' && d.id !== entity.id) {
            context.replace(
                iD.actions.Connect([entity.id, d.id]),
                connectAnnotation(d));

        } else if (wasMidpoint) {
            context.replace(
                iD.actions.Noop(),
                t('operations.add.annotation.vertex'));

        } else {
            context.replace(
                iD.actions.Noop(),
                moveAnnotation(entity));
        }

        context.enter(iD.modes.Browse(context));
    }

    function cancel() {
        behavior.cancel();
        context.enter(iD.modes.Browse(context));
    }

    var behavior = iD.behavior.drag()
        .delegate("g.node, g.point, g.midpoint")
        .surface(context.surface().node())
        .origin(origin)
        .on('start', start)
        .on('move', move)
        .on('end', end);

    mode.enter = function() {
        context.install(hover);

        context.history()
            .on('undone.drag-node', cancel);

        context.surface()
            .selectAll('.node, .way')
            .filter(function(d) { return activeIDs.indexOf(d.id) >= 0; })
            .classed('active', true);
    };

    mode.exit = function() {
        context.uninstall(hover);

        context.history()
            .on('undone.drag_node', null);

        context.surface()
            .selectAll('.active')
            .classed('active', false);

        stopNudge();
    };

    mode.behavior = behavior;

    return mode;
};
iD.modes.DrawArea = function(context, wayId, baseGraph) {
    var mode = {
        button: 'area',
        id: 'draw-area'
    };

    var behavior;

    mode.enter = function() {
        var way = context.entity(wayId),
            headId = way.nodes[way.nodes.length - 2],
            tailId = way.first();

        behavior = iD.behavior.DrawWay(context, wayId, -1, mode, baseGraph);

        var addNode = behavior.addNode;

        behavior.addNode = function(node) {
            if (node.id === headId || node.id === tailId) {
                behavior.finish();
            } else {
                addNode(node);
            }
        };

        context.install(behavior);
        context.tail(t('modes.draw_area.tail'));
    };

    mode.exit = function() {
        context.uninstall(behavior);
    };

    return mode;
};
iD.modes.DrawLine = function(context, wayId, direction, baseGraph) {
    var mode = {
        button: 'line',
        id: 'draw-line'
    };

    var behavior;

    mode.enter = function() {
        var way = context.entity(wayId),
            index = (direction === 'forward') ? undefined : 0,
            headId = (direction === 'forward') ? way.last() : way.first();

        behavior = iD.behavior.DrawWay(context, wayId, index, mode, baseGraph);

        var addNode = behavior.addNode;

        behavior.addNode = function(node) {
            if (node.id === headId) {
                behavior.finish();
            } else {
                addNode(node);
            }
        };

        context.install(behavior);
        context.tail(t('modes.draw_line.tail'));
    };

    mode.exit = function() {
        context.uninstall(behavior);
    };

    return mode;
};
iD.modes.Move = function(context, entityIDs) {
    var mode = {
        id: 'move',
        button: 'browse'
    };

    var keybinding = d3.keybinding('move');

    mode.enter = function() {
        var origin,
            nudgeInterval,
            annotation = entityIDs.length === 1 ?
                t('operations.move.annotation.' + context.geometry(entityIDs[0])) :
                t('operations.move.annotation.multiple');

        context.perform(
            iD.actions.Noop(),
            annotation);

        function edge(point, size) {
            var pad = [30, 100, 30, 100];
            if (point[0] > size[0] - pad[0]) return [-10, 0];
            else if (point[0] < pad[2]) return [10, 0];
            else if (point[1] > size[1] - pad[1]) return [0, -10];
            else if (point[1] < pad[3]) return [0, 10];
            return null;
        }

        function startNudge(nudge) {
            if (nudgeInterval) window.clearInterval(nudgeInterval);
            nudgeInterval = window.setInterval(function() {
                context.pan(nudge);
            }, 50);
        }

        function stopNudge() {
            if (nudgeInterval) window.clearInterval(nudgeInterval);
            nudgeInterval = null;
        }

        function point() {
            return d3.mouse(context.map().surface.node());
        }

        function move() {
            var p = point();

            var delta = origin ?
                [p[0] - context.projection(origin)[0],
                p[1] - context.projection(origin)[1]] :
                [0, 0];

            var nudge = edge(p, context.map().size());
            if (nudge) startNudge(nudge);
            else stopNudge();

            origin = context.map().mouseCoordinates();

            context.replace(
                iD.actions.Move(entityIDs, delta, context.projection),
                annotation);
        }

        function finish() {
            d3.event.stopPropagation();
            context.enter(iD.modes.Select(context, entityIDs));
        }

        function cancel() {
            context.pop();
            context.enter(iD.modes.Select(context, entityIDs));
        }

        function undone() {
            context.enter(iD.modes.Browse(context));
        }

        context.surface()
            .on('mousemove.move', move)
            .on('click.move', finish);

        context.history()
            .on('undone.move', undone);

        keybinding
            .on('⎋', cancel)
            .on('↩', finish);

        d3.select(document)
            .call(keybinding);
    };

    mode.exit = function() {
        context.surface()
            .on('mousemove.move', null)
            .on('click.move', null);

        context.history()
            .on('undone.move', null);

        keybinding.off();
    };

    return mode;
};
iD.modes.RotateWay = function(context, wayId) {
    var mode = {
        id: 'rotate-way',
        button: 'browse'
    };

    var keybinding = d3.keybinding('rotate-way');

    mode.enter = function() {

        var annotation = t('operations.rotate.annotation.' + context.geometry(wayId)),
            way = context.graph().entity(wayId),
            nodes = _.uniq(context.graph().childNodes(way)),
            points = nodes.map(function(n) { return context.projection(n.loc); }),
            pivot = d3.geom.polygon(points).centroid(),
            angle;

        context.perform(
            iD.actions.Noop(),
            annotation);

        function point() {
            return d3.mouse(context.map().surface.node());
        }

        function rotate() {

            var mousePoint = point(),
                newAngle = Math.atan2(mousePoint[1] - pivot[1], mousePoint[0] - pivot[0]);

            if (typeof angle === 'undefined') angle = newAngle;

            context.replace(
                iD.actions.RotateWay(wayId, pivot, newAngle - angle, context.projection),
                annotation);

            angle = newAngle;
        }

        function finish() {
            d3.event.stopPropagation();
            context.enter(iD.modes.Select(context, [wayId]));
        }

        function cancel() {
            context.pop();
            context.enter(iD.modes.Select(context, [wayId]));
        }

        function undone() {
            context.enter(iD.modes.Browse(context));
        }

        context.surface()
            .on('mousemove.rotate-way', rotate)
            .on('click.rotate-way', finish);

        context.history()
            .on('undone.rotate-way', undone);

        keybinding
            .on('⎋', cancel)
            .on('↩', finish);

        d3.select(document)
            .call(keybinding);
    };

    mode.exit = function() {
        context.surface()
            .on('mousemove.rotate-way', null)
            .on('click.rotate-way', null);

        context.history()
            .on('undone.rotate-way', null);

        keybinding.off();
    };

    return mode;
};
iD.modes.Select = function(context, selection, initial) {
    var mode = {
        id: 'select',
        button: 'browse'
    };

    var inspector = iD.ui.Inspector(context, singular()),
        keybinding = d3.keybinding('select'),
        timeout = null,
        behaviors = [
            iD.behavior.Hover(),
            iD.behavior.Select(context),
            iD.behavior.Lasso(context),
            iD.modes.DragNode(context).behavior],
        radialMenu;

    var wrap = context.container()
        .select('.inspector-wrap');

    function singular() {
        if (selection.length === 1) {
            return context.entity(selection[0]);
        }
    }

    function positionMenu() {
        var entity = singular();

        if (entity && entity.type === 'node') {
            radialMenu.center(context.projection(entity.loc));
        } else {
            radialMenu.center(d3.mouse(context.surface().node()));
        }
    }

    function showMenu() {
        context.surface()
            .call(radialMenu.close)
            .call(radialMenu);
    }

    mode.selection = function() {
        return selection;
    };

    mode.reselect = function() {
        positionMenu();
        showMenu();
    };

    mode.enter = function() {
        behaviors.forEach(function(behavior) {
            context.install(behavior);
        });

        var operations = _.without(d3.values(iD.operations), iD.operations.Delete)
            .map(function(o) { return o(selection, context); })
            .filter(function(o) { return o.available(); });
        operations.unshift(iD.operations.Delete(selection, context));

        keybinding.on('⎋', function() {
            context.enter(iD.modes.Browse(context));
        }, true);

        operations.forEach(function(operation) {
            operation.keys.forEach(function(key) {
                keybinding.on(key, function() {
                    if (operation.enabled()) {
                        operation();
                    }
                });
            });
        });

        var q = iD.util.stringQs(location.hash.substring(1));
        location.replace('#' + iD.util.qsString(_.assign(q, {
            id: selection.join(',')
        }), true));

        if (singular()) {
            wrap.call(inspector);
        }

        context.history()
            .on('undone.select', update)
            .on('redone.select', update);

        function update() {
            context.surface().call(radialMenu.close);

            if (_.any(selection, function(id) { return !context.entity(id); })) {
                // Exit mode if selected entity gets undone
                context.enter(iD.modes.Browse(context));
            }
        }

        context.map().on('move.select', function() {
            context.surface().call(radialMenu.close);
        });

        function dblclick() {
            var target = d3.select(d3.event.target),
                datum = target.datum();

            if (datum instanceof iD.Way && !target.classed('fill')) {
                var choice = iD.geo.chooseIndex(datum,
                        d3.mouse(context.surface().node()), context),
                    node = iD.Node();

                var prev = datum.nodes[choice.index - 1],
                    next = datum.nodes[choice.index];

                context.perform(
                    iD.actions.AddMidpoint({loc: choice.loc, edge: [prev, next]}, node),
                    t('operations.add.annotation.vertex'));

                d3.event.preventDefault();
                d3.event.stopPropagation();
            }
        }

        function selected(entity) {
            if (!entity) return false;
            if (selection.indexOf(entity.id) >= 0) return true;
            return d3.select(this).classed('stroke') &&
                _.any(context.graph().parentRelations(entity), function(parent) {
                    return selection.indexOf(parent.id) >= 0;
                });
        }

        d3.select(document)
            .call(keybinding);

        context.surface()
            .selectAll("*")
            .filter(selected)
            .classed('selected', true);

        radialMenu = iD.ui.RadialMenu(operations);
        var show = d3.event && !initial;

        if (show) {
            positionMenu();
        }

        timeout = window.setTimeout(function() {
            if (show) {
                showMenu();
            }

            context.surface()
                .on('dblclick.select', dblclick);
        }, 200);
    };

    mode.exit = function() {
        if (timeout) window.clearTimeout(timeout);

        wrap.call(inspector.close);

        behaviors.forEach(function(behavior) {
            context.uninstall(behavior);
        });

        var q = iD.util.stringQs(location.hash.substring(1));
        location.replace('#' + iD.util.qsString(_.omit(q, 'id'), true));

        keybinding.off();

        context.history()
            .on('undone.select', null)
            .on('redone.select', null);

        context.surface()
            .call(radialMenu.close)
            .on('dblclick.select', null)
            .selectAll(".selected")
            .classed('selected', false);
    };

    return mode;
};
iD.operations = {};
iD.operations.Circularize = function(selection, context) {
    var entityId = selection[0],
        action = iD.actions.Circularize(entityId, context.projection);

    var operation = function() {
        var annotation = t('operations.circularize.annotation.' + context.geometry(entityId));
        context.perform(action, annotation);
    };

    operation.available = function() {
        return selection.length === 1 &&
            context.entity(entityId).type === 'way';
    };

    operation.enabled = function() {
        return action.enabled(context.graph());
    };

    operation.id = "circularize";
    operation.keys = [t('operations.circularize.key')];
    operation.title = t('operations.circularize.title');
    operation.description = t('operations.circularize.description');

    return operation;
};
iD.operations.Delete = function(selection, context) {
    var operation = function() {
        var annotation;

        if (selection.length === 1) {
            annotation = t('operations.delete.annotation.' + context.geometry(selection[0]));
        } else {
            annotation = t('operations.delete.annotation.multiple', {n: selection.length});
        }

        context.perform(
            iD.actions.DeleteMultiple(selection),
            annotation);

        context.enter(iD.modes.Browse(context));
    };

    operation.available = function() {
        return true;
    };

    operation.enabled = function() {
        return true;
    };

    operation.id = "delete";
    operation.keys = [iD.ui.cmd('⌫'), iD.ui.cmd('⌦')];
    operation.title = t('operations.delete.title');
    operation.description = t('operations.delete.description');

    return operation;
};
iD.operations.Disconnect = function(selection, context) {
    var entityId = selection[0],
        action = iD.actions.Disconnect(entityId);

    var operation = function() {
        context.perform(action, t('operations.disconnect.annotation'));
        context.enter(iD.modes.Browse(context));
    };

    operation.available = function() {
        return selection.length === 1 &&
            context.geometry(entityId) === 'vertex';
    };

    operation.enabled = function() {
        return action.enabled(context.graph());
    };

    operation.id = "disconnect";
    operation.keys = [t('operations.disconnect.key')];
    operation.title = t('operations.disconnect.title');
    operation.description = t('operations.disconnect.description');

    return operation;
};
iD.operations.Merge = function(selection, context) {
    var join = iD.actions.Join(selection),
        merge = iD.actions.Merge(selection);

    var operation = function() {
        var annotation = t('operations.merge.annotation', {n: selection.length}),
            action;

        if (join.enabled(context.graph())) {
            action = join;
        } else {
            action = merge;
        }

        var difference = context.perform(action, annotation);
        context.enter(iD.modes.Select(context, difference.extantIDs()));
    };

    operation.available = function() {
        return selection.length >= 2;
    };

    operation.enabled = function() {
        return join.enabled(context.graph()) ||
            merge.enabled(context.graph());
    };

    operation.id = "merge";
    operation.keys = [t('operations.merge.key')];
    operation.title = t('operations.merge.title');
    operation.description = t('operations.merge.description');

    return operation;
};
iD.operations.Move = function(selection, context) {
    var operation = function() {
        context.enter(iD.modes.Move(context, selection));
    };

    operation.available = function() {
        return selection.length > 1 ||
            context.entity(selection[0]).type !== 'node';
    };

    operation.enabled = function() {
        return iD.actions.Move(selection)
            .enabled(context.graph());
    };

    operation.id = "move";
    operation.keys = [t('operations.move.key')];
    operation.title = t('operations.move.title');
    operation.description = t('operations.move.description');

    return operation;
};
iD.operations.Orthogonalize = function(selection, context) {
    var entityId = selection[0],
        action = iD.actions.Orthogonalize(entityId, context.projection);

    var operation = function() {
        var annotation = t('operations.orthogonalize.annotation.' + context.geometry(entityId));
        context.perform(action, annotation);
    };

    operation.available = function() {
        return selection.length === 1 &&
            context.entity(entityId).type === 'way' &&
            _.uniq(context.entity(entityId).nodes).length > 3;
    };

    operation.enabled = function() {
        return action.enabled(context.graph());
    };

    operation.id = "orthogonalize";
    operation.keys = [t('operations.orthogonalize.key')];
    operation.title = t('operations.orthogonalize.title');
    operation.description = t('operations.orthogonalize.description');

    return operation;
};
iD.operations.Reverse = function(selection, context) {
    var entityId = selection[0];

    var operation = function() {
        context.perform(
            iD.actions.Reverse(entityId),
            t('operations.reverse.annotation'));
    };

    operation.available = function() {
        return selection.length === 1 &&
            context.geometry(entityId) === 'line';
    };

    operation.enabled = function() {
        return true;
    };

    operation.id = "reverse";
    operation.keys = [t('operations.reverse.key')];
    operation.title = t('operations.reverse.title');
    operation.description = t('operations.reverse.description');

    return operation;
};
iD.operations.Rotate = function(selection, context) {
    var entityId = selection[0];

    var operation = function() {
        context.enter(iD.modes.RotateWay(context, entityId));
    };

    operation.available = function() {
        return selection.length === 1 &&
            context.entity(entityId).type === 'way' &&
            context.entity(entityId).geometry() === 'area';
    };

    operation.enabled = function() {
        return true;
    };

    operation.id = "rotate";
    operation.keys = [t('operations.rotate.key')];
    operation.title = t('operations.rotate.title');
    operation.description = t('operations.rotate.description');

    return operation;
};
iD.operations.Split = function(selection, context) {
    var entityId = selection[0],
        action = iD.actions.Split(entityId);

    var operation = function() {
        var annotation = t('operations.split.annotation'),
            difference = context.perform(action, annotation);
        context.enter(iD.modes.Select(context, difference.extantIDs()));
    };

    operation.available = function() {
        return selection.length === 1 &&
            context.geometry(entityId) === 'vertex';
    };

    operation.enabled = function() {
        return action.enabled(context.graph());
    };

    operation.id = "split";
    operation.keys = [t('operations.split.key')];
    operation.title = t('operations.split.title');
    operation.description = t('operations.split.description');

    return operation;
};
/*
    iD.Difference represents the difference between two graphs.
    It knows how to calculate the set of entities that were
    created, modified, or deleted, and also contains the logic
    for recursively extending a difference to the complete set
    of entities that will require a redraw, taking into account
    child and parent relationships.
 */
iD.Difference = function(base, head) {
    var changes = {}, length = 0;

    _.each(head.entities, function(h, id) {
        var b = base.entities[id];
        if (h !== b) {
            changes[id] = {base: b, head: h};
            length++;
        }
    });

    _.each(base.entities, function(b, id) {
        var h = head.entities[id];
        if (!changes[id] && h !== b) {
            changes[id] = {base: b, head: h};
            length++;
        }
    });

    function addParents(parents, result) {
        for (var i = 0; i < parents.length; i++) {
            var parent = parents[i];

            if (parent.id in result)
                continue;

            result[parent.id] = parent;
            addParents(head.parentRelations(parent), result);
        }
    }

    var difference = {};

    difference.length = function() {
        return length;
    };

    difference.changes = function() {
        return changes;
    };

    difference.extantIDs = function() {
        var result = [];
        _.each(changes, function(change, id) {
            if (change.head) result.push(id);
        });
        return result;
    };

    difference.modified = function() {
        var result = [];
        _.each(changes, function(change) {
            if (change.base && change.head) result.push(change.head);
        });
        return result;
    };

    difference.created = function() {
        var result = [];
        _.each(changes, function(change) {
            if (!change.base && change.head) result.push(change.head);
        });
        return result;
    };

    difference.deleted = function() {
        var result = [];
        _.each(changes, function(change) {
            if (change.base && !change.head) result.push(change.base);
        });
        return result;
    };

    difference.addParents = function(entities) {

        for (var i in entities) {
            addParents(head.parentWays(entities[i]), entities);
            addParents(head.parentRelations(entities[i]), entities);
        }
        return entities;
    };

    difference.complete = function(extent) {
        var result = {}, id, change;

        for (id in changes) {
            change = changes[id];

            var h = change.head,
                b = change.base,
                entity = h || b;

            if (extent &&
                (!h || !h.intersects(extent, head)) &&
                (!b || !b.intersects(extent, base)))
                continue;

            result[id] = h;

            if (entity.type === 'way') {
                var nh = h ? h.nodes : [],
                    nb = b ? b.nodes : [],
                    diff, i;

                diff = _.difference(nh, nb);
                for (i = 0; i < diff.length; i++) {
                    result[diff[i]] = head.entity(diff[i]);
                }

                diff = _.difference(nb, nh);
                for (i = 0; i < diff.length; i++) {
                    result[diff[i]] = head.entity(diff[i]);
                }
            }

            addParents(head.parentWays(entity), result);
            addParents(head.parentRelations(entity), result);
        }

        return result;
    };

    return difference;
};
iD.Entity = function(attrs) {
    // For prototypal inheritance.
    if (this instanceof iD.Entity) return;

    // Create the appropriate subtype.
    if (attrs && attrs.type) {
        return iD.Entity[attrs.type].apply(this, arguments);
    }

    // Initialize a generic Entity (used only in tests).
    return (new iD.Entity()).initialize(arguments);
};

iD.Entity.id = function(type) {
    return iD.Entity.id.fromOSM(type, iD.Entity.id.next[type]--);
};

iD.Entity.id.next = {node: -1, way: -1, relation: -1};

iD.Entity.id.fromOSM = function(type, id) {
    return type[0] + id;
};

iD.Entity.id.toOSM = function(id) {
    return id.slice(1);
};

// A function suitable for use as the second argument to d3.selection#data().
iD.Entity.key = function(entity) {
    return entity.id;
};

iD.Entity.prototype = {
    tags: {},

    initialize: function(sources) {
        for (var i = 0; i < sources.length; ++i) {
            var source = sources[i];
            for (var prop in source) {
                if (Object.prototype.hasOwnProperty.call(source, prop)) {
                    this[prop] = source[prop];
                }
            }
        }

        if (!this.id && this.type) {
            this.id = iD.Entity.id(this.type);
        }

        if (iD.debug) {
            Object.freeze(this);
            Object.freeze(this.tags);

            if (this.loc) Object.freeze(this.loc);
            if (this.nodes) Object.freeze(this.nodes);
            if (this.members) Object.freeze(this.members);
        }

        return this;
    },

    osmId: function() {
        return iD.Entity.id.toOSM(this.id);
    },

    isNew: function() {
        return this.osmId() < 0;
    },

    update: function(attrs) {
        return iD.Entity(this, attrs);
    },

    mergeTags: function(tags) {
        var merged = _.clone(this.tags), changed = false;
        for (var k in tags) {
            var t1 = merged[k],
                t2 = tags[k];
            if (!t1) {
                changed = true;
                merged[k] = t2;
            } else if (t1 !== t2) {
                changed = true;
                merged[k] = _.union(t1.split(/;\s*/), t2.split(/;\s*/)).join(';');
            }
        }
        return changed ? this.update({tags: merged}) : this;
    },

    intersects: function(extent, resolver) {
        return this.extent(resolver).intersects(extent);
    },

    hasInterestingTags: function() {
        return _.keys(this.tags).some(function(key) {
            return key != 'attribution' &&
                key != 'created_by' &&
                key != 'source' &&
                key != 'odbl' &&
                key.indexOf('tiger:') !== 0;
        });
    },

    deprecatedTags: function() {
        var tags = _.pairs(this.tags);
        var deprecated = {};

        iD.data.deprecated.forEach(function(d) {
            var match = _.pairs(d.old)[0];
            tags.forEach(function(t) {
                if (t[0] == match[0] &&
                    (t[1] == match[1] || match[1] == '*')) {
                    deprecated[t[0]] = t[1];
                }
            });
        });

        return deprecated;
    },

    friendlyName: function() {
        // Generate a string such as 'river' or 'Fred's House' for an entity.
        if (!this.tags || !Object.keys(this.tags).length) { return ''; }

        var mainkeys = ['highway', 'amenity', 'railway', 'waterway', 'natural'],
            n = [];

        if (this.tags.name) n.push(this.tags.name);
        if (this.tags.ref) n.push(this.tags.ref);

        if (!n.length) {
            for (var k in this.tags) {
                if (mainkeys.indexOf(k) !== -1) {
                    n.push(this.tags[k]);
                    break;
                }
            }
        }

        return n.length === 0 ? 'unknown' : n.join('; ');
    }
};
iD.Graph = function(other, mutable) {
    if (!(this instanceof iD.Graph)) return new iD.Graph(other, mutable);

    if (other instanceof iD.Graph) {
        var base = other.base();
        this.entities = _.assign(Object.create(base.entities), other.entities);
        this._parentWays = _.assign(Object.create(base.parentWays), other._parentWays);
        this._parentRels = _.assign(Object.create(base.parentRels), other._parentRels);
        this.inherited = true;

    } else {
        if (Array.isArray(other)) {
            var entities = {};
            for (var i = 0; i < other.length; i++) {
                entities[other[i].id] = other[i];
            }
            other = entities;
        }
        this.entities = Object.create({});
        this._parentWays = Object.create({});
        this._parentRels = Object.create({});
        this.rebase(other || {});
    }

    this.transients = {};
    this._childNodes = {};
    this.getEntity = _.bind(this.entity, this);

    if (!mutable) {
        this.freeze();
    }
};

iD.Graph.prototype = {
    entity: function(id) {
        return this.entities[id];
    },

    transient: function(entity, key, fn) {
        var id = entity.id,
            transients = this.transients[id] ||
            (this.transients[id] = {});

        if (transients[key] !== undefined) {
            return transients[key];
        }

        transients[key] = fn.call(entity);

        return transients[key];
    },

    parentWays: function(entity) {
        return _.map(this._parentWays[entity.id], this.getEntity);
    },

    isPoi: function(entity) {
        var parentWays = this._parentWays[entity.id];
        return !parentWays || parentWays.length === 0;
    },

    isShared: function(entity) {
        var parentWays = this._parentWays[entity.id];
        return parentWays && parentWays.length > 1;
    },

    parentRelations: function(entity) {
        return _.map(this._parentRels[entity.id], this.getEntity);
    },

    childNodes: function(entity) {
        if (this._childNodes[entity.id])
            return this._childNodes[entity.id];

        var nodes = [];
        for (var i = 0, l = entity.nodes.length; i < l; i++) {
            nodes[i] = this.entity(entity.nodes[i]);
        }

        this._childNodes[entity.id] = nodes;
        return this._childNodes[entity.id];
    },

    base: function() {
        return {
            'entities': iD.util.getPrototypeOf(this.entities),
            'parentWays': iD.util.getPrototypeOf(this._parentWays),
            'parentRels': iD.util.getPrototypeOf(this._parentRels)
        };
    },

    // Unlike other graph methods, rebase mutates in place. This is because it
    // is used only during the history operation that merges newly downloaded
    // data into each state. To external consumers, it should appear as if the
    // graph always contained the newly downloaded data.
    rebase: function(entities) {
        var base = this.base(),
            i, k, child, id, keys;

        // Merging of data only needed if graph is the base graph
        if (!this.inherited) {
            for (i in entities) {
                if (!base.entities[i]) {
                    base.entities[i] = entities[i];
                    this._updateCalculated(undefined, entities[i],
                            base.parentWays, base.parentRels);
                }
            }
        }

        keys = Object.keys(this._parentWays);
        for (i = 0; i < keys.length; i++) {
            child = keys[i];
            if (base.parentWays[child]) {
                for (k = 0; k < base.parentWays[child].length; k++) {
                    id = base.parentWays[child][k];
                    if (!this.entities.hasOwnProperty(id) && !_.contains(this._parentWays[child], id)) {
                        this._parentWays[child].push(id);
                    }
                }
            }
        }

        keys = Object.keys(this._parentRels);
        for (i = 0; i < keys.length; i++) {
            child = keys[i];
            if (base.parentRels[child]) {
                for (k = 0; k < base.parentRels[child].length; k++) {
                    id = base.parentRels[child][k];
                    if (!this.entities.hasOwnProperty(id) && !_.contains(this._parentRels[child], id)) {
                        this._parentRels[child].push(id);
                    }
                }
            }
        }
    },

    // Updates calculated properties (parentWays, parentRels) for the specified change
    _updateCalculated: function(oldentity, entity, parentWays, parentRels) {

        parentWays = parentWays || this._parentWays;
        parentRels = parentRels || this._parentRels;

        var type = entity && entity.type || oldentity && oldentity.type,
            removed, added, ways, rels, i;


        if (type === 'way') {

            // Update parentWays
            if (oldentity && entity) {
                removed = _.difference(oldentity.nodes, entity.nodes);
                added = _.difference(entity.nodes, oldentity.nodes);
            } else if (oldentity) {
                removed = oldentity.nodes;
                added = [];
            } else if (entity) {
                removed = [];
                added = entity.nodes;
            }
            for (i = 0; i < removed.length; i++) {
                parentWays[removed[i]] = _.without(parentWays[removed[i]], oldentity.id);
            }
            for (i = 0; i < added.length; i++) {
                ways = _.without(parentWays[added[i]], entity.id);
                ways.push(entity.id);
                parentWays[added[i]] = ways;
            }
        } else if (type === 'node') {

        } else if (type === 'relation') {

            // Update parentRels
            if (oldentity && entity) {
                removed = _.difference(oldentity.members, entity.members);
                added = _.difference(entity.members, oldentity);
            } else if (oldentity) {
                removed = oldentity.members;
                added = [];
            } else if (entity) {
                removed = [];
                added = entity.members;
            }
            for (i = 0; i < removed.length; i++) {
                parentRels[removed[i].id] = _.without(parentRels[removed[i].id], oldentity.id);
            }
            for (i = 0; i < added.length; i++) {
                rels = _.without(parentRels[added[i].id], entity.id);
                rels.push(entity.id);
                parentRels[added[i].id] = rels;
            }
        }
    },

    replace: function(entity) {
        if (this.entities[entity.id] === entity)
            return this;

        return this.update(function() {
            this._updateCalculated(this.entities[entity.id], entity);
            this.entities[entity.id] = entity;
        });
    },

    remove: function(entity) {
        return this.update(function() {
            this._updateCalculated(entity, undefined);
            this.entities[entity.id] = undefined;
        });
    },

    update: function() {
        var graph = this.frozen ? iD.Graph(this, true) : this;

        for (var i = 0; i < arguments.length; i++) {
            arguments[i].call(graph, graph);
        }

        return this.frozen ? graph.freeze() : this;
    },

    freeze: function() {
        this.frozen = true;

        if (iD.debug) {
            Object.freeze(this.entities);
        }

        return this;
    },

    hasAllChildren: function(entity) {
        // we're only checking changed entities, since we assume fetched data
        // must have all children present
        var i;
        if (this.entities.hasOwnProperty(entity.id)) {
            if (entity.type === 'way') {
                for (i = 0; i < entity.nodes.length; i++) {
                    if (!this.entities[entity.nodes[i]]) return false;
                }
            } else if (entity.type === 'relation') {
                for (i = 0; i < entity.members.length; i++) {
                    if (!this.entities[entity.members[i].id]) return false;
                }
            }
        }
        return true;
    },

    // Obliterates any existing entities
    load: function(entities) {

        var base = this.base(),
            i, entity, prefix;
        this.entities = Object.create(base.entities);

        for (i in entities) {
            entity = entities[i];
            prefix = i[0];

            if (entity === 'undefined') {
                this.entities[i] = undefined;
            } else if (prefix == 'n') {
                this.entities[i] = new iD.Node(entity);

            } else if (prefix == 'w') {
                this.entities[i] = new iD.Way(entity);

            } else if (prefix == 'r') {
                this.entities[i] = new iD.Relation(entity);
            }
            this._updateCalculated(base.entities[i], this.entities[i]);
        }
        return this;
    }
};
iD.History = function(context) {
    var stack, index, tree,
        imagery_used = 'Bing',
        dispatch = d3.dispatch('change', 'undone', 'redone'),
        lock = false;

    function perform(actions) {
        actions = Array.prototype.slice.call(actions);

        var annotation;

        if (!_.isFunction(_.last(actions))) {
            annotation = actions.pop();
        }

        var graph = stack[index].graph;
        for (var i = 0; i < actions.length; i++) {
            graph = actions[i](graph);
        }

        return {
            graph: graph,
            annotation: annotation,
            imagery_used: imagery_used
        };
    }

    function change(previous) {
        var difference = iD.Difference(previous, history.graph());
        dispatch.change(difference);
        return difference;
    }

    // iD uses namespaced keys so multiple installations do not conflict
    function getKey(n) {
        return 'iD_' + window.location.origin + '_' + n;
    }

    var history = {
        graph: function() {
            return stack[index].graph;
        },

        merge: function(entities) {

            var base = stack[0].graph.base(),
                newentities = Object.keys(entities).filter(function(i) {
                    return !base.entities[i];
                });

            for (var i = 0; i < stack.length; i++) {
                stack[i].graph.rebase(entities);
            }

            tree.rebase(newentities);

            dispatch.change();
        },

        perform: function() {
            var previous = stack[index].graph;

            stack = stack.slice(0, index + 1);
            stack.push(perform(arguments));
            index++;

            return change(previous);
        },

        replace: function() {
            var previous = stack[index].graph;

            // assert(index == stack.length - 1)
            stack[index] = perform(arguments);

            return change(previous);
        },

        pop: function() {
            var previous = stack[index].graph;

            if (index > 0) {
                index--;
                stack.pop();
                return change(previous);
            }
        },

        undo: function() {
            var previous = stack[index].graph;

            // Pop to the first annotated state.
            while (index > 0) {
                if (stack[index].annotation) break;
                index--;
            }

            // Pop to the next annotated state.
            while (index > 0) {
                index--;
                if (stack[index].annotation) break;
            }

            dispatch.undone();
            return change(previous);
        },

        redo: function() {
            var previous = stack[index].graph;

            while (index < stack.length - 1) {
                index++;
                if (stack[index].annotation) break;
            }

            dispatch.redone();
            return change(previous);
        },

        undoAnnotation: function() {
            var i = index;
            while (i >= 0) {
                if (stack[i].annotation) return stack[i].annotation;
                i--;
            }
        },

        redoAnnotation: function() {
            var i = index + 1;
            while (i <= stack.length - 1) {
                if (stack[i].annotation) return stack[i].annotation;
                i++;
            }
        },

        intersects: function(extent) {
            return tree.intersects(extent, stack[index].graph);
        },

        difference: function() {
            var base = stack[0].graph,
                head = stack[index].graph;
            return iD.Difference(base, head);
        },

        changes: function() {
            var difference = history.difference();

            function discardTags(entity) {
                if (_.isEmpty(entity.tags)) {
                    return entity;
                } else {
                    return entity.update({
                        tags: _.omit(entity.tags, iD.data.discarded)
                    });
                }
            }

            return {
                modified: difference.modified().map(discardTags),
                created: difference.created().map(discardTags),
                deleted: difference.deleted()
            };
        },

        hasChanges: function() {
            return this.difference().length() > 0;
        },

        numChanges: function() {
            return this.difference().length();
        },

        imagery_used: function(source) {
            if (source) imagery_used = source;
            else return _.without(
                    _.unique(_.pluck(stack.slice(1, index + 1), 'imagery_used')),
                    undefined, 'Custom');
        },

        reset: function() {
            stack = [{graph: iD.Graph()}];
            index = 0;
            tree = iD.Tree(stack[0].graph);
            dispatch.change();
        },

        save: function() {
            if (!lock) return;
            context.storage(getKey('lock'), null);

            if (stack.length <= 1) return;

            var json = JSON.stringify(stack.map(function(i) {
                var x = { entities: i.graph.entities };
                if (i.imagery_used) x.imagery_used = i.imagery_used;
                if (i.annotation) x.annotation = i.annotation;
                return x;
            }), function includeUndefined(key, value) {
                if (typeof value === 'undefined') return 'undefined';
                return value;
            });

            context.storage(getKey('history'), json);
            context.storage(getKey('nextIDs'), JSON.stringify(iD.Entity.id.next));
            context.storage(getKey('index'), index);
        },

        clearSaved: function() {
            if (!lock) return;
            context.storage(getKey('history'), null);
            context.storage(getKey('nextIDs'), null);
            context.storage(getKey('index'), null);
        },

        lock: function() {
            if (context.storage(getKey('lock'))) return false;
            context.storage(getKey('lock'), true);
            lock = true;
            return lock;
        },

        // is iD not open in another window and it detects that
        // there's a history stored in localStorage that's recoverable?
        restorableChanges: function() {
            return lock && !!context.storage(getKey('history'));
        },

        // load history from a version stored in localStorage
        load: function() {
            if (!lock) return;

            var json = context.storage(getKey('history')),
                nextIDs = context.storage(getKey('nextIDs')),
                index_ = context.storage(getKey('index'));

            if (!json) return;
            if (nextIDs) iD.Entity.id.next = JSON.parse(nextIDs);
            if (index_ !== null) index = parseInt(index_, 10);

            context.storage(getKey('history', null));
            context.storage(getKey('nextIDs', null));
            context.storage(getKey('index', null));

            stack = JSON.parse(json).map(function(d) {
                d.graph = iD.Graph(stack[0].graph).load(d.entities);
                return d;
            });
            stack[0].graph.inherited = false;
            dispatch.change();
        },

        _getKey: getKey

    };

    history.reset();

    return d3.rebind(history, dispatch, 'on');
};
iD.Node = iD.Entity.node = function iD_Node() {
    if (!(this instanceof iD_Node)) {
        return (new iD_Node()).initialize(arguments);
    } else if (arguments.length) {
        this.initialize(arguments);
    }
};

iD.Node.prototype = Object.create(iD.Entity.prototype);

_.extend(iD.Node.prototype, {
    type: "node",

    extent: function() {
        return new iD.geo.Extent(this.loc);
    },

    geometry: function(graph) {
        return graph.isPoi(this) ? 'point' : 'vertex';
    },

    move: function(loc) {
        return this.update({loc: loc});
    },

    asJXON: function(changeset_id) {
        var r = {
            node: {
                '@id': this.osmId(),
                '@lon': this.loc[0],
                '@lat': this.loc[1],
                '@version': (this.version || 0),
                tag: _.map(this.tags, function(v, k) {
                    return { keyAttributes: { k: k, v: v } };
                })
            }
        };
        if (changeset_id) r.node['@changeset'] = changeset_id;
        return r;
    },

    asGeoJSON: function() {
        return {
            type: 'Feature',
            properties: this.tags,
            geometry: {
                type: 'Point',
                coordinates: this.loc
            }
        };
    }
});
iD.Relation = iD.Entity.relation = function iD_Relation() {
    if (!(this instanceof iD_Relation)) {
        return (new iD_Relation()).initialize(arguments);
    } else if (arguments.length) {
        this.initialize(arguments);
    }
};

iD.Relation.prototype = Object.create(iD.Entity.prototype);

_.extend(iD.Relation.prototype, {
    type: "relation",
    members: [],

    extent: function(resolver) {
        return resolver.transient(this, 'extent', function() {
            return this.members.reduce(function(extent, member) {
                member = resolver.entity(member.id);
                if (member) {
                    return extent.extend(member.extent(resolver));
                } else {
                    return extent;
                }
            }, iD.geo.Extent());
        });
    },

    geometry: function() {
        return this.isMultipolygon() ? 'area' : 'relation';
    },

    // Return the first member with the given role. A copy of the member object
    // is returned, extended with an 'index' property whose value is the member index.
    memberByRole: function(role) {
        for (var i = 0; i < this.members.length; i++) {
            if (this.members[i].role === role) {
                return _.extend({}, this.members[i], {index: i});
            }
        }
    },

    // Return the first member with the given id. A copy of the member object
    // is returned, extended with an 'index' property whose value is the member index.
    memberById: function(id) {
        for (var i = 0; i < this.members.length; i++) {
            if (this.members[i].id === id) {
                return _.extend({}, this.members[i], {index: i});
            }
        }
    },

    // Return the first member with the given id and role. A copy of the member object
    // is returned, extended with an 'index' property whose value is the member index.
    memberByIdAndRole: function(id, role) {
        for (var i = 0; i < this.members.length; i++) {
            if (this.members[i].id === id && this.members[i].role === role) {
                return _.extend({}, this.members[i], {index: i});
            }
        }
    },

    addMember: function(member, index) {
        var members = this.members.slice();
        members.splice(index === undefined ? members.length : index, 0, member);
        return this.update({members: members});
    },

    updateMember: function(member, index) {
        var members = this.members.slice();
        members.splice(index, 1, _.extend({}, members[index], member));
        return this.update({members: members});
    },

    removeMember: function(id) {
        var members = _.reject(this.members, function(m) { return m.id === id; });
        return this.update({members: members});
    },

    // Wherever a member appears with id `needle.id`, replace it with a member
    // with id `replacement.id`, type `replacement.type`, and the original role,
    // unless a member already exists with that id and role. Return an updated
    // relation.
    replaceMember: function(needle, replacement) {
        if (!this.memberById(needle.id))
            return this;

        var members = [];

        for (var i = 0; i < this.members.length; i++) {
            var member = this.members[i];
            if (member.id !== needle.id) {
                members.push(member);
            } else if (!this.memberByIdAndRole(replacement.id, member.role)) {
                members.push({id: replacement.id, type: replacement.type, role: member.role});
            }
        }

        return this.update({members: members});
    },

    asJXON: function(changeset_id) {
        var r = {
            relation: {
                '@id': this.osmId(),
                '@version': this.version || 0,
                member: _.map(this.members, function(member) {
                    return { keyAttributes: { type: member.type, role: member.role, ref: iD.Entity.id.toOSM(member.id) } };
                }),
                tag: _.map(this.tags, function(v, k) {
                    return { keyAttributes: { k: k, v: v } };
                })
            }
        };
        if (changeset_id) r.relation['@changeset'] = changeset_id;
        return r;
    },

    asGeoJSON: function(resolver) {
        if (this.isMultipolygon()) {
            return {
                type: 'Feature',
                properties: this.tags,
                geometry: {
                    type: 'MultiPolygon',
                    coordinates: this.multipolygon(resolver)
                }
            };
        } else {
            return {
                type: 'FeatureCollection',
                properties: this.tags,
                features: this.members.map(function(member) {
                    return _.extend({role: member.role}, resolver.entity(member.id).asGeoJSON(resolver));
                })
            };
        }
    },

    isMultipolygon: function() {
        return this.tags.type === 'multipolygon';
    },

    isComplete: function(resolver) {
        for (var i = 0; i < this.members.length; i++) {
            if (!resolver.entity(this.members[i].id)) {
                return false;
            }
        }
        return true;
    },

    isRestriction: function() {
        return !!(this.tags.type && this.tags.type.match(/^restriction:?/));
    },

    // Returns an array [A0, ... An], each Ai being an array of node arrays [Nds0, ... Ndsm],
    // where Nds0 is an outer ring and subsequent Ndsi's (if any i > 0) being inner rings.
    //
    // This corresponds to the structure needed for rendering a multipolygon path using a
    // `evenodd` fill rule, as well as the structure of a GeoJSON MultiPolygon geometry.
    //
    // In the case of invalid geometries, this function will still return a result which
    // includes the nodes of all way members, but some Nds may be unclosed and some inner
    // rings not matched with the intended outer ring.
    //
    multipolygon: function(resolver) {
        var members = this.members
            .filter(function(m) { return m.type === 'way' && resolver.entity(m.id); })
            .map(function(m) { return { role: m.role || 'outer', id: m.id, nodes: resolver.childNodes(resolver.entity(m.id)) }; });

        function join(ways) {
            var joined = [], current, first, last, i, how, what;

            while (ways.length) {
                current = ways.pop().nodes.slice();
                joined.push(current);

                while (ways.length && _.first(current) !== _.last(current)) {
                    first = _.first(current);
                    last  = _.last(current);

                    for (i = 0; i < ways.length; i++) {
                        what = ways[i].nodes;

                        if (last === _.first(what)) {
                            how  = current.push;
                            what = what.slice(1);
                            break;
                        } else if (last === _.last(what)) {
                            how  = current.push;
                            what = what.slice(0, -1).reverse();
                            break;
                        } else if (first == _.last(what)) {
                            how  = current.unshift;
                            what = what.slice(0, -1);
                            break;
                        } else if (first == _.first(what)) {
                            how  = current.unshift;
                            what = what.slice(1).reverse();
                            break;
                        } else {
                            what = how = null;
                        }
                    }

                    if (!what)
                        break; // Invalid geometry (unclosed ring)

                    ways.splice(i, 1);
                    how.apply(current, what);
                }
            }

            return joined.map(function(nodes) { return _.pluck(nodes, 'loc'); });
        }

        function findOuter(inner) {
            var o, outer;

            for (o = 0; o < outers.length; o++) {
                outer = outers[o];
                if (iD.geo.polygonContainsPolygon(outer, inner))
                    return o;
            }

            for (o = 0; o < outers.length; o++) {
                outer = outers[o];
                if (iD.geo.polygonIntersectsPolygon(outer, inner))
                    return o;
            }
        }

        var outers = join(members.filter(function(m) { return m.role === 'outer'; })),
            inners = join(members.filter(function(m) { return m.role === 'inner'; })),
            result = outers.map(function(o) { return [o]; });

        for (var i = 0; i < inners.length; i++) {
            var o = findOuter(inners[i]);
            if (o !== undefined)
                result[o].push(inners[i]);
            else
                result.push([inners[i]]); // Invalid geometry
        }

        return result;
    }
});
iD.Tree = function(graph) {

    var rtree = new RTree(),
        m = 1000 * 1000 * 100,
        head = graph,
        queuedCreated = [],
        queuedModified = [],
        x, y, dx, dy, rebased;

    function extentRectangle(extent) {
            x = m * extent[0][0],
            y = m * extent[0][1],
            dx = m * extent[1][0] - x || 2,
            dy = m * extent[1][1] - y || 2;
        return new RTree.Rectangle(~~x, ~~y, ~~dx - 1, ~~dy - 1);
    }

    function insert(entity) {
        rtree.insert(extentRectangle(entity.extent(head)), entity.id);
    }

    function remove(entity) {
        rtree.remove(extentRectangle(entity.extent(graph)), entity.id);
    }

    function reinsert(entity) {
        remove(graph.entities[entity.id]);
        insert(entity);
    }

    var tree = {

        rebase: function(entities) {
            for (var i = 0; i < entities.length; i++) {
                if (!graph.entities.hasOwnProperty(entities[i])) {
                    insert(graph.entity(entities[i]), true);
                }
            }
            rebased = true;
            return tree;
        },

        intersects: function(extent, g) {

            head = g;

            if (graph !== head || rebased) {
                var diff = iD.Difference(graph, head),
                    modified = {};

                diff.modified().forEach(function(d) {
                    var loc = graph.entities[d.id].loc;
                    if (!loc || loc[0] !== d.loc[0] || loc[1] !== d.loc[1]) {
                        modified[d.id] = d;
                    }
                });

                var created = diff.created().concat(queuedCreated);
                modified = d3.values(diff.addParents(modified))
                    // some parents might be created, not modified
                    .filter(function(d) { return !!graph.entity(d.id); })
                    .concat(queuedModified);
                queuedCreated = [];
                queuedModified = [];

                modified.forEach(function(d) {
                    if (head.hasAllChildren(d)) reinsert(d);
                    else queuedModified.push(d);
                });

                created.forEach(function(d) {
                    if (head.hasAllChildren(d)) insert(d);
                    else queuedCreated.push(d);
                });

                diff.deleted().forEach(remove);

                graph = head;
                rebased = false;
            }

            return rtree.search(extentRectangle(extent))
                .map(function(id) { return graph.entity(id); });
        },

        graph: function() {
            return graph;
        }

    };

    return tree;
};
iD.Way = iD.Entity.way = function iD_Way() {
    if (!(this instanceof iD_Way)) {
        return (new iD_Way()).initialize(arguments);
    } else if (arguments.length) {
        this.initialize(arguments);
    }
};

iD.Way.prototype = Object.create(iD.Entity.prototype);

_.extend(iD.Way.prototype, {
    type: "way",
    nodes: [],

    extent: function(resolver) {
        return resolver.transient(this, 'extent', function() {
            return this.nodes.reduce(function(extent, id) {
                return extent.extend(resolver.entity(id).extent(resolver));
            }, iD.geo.Extent());
        });
    },

    first: function() {
        return this.nodes[0];
    },

    last: function() {
        return this.nodes[this.nodes.length - 1];
    },

    contains: function(node) {
        return this.nodes.indexOf(node) >= 0;
    },

    isOneWay: function() {
        return this.tags.oneway === 'yes' ||
            this.tags.waterway === 'river' ||
            this.tags.waterway === 'stream';
    },

    isClosed: function() {
        return this.nodes.length > 0 && this.first() === this.last();
    },

    isArea: function() {
        if (this.tags.area === 'yes')
            return true;
        if (!this.isClosed() || this.tags.area === 'no')
            return false;
        for (var key in this.tags)
            if (key in iD.Way.areaKeys && !(this.tags[key] in iD.Way.areaKeys[key]))
                return true;
        return false;
    },

    isDegenerate: function() {
        return _.uniq(this.nodes).length < (this.isArea() ? 3 : 2);
    },

    areAdjacent: function(n1, n2) {
        for (var i = 0; i < this.nodes.length; i++) {
            if (this.nodes[i] === n1) {
                if (this.nodes[i - 1] === n2) return true;
                if (this.nodes[i + 1] === n2) return true;
            }
        }
        return false;
    },

    geometry: function() {
        return this.isArea() ? 'area' : 'line';
    },

    addNode: function(id, index) {
        var nodes = this.nodes.slice();
        nodes.splice(index === undefined ? nodes.length : index, 0, id);
        return this.update({nodes: nodes});
    },

    updateNode: function(id, index) {
        var nodes = this.nodes.slice();
        nodes.splice(index, 1, id);
        return this.update({nodes: nodes});
    },

    replaceNode: function(needle, replacement) {
        if (this.nodes.indexOf(needle) < 0)
            return this;

        var nodes = this.nodes.slice();
        for (var i = 0; i < nodes.length; i++) {
            if (nodes[i] === needle) {
                nodes[i] = replacement;
            }
        }
        return this.update({nodes: nodes});
    },

    removeNode: function(id) {
        var nodes = _.without(this.nodes, id);

        // Preserve circularity
        if (this.nodes.length > 1 && this.first() === id && this.last() === id) {
            nodes.push(nodes[0]);
        }

        return this.update({nodes: nodes});
    },

    asJXON: function(changeset_id) {
        var r = {
            way: {
                '@id': this.osmId(),
                '@version': this.version || 0,
                nd: _.map(this.nodes, function(id) {
                    return { keyAttributes: { ref: iD.Entity.id.toOSM(id) } };
                }),
                tag: _.map(this.tags, function(v, k) {
                    return { keyAttributes: { k: k, v: v } };
                })
            }
        };
        if (changeset_id) r.way['@changeset'] = changeset_id;
        return r;
    },

    asGeoJSON: function(resolver, close) {

        var childnodes = resolver.childNodes(this);

        // Close unclosed way
        if (close && !this.isClosed() && childnodes.length) {
            childnodes = childnodes.concat([childnodes[0]]);
        }

        if (this.isArea() && (close || this.isClosed())) {
            return {
                type: 'Feature',
                properties: this.tags,
                geometry: {
                    type: 'Polygon',
                    coordinates: [_.pluck(childnodes, 'loc')]
                }
            };
        } else {
            return {
                type: 'Feature',
                properties: this.tags,
                geometry: {
                    type: 'LineString',
                    coordinates: _.pluck(childnodes, 'loc')
                }
            };
        }
    }
});

// A closed way is considered to be an area if it has a tag with one
// of the following keys, and the value is _not_ one of the associated
// values for the respective key.
iD.Way.areaKeys = {
    area: {},
    building: {},
    leisure: {},
    tourism: {},
    ruins: {},
    historic: {},
    landuse: {},
    military: {},
    natural: { coastline: true },
    amenity: {},
    shop: {},
    man_made: {},
    public_transport: {},
    place: {},
    aeroway: {},
    waterway: {}
};
iD.Background = function() {
    var tileSize = 256,
        tile = d3.geo.tile(),
        projection,
        cache = {},
        offset = [0, 0],
        tileOrigin,
        z,
        transformProp = iD.util.prefixCSSProperty('Transform'),
        source = d3.functor('');

    function tileSizeAtZoom(d, z) {
        return Math.ceil(tileSize * Math.pow(2, z - d[2])) / tileSize;
    }

    function atZoom(t, distance) {
        var power = Math.pow(2, distance);
        return [
            Math.floor(t[0] * power),
            Math.floor(t[1] * power),
            t[2] + distance];
    }

    function lookUp(d) {
        for (var up = -1; up > -d[2]; up--) {
            if (cache[atZoom(d, up)] !== false) return atZoom(d, up);
        }
    }

    function uniqueBy(a, n) {
        var o = [], seen = {};
        for (var i = 0; i < a.length; i++) {
            if (seen[a[i][n]] === undefined) {
                o.push(a[i]);
                seen[a[i][n]] = true;
            }
        }
        return o;
    }

    function addSource(d) {
        d.push(source(d));
        return d;
    }

    // Update tiles based on current state of `projection`.
    function background(selection) {
        tile.scale(projection.scale())
            .translate(projection.translate());

        tileOrigin = [
            projection.scale() / 2 - projection.translate()[0],
            projection.scale() / 2 - projection.translate()[1]];

        z = Math.max(Math.log(projection.scale()) / Math.log(2) - 8, 0);

        render(selection);
    }

    // Derive the tiles onscreen, remove those offscreen and position them.
    // Important that this part not depend on `projection` because it's
    // rentered when tiles load/error (see #644).
    function render(selection) {
        var requests = [];

        tile().forEach(function(d) {
            addSource(d);
            requests.push(d);
            if (cache[d[3]] === false && lookUp(d)) {
                requests.push(addSource(lookUp(d)));
            }
        });

        requests = uniqueBy(requests, 3).filter(function(r) {
            // don't re-request tiles which have failed in the past
            return cache[r[3]] !== false;
        });

        var pixelOffset = [
            Math.round(offset[0] * Math.pow(2, z)),
            Math.round(offset[1] * Math.pow(2, z))
        ];

        function load(d) {
            cache[d[3]] = true;
            d3.select(this)
                .on('load', null)
                .classed('tile-loaded', true);
            render(selection);
        }

        function error(d) {
            cache[d[3]] = false;
            d3.select(this)
                .on('load', null)
                .remove();
            render(selection);
        }

        function imageTransform(d) {
            var _ts = tileSize * Math.pow(2, z - d[2]);
            var scale = tileSizeAtZoom(d, z);
            return 'translate(' +
                (Math.round((d[0] * _ts) - tileOrigin[0]) + pixelOffset[0]) + 'px,' +
                (Math.round((d[1] * _ts) - tileOrigin[1]) + pixelOffset[1]) + 'px)' +
                'scale(' + scale + ',' + scale + ')';
        }

        var image = selection
            .selectAll('img')
            .data(requests, function(d) { return d[3]; });

        image.exit()
            .style(transformProp, imageTransform)
            .classed('tile-loaded', false)
            .each(function() {
                var tile = this;
                window.setTimeout(function() {
                    // this tile may already be removed
                    if (tile.parentNode) {
                        tile.parentNode.removeChild(tile);
                    }
                }, 300);
            });

        image.enter().append('img')
            .attr('class', 'tile')
            .attr('src', function(d) { return d[3]; })
            .on('error', error)
            .on('load', load);

        image.style(transformProp, imageTransform);
    }

    background.offset = function(_) {
        if (!arguments.length) return offset;
        offset = _;
        return background;
    };

    background.nudge = function(_, zoomlevel) {
        offset[0] += _[0] / Math.pow(2, zoomlevel);
        offset[1] += _[1] / Math.pow(2, zoomlevel);
        return background;
    };

    background.projection = function(_) {
        if (!arguments.length) return projection;
        projection = _;
        return background;
    };

    background.size = function(_) {
        if (!arguments.length) return tile.size();
        tile.size(_);
        return background;
    };

    function setHash(source) {
        var tag = source.data.sourcetag;
        var q = iD.util.stringQs(location.hash.substring(1));
        if (tag) {
            location.replace('#' + iD.util.qsString(_.assign(q, {
                layer: tag
            }), true));
        } else {
            location.replace('#' + iD.util.qsString(_.omit(q, 'layer'), true));
        }
    }

    background.dispatch = d3.dispatch('change');

    background.source = function(_) {
        if (!arguments.length) return source;
        source = _;
        cache = {};
        tile.scaleExtent((source.data && source.data.scaleExtent) || [1, 20]);
        setHash(source);
        background.dispatch.change();
        return background;
    };

    return d3.rebind(background, background.dispatch, 'on');
};
iD.BackgroundSource = {};

// derive the url of a 'quadkey' style tile from a coordinate object
iD.BackgroundSource.template = function(data) {

    function generator(coord) {
        var u = '';
        for (var zoom = coord[2]; zoom > 0; zoom--) {
            var b = 0;
            var mask = 1 << (zoom - 1);
            if ((coord[0] & mask) !== 0) b++;
            if ((coord[1] & mask) !== 0) b += 2;
            u += b.toString();
        }

        return data.template
            .replace('{t}', data.subdomains ?
                data.subdomains[coord[2] % data.subdomains.length] : '')
            .replace('{u}', u)
            .replace('{x}', coord[0])
            .replace('{y}', coord[1])
            .replace('{z}', coord[2])
            // JOSM style
            .replace('{zoom}', coord[2])
            .replace(/\{(switch\:[^\}]*)\}/, function(s, r) {
                var subdomains = r.split(':')[1].split(',');
                return subdomains[coord[2] % subdomains.length];
            });
    }

    generator.data = data;
    generator.copyrightNotices = function() {};

    return generator;
};

iD.BackgroundSource.Bing = function(data, dispatch) {
    // http://msdn.microsoft.com/en-us/library/ff701716.aspx
    // http://msdn.microsoft.com/en-us/library/ff701701.aspx

    var bing = iD.BackgroundSource.template(data),
        key = 'Arzdiw4nlOJzRwOz__qailc8NiR31Tt51dN2D7cm57NrnceZnCpgOkmJhNpGoppU', // Same as P2 and JOSM
        url = 'http://dev.virtualearth.net/REST/v1/Imagery/Metadata/Aerial?include=ImageryProviders&key=' +
            key + '&jsonp={callback}',
        providers = [];

    d3.jsonp(url, function(json) {
        providers = json.resourceSets[0].resources[0].imageryProviders.map(function(provider) {
            return {
                attribution: provider.attribution,
                areas: provider.coverageAreas.map(function(area) {
                    return {
                        zoom: [area.zoomMin, area.zoomMax],
                        extent: iD.geo.Extent([area.bbox[1], area.bbox[0]], [area.bbox[3], area.bbox[2]])
                    };
                })
            };
        });
        dispatch.change();
    });

    bing.copyrightNotices = function(zoom, extent) {
        zoom = Math.min(zoom, 21);
        return providers.filter(function(provider) {
            return _.any(provider.areas, function(area) {
                return extent.intersects(area.extent) &&
                    area.zoom[0] <= zoom &&
                    area.zoom[1] >= zoom;
            });
        }).map(function(provider) {
            return provider.attribution;
        }).join(', ');
    };

    return bing;
};

iD.BackgroundSource.Custom = function() {
    var template = window.prompt('Enter a tile template. ' +
        'Valid tokens are {z}, {x}, {y} for Z/X/Y scheme and {u} for quadtile scheme.');
    if (!template) return null;
    return iD.BackgroundSource.template({
        template: template,
        name: 'Custom'
    });
};

iD.BackgroundSource.Custom.data = { 'name': 'Custom' };
iD.LocalGpx = function(context) {
    var tileSize = 256,
        projection,
        gj = {},
        enable = true,
        size = [0, 0],
        transformProp = iD.util.prefixCSSProperty('Transform'),
        path = d3.geo.path().projection(projection),
        source = d3.functor('');

    function render(selection) {

        path.projection(projection);

        var surf = selection.selectAll('svg')
            .data(enable ? [gj] : []);

        surf.exit().remove();

        surf.enter()
            .append('svg')
            .style('position', 'absolute');

        var paths = surf
            .selectAll('path')
            .data(function(d) { return [d]; });

        paths
            .enter()
            .append('path')
            .attr('class', 'gpx');

        paths
            .attr('d', path);
    }

    function toDom(x) {
        return (new DOMParser()).parseFromString(x, 'text/xml');
    }

    render.projection = function(_) {
        if (!arguments.length) return projection;
        projection = _;
        return render;
    };

    render.enable = function(_) {
        if (!arguments.length) return enable;
        enable = _;
        return render;
    };

    render.geojson = function(_) {
        if (!arguments.length) return gj;
        gj = _;
        return render;
    };

    render.size = function(_) {
        if (!arguments.length) return size;
        size = _;
        return render;
    };

    render.id = 'layer-gpx';

    function over() {
        d3.event.stopPropagation();
        d3.event.preventDefault();
        d3.event.dataTransfer.dropEffect = 'copy';
    }

    d3.select('body')
        .attr('dropzone', 'copy')
        .on('drop.localgpx', function() {
            d3.event.stopPropagation();
            d3.event.preventDefault();
            var f = d3.event.dataTransfer.files[0],
                reader = new FileReader();

            reader.onload = function(e) {
                render.geojson(toGeoJSON.gpx(toDom(e.target.result)));
                context.redraw();
                context.map().pan([0, 0]);
            };

            reader.readAsText(f);
        })
        .on('dragenter.localgpx', over)
        .on('dragexit.localgpx', over)
        .on('dragover.localgpx', over);

    return render;
};
iD.Map = function(context) {
    var dimensions = [1, 1],
        dispatch = d3.dispatch('move', 'drawn'),
        projection = d3.geo.mercator().scale(1024),
        roundedProjection = iD.svg.RoundProjection(projection),
        zoom = d3.behavior.zoom()
            .translate(projection.translate())
            .scale(projection.scale())
            .scaleExtent([1024, 256 * Math.pow(2, 24)])
            .on('zoom', zoomPan),
        dblclickEnabled = true,
        transformStart,
        minzoom = 0,
        layers = [
            iD.Background().projection(projection),
            iD.LocalGpx(context).projection(projection)],
        transformProp = iD.util.prefixCSSProperty('Transform'),
        points = iD.svg.Points(roundedProjection, context),
        vertices = iD.svg.Vertices(roundedProjection, context),
        lines = iD.svg.Lines(projection),
        areas = iD.svg.Areas(roundedProjection),
        midpoints = iD.svg.Midpoints(roundedProjection),
        labels = iD.svg.Labels(roundedProjection, context),
        tail = iD.ui.Tail(),
        surface, layergroup;

    function map(selection) {
        context.history()
            .on('change.map', redraw);

        selection.call(zoom);

        layergroup = selection.append('div')
            .attr('id', 'layer-g');

        var supersurface = selection.append('div')
            .style('position', 'absolute');

        surface = supersurface.append('svg')
            .on('mousedown.zoom', function() {
                if (d3.event.button == 2) {
                    d3.event.stopPropagation();
                }
            }, true)
            .on('mouseup.zoom', function() {
                if (resetTransform()) redraw();
            })
            .attr('id', 'surface')
            .call(iD.svg.Surface());

        map.size(selection.size());
        map.surface = surface;
        map.layersurface = layergroup;

        supersurface
            .call(tail);
    }

    function pxCenter() { return [dimensions[0] / 2, dimensions[1] / 2]; }

    function drawVector(difference) {
        var filter, all,
            extent = map.extent(),
            graph = context.graph();

        if (!difference) {
            all = context.intersects(extent);
            filter = d3.functor(true);
        } else {
            var complete = difference.complete(extent);
            all = _.compact(_.values(complete));
            filter = function(d) {
                if (d.type === 'midpoint') {
                    var a = graph.entity(d.edge[0]),
                        b = graph.entity(d.edge[1]);
                    return !a || !b ||
                        _.intersection(graph.parentWays(a), all).length ||
                        _.intersection(graph.parentWays(b), all).length;
                } else {
                    return d.id in complete;
                }
            };
        }

        if (all.length > 100000) {
            editOff();
        } else {
            surface
                .call(points, graph, all, filter)
                .call(vertices, graph, all, filter, map.zoom())
                .call(lines, graph, all, filter, dimensions)
                .call(areas, graph, all, filter)
                .call(midpoints, graph, all, filter, extent)
                .call(labels, graph, all, filter, dimensions, !difference);
        }
        dispatch.drawn(map);
    }

    function editOff() {
        surface.selectAll('.layer *').remove();
    }

    function zoomPan() {
        if (d3.event && d3.event.sourceEvent.type === 'dblclick') {
            if (!dblclickEnabled) {
                zoom.scale(projection.scale())
                    .translate(projection.translate());
                return d3.event.sourceEvent.preventDefault();
            }
        }

        if (Math.log(d3.event.scale / Math.LN2 - 8) < minzoom + 1) {
            iD.ui.flash(context.container())
                .select('.content')
                .text('Cannot zoom out further in current mode.');
            return setZoom(16, true);
        }

        projection
            .translate(d3.event.translate)
            .scale(d3.event.scale);

        var ascale = d3.event.scale;
        var bscale = transformStart[0];
        var scale = (ascale / bscale);

        var tX = Math.round((d3.event.translate[0] / scale) - (transformStart[1][0]));
        var tY = Math.round((d3.event.translate[1] / scale) - (transformStart[1][1]));

        var transform =
            'scale(' + scale + ')' +
            'translate(' + tX + 'px,' + tY + 'px) ';

        layergroup.style(transformProp, transform);
        surface.style(transformProp, transform);
        queueRedraw();

        dispatch.move(map);
    }

    function resetTransform() {
        var prop = surface.node().style[transformProp];
        if (!prop || prop === 'none') return false;
        surface.node().style[transformProp] = '';
        layergroup.node().style[transformProp] = '';
        return true;
    }

    function redraw(difference) {

        if (!surface) return;

        clearTimeout(timeoutId);

        // If we are in the middle of a zoom/pan, we can't do differenced redraws.
        // It would result in artifacts where differenced entities are redrawn with
        // one transform and unchanged entities with another.
        if (resetTransform()) {
            difference = undefined;
        }

        var zoom = String(~~map.zoom());
        if (surface.attr('data-zoom') !== zoom) {
            surface.attr('data-zoom', zoom);
        }

        if (!difference) {
            var sel = layergroup
                .selectAll('.layer-layer')
                .data(layers);

            sel.exit().remove();

            sel.enter().append('div')
                .attr('class', 'layer-layer');

            sel.each(function(layer) {
                    d3.select(this).call(layer);
                });
        }

        if (map.editable()) {
            context.connection().loadTiles(projection, dimensions);
            drawVector(difference);
        } else {
            editOff();
        }

        transformStart = [
            projection.scale(),
            projection.translate().slice()];

        return map;
    }

    var timeoutId;
    function queueRedraw() {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(function() { redraw(); }, 300);
    }

    function pointLocation(p) {
        var translate = projection.translate(),
            scale = projection.scale();
        return [(p[0] - translate[0]) / scale, (p[1] - translate[1]) / scale];
    }

    function locationPoint(l) {
        var translate = projection.translate(),
            scale = projection.scale();
        return [l[0] * scale + translate[0], l[1] * scale + translate[1]];
    }

    map.mouseCoordinates = function() {
        try {
            return projection.invert(d3.mouse(surface.node()));
        } catch(e) {
            // when called with hidden elements, d3.mouse() will throw
            return [NaN, NaN];
        }
    };

    map.dblclickEnable = function(_) {
        if (!arguments.length) return dblclickEnabled;
        dblclickEnabled = _;
        return map;
    };

    function setZoom(z, force) {
        if (z === map.zoom() && !force)
            return false;
        var scale = 256 * Math.pow(2, z),
            center = pxCenter(),
            l = pointLocation(center);
        scale = Math.max(1024, Math.min(256 * Math.pow(2, 24), scale));
        projection.scale(scale);
        zoom.scale(projection.scale());
        var t = projection.translate();
        l = locationPoint(l);
        t[0] += center[0] - l[0];
        t[1] += center[1] - l[1];
        projection.translate(t);
        zoom.translate(projection.translate());
        return true;
    }

    function setCenter(loc) {
        var t = projection.translate(),
            c = pxCenter(),
            ll = projection(loc);
        if (ll[0] === c[0] && ll[1] === c[1])
            return false;
        projection.translate([
            t[0] - ll[0] + c[0],
            t[1] - ll[1] + c[1]]);
        zoom.translate(projection.translate());
        return true;
    }

    map.pan = function(d) {
        var t = projection.translate();
        t[0] += d[0];
        t[1] += d[1];
        projection.translate(t);
        zoom.translate(projection.translate());
        return redraw();
    };

    map.size = function(_) {
        if (!arguments.length) return dimensions;
        var center = map.center();
        dimensions = _;
        surface.size(dimensions);
        layers.map(function(l) {
            l.size(dimensions);
        });
        projection.clipExtent([[0, 0], dimensions]);
        setCenter(center);
        return redraw();
    };

    map.zoomIn = function() { return map.zoom(Math.ceil(map.zoom() + 1)); };
    map.zoomOut = function() { return map.zoom(Math.floor(map.zoom() - 1)); };

    map.center = function(loc) {
        if (!arguments.length) {
            return projection.invert(pxCenter());
        }

        if (setCenter(loc)) {
            dispatch.move(map);
        }

        return redraw();
    };

    map.zoom = function(z) {
        if (!arguments.length) {
            return Math.max(Math.log(projection.scale()) / Math.LN2 - 8, 0);
        }

        if (setZoom(z)) {
            dispatch.move(map);
        }

        return redraw();
    };

    map.centerZoom = function(loc, z) {
        var centered = setCenter(loc),
            zoomed   = setZoom(z);

        if (centered || zoomed) {
            dispatch.move(map);
        }

        return redraw();
    };

    map.centerEase = function(loc) {
        var from = map.center().slice(),
            t = 0,
            stop;

        surface.one('mousedown.ease', function() {
            stop = true;
        });

        d3.timer(function() {
            if (stop) return true;
            map.center(iD.geo.interp(from, loc, (t += 1) / 10));
            return t == 10;
        }, 20);
        return map;
    };

    map.extent = function(_) {
        if (!arguments.length) {
            return new iD.geo.Extent(projection.invert([0, dimensions[1]]),
                                 projection.invert([dimensions[0], 0]));
        } else {
            var extent = iD.geo.Extent(_);
            map.centerZoom(extent.center(), map.extentZoom(extent));
        }
    };

    map.extentZoom = function(_) {
        var extent = iD.geo.Extent(_),
            tl = projection([extent[0][0], extent[1][1]]),
            br = projection([extent[1][0], extent[0][1]]);

        // Calculate maximum zoom that fits extent
        var hFactor = (br[0] - tl[0]) / dimensions[0],
            vFactor = (br[1] - tl[1]) / dimensions[1],
            hZoomDiff = Math.log(Math.abs(hFactor)) / Math.LN2,
            vZoomDiff = Math.log(Math.abs(vFactor)) / Math.LN2,
            newZoom = map.zoom() - Math.max(hZoomDiff, vZoomDiff);

        return newZoom;
    };

    map.flush = function() {
        context.connection().flush();
        context.history().reset();
        return map;
    };

    var usedTails = {};
    map.tail = function(_) {
        if (!_ || usedTails[_] === undefined) {
            tail.text(_);
            usedTails[_] = true;
        }
        return map;
    };

    map.editable = function() {
        return map.zoom() >= 16;
    };

    map.minzoom = function(_) {
        if (!arguments.length) return minzoom;
        minzoom = _;
        return map;
    };

    map.layers = layers;
    map.projection = projection;
    map.redraw = redraw;

    return d3.rebind(map, dispatch, 'on');
};
iD.svg = {
    RoundProjection: function(projection) {
        return function(d) {
            return iD.geo.roundCoords(projection(d));
        };
    },

    PointTransform: function(projection) {
        return function(entity) {
            // http://jsperf.com/short-array-join
            var pt = projection(entity.loc);
            return 'translate(' + pt[0] + ',' + pt[1] + ')';
        };
    },

    LineString: function(projection, graph, dimensions, dx) {
        var cache = {};

        return function(entity) {
            if (cache[entity.id] !== undefined) {
                return cache[entity.id];
            }

            var last,
                next,
                started = false,
                d = '';

            d3.geo.stream({
                type: 'LineString',
                coordinates: graph.childNodes(entity).map(function(n) {
                    return n.loc;
                })
            }, projection.stream({
                lineStart: function() { last = null; started = false; },
                lineEnd: function() { },
                point: function(x, y) {
                    if (!started) d += 'M';
                    next = [Math.floor(x), Math.floor(y)];
                    if (dx && last && iD.geo.dist(last, next) > dx) {
                        var span = iD.geo.dist(last, next),
                            angle = Math.atan2(next[1] - last[1], next[0] - last[0]),
                            to = last.slice();
                        to[0] += Math.cos(angle) * dx;
                        to[1] += Math.sin(angle) * dx;
                        while (iD.geo.dist(last, to) < (span)) {
                            // a dx-length line segment in that angle
                            if (started) d += 'L';
                            d += Math.floor(to[0]) + ',' + Math.floor(to[1]);
                            started = started || true;
                            to[0] += Math.cos(angle) * dx;
                            to[1] += Math.sin(angle) * dx;
                        }
                    }
                    if (started) d += 'L';
                    d += next[0] + ',' + next[1];
                    started = started || true;
                    last = next;
                }
            }));

            if (d === '') {
                cache[entity.id] = null;
                return cache[entity.id];
            } else {
                cache[entity.id] = d;
                return cache[entity.id];
            }
        };
    },

    MultipolygonMemberTags: function(graph) {
        return function(entity) {
            var tags = entity.tags;
            graph.parentRelations(entity).forEach(function(relation) {
                if (relation.isMultipolygon()) {
                    tags = _.extend({}, relation.tags, tags);
                }
            });
            return tags;
        };
    }
};
iD.svg.Areas = function(projection) {
    // For fixing up rendering of multipolygons with tags on the outer member.
    // https://github.com/systemed/iD/issues/613
    function isSimpleMultipolygonOuterMember(entity, graph) {
        if (entity.type !== 'way')
            return false;

        var parents = graph.parentRelations(entity);
        if (parents.length !== 1)
            return false;

        var parent = parents[0];
        if (!parent.isMultipolygon() || Object.keys(parent.tags).length > 1)
            return false;

        var members = parent.members, member;
        for (var i = 0; i < members.length; i++) {
            member = members[i];
            if (member.id === entity.id && member.role && member.role !== 'outer')
                return false; // Not outer member
            if (member.id !== entity.id && (!member.role || member.role === 'outer'))
                return false; // Not a simple multipolygon
        }

        return parent;
    }

    // Patterns only work in Firefox when set directly on element
    var patterns = {
        wetland: 'wetland',
        beach: 'beach',
        scrub: 'scrub',
        construction: 'construction',
        cemetery: 'cemetery',
        grave_yard: 'cemetery',
        meadow: 'meadow',
        farm: 'farmland',
        farmland: 'farmland',
        orchard: 'orchard'
    };

    var patternKeys = ['landuse', 'natural', 'amenity'];

    function setPattern(selection) {
        selection.each(function(d) {
            for (var i = 0; i < patternKeys.length; i++) {
                if (patterns.hasOwnProperty(d.tags[patternKeys[i]])) {
                    this.style.fill = 'url("#pattern-' + patterns[d.tags[patternKeys[i]]] + '")';
                    return;
                }
            }
            this.style.fill = '';
        });
    }

    return function drawAreas(surface, graph, entities, filter) {
        var path = d3.geo.path().projection(projection),
            areas = {},
            multipolygon;

        for (var i = 0; i < entities.length; i++) {
            var entity = entities[i];
            if (entity.geometry(graph) !== 'area') continue;

            if (multipolygon = isSimpleMultipolygonOuterMember(entity, graph)) {
                areas[multipolygon.id] = {
                    entity: multipolygon.mergeTags(entity.tags),
                    area: Math.abs(path.area(entity.asGeoJSON(graph, true)))
                };
            } else if (!areas[entity.id]) {
                areas[entity.id] = {
                    entity: entity,
                    area: Math.abs(path.area(entity.asGeoJSON(graph, true)))
                };
            }
        }

        areas = d3.values(areas);
        areas.sort(function(a, b) { return b.area - a.area; });

        function drawPaths(group, areas, filter, klass, closeWay) {
            var tagClasses = iD.svg.TagClasses();

            if (klass === 'stroke') {
                tagClasses.tags(iD.svg.MultipolygonMemberTags(graph));
            }

            var paths = group.selectAll('path.area')
                .filter(filter)
                .data(areas, iD.Entity.key);

            paths.enter()
                .append('path')
                .attr('class', function(d) { return d.type + ' area ' + klass; });

            paths
                .order()
                .attr('d', function(entity) { return path(entity.asGeoJSON(graph, closeWay)); })
                .call(tagClasses)
                .call(iD.svg.MemberClasses(graph));

            if (klass === 'fill') paths.call(setPattern);

            paths.exit()
                .remove();

            return paths;
        }

        areas = _.pluck(areas, 'entity');

        var strokes = areas.filter(function(area) {
            return area.type === 'way';
        });

        var shadow = surface.select('.layer-shadow'),
            fill   = surface.select('.layer-fill'),
            stroke = surface.select('.layer-stroke');

        drawPaths(shadow, strokes, filter, 'shadow');
        drawPaths(fill, areas, filter, 'fill', true);
        drawPaths(stroke, strokes, filter, 'stroke');
    };
};
iD.svg.Labels = function(projection, context) {

    // Replace with dict and iterate over entities tags instead?
    var label_stack = [
        ['line', 'aeroway'],
        ['line', 'highway'],
        ['line', 'railway'],
        ['line', 'waterway'],
        ['area', 'aeroway'],
        ['area', 'amenity'],
        ['area', 'building'],
        ['area', 'historic'],
        ['area', 'leisure'],
        ['area', 'man_made'],
        ['area', 'natural'],
        ['area', 'shop'],
        ['area', 'tourism'],
        ['point', 'aeroway'],
        ['point', 'amenity'],
        ['point', 'building'],
        ['point', 'historic'],
        ['point', 'leisure'],
        ['point', 'man_made'],
        ['point', 'natural'],
        ['point', 'shop'],
        ['point', 'tourism'],
        ['line', 'name'],
        ['area', 'name'],
        ['point', 'name']
    ];

    var default_size = 12;

    var font_sizes = label_stack.map(function(d) {
        var style = iD.util.getStyle('text.' + d[0] + '.tag-' + d[1]),
            m = style && style.cssText.match("font-size: ([0-9]{1,2})px;");
        if (m) return parseInt(m[1], 10);

        style = iD.util.getStyle('text.' + d[0]);
        m = style && style.cssText.match("font-size: ([0-9]{1,2})px;");
        if (m) return parseInt(m[1], 10);

        return default_size;
    });

    var iconSize = 18;

    var pointOffsets = [
        [15, -11, 'start'], // right
        [10, -11, 'start'], // unused right now
        [-15, -11, 'end']
    ];

    var lineOffsets = [50, 45, 55, 40, 60, 35, 65, 30, 70, 25,
        75, 20, 80, 15, 95, 10, 90, 5, 95];


    var noIcons = ['building', 'landuse', 'natural'];
    function blacklisted(preset) {
        return _.any(noIcons, function(s) {
            return preset.id.indexOf(s) >= 0;
        });
    }

    function get(array, prop) {
        return function(d, i) { return array[i][prop]; };
    }

    var textWidthCache = {};

    function textWidth(text, size, elem) {
        var c = textWidthCache[size];
        if (!c) c = textWidthCache[size] = {};

        if (c[text]) {
            return c[text];

        } else if (elem) {
            c[text] = elem.getComputedTextLength();
            return c[text];

        } else {
            return size / 3 * 2 * text.length;
        }
    }

    function drawLineLabels(group, entities, filter, classes, labels) {

        var texts = group.selectAll('text.' + classes)
            .filter(filter)
            .data(entities, iD.Entity.key);

        var tp = texts.enter()
            .append('text')
            .attr('class', function(d, i) { return classes + ' ' + labels[i].classes;})
            .append('textPath')
            .attr('class', 'textpath');


        var tps = texts.selectAll('.textpath')
            .filter(filter)
            .data(entities, iD.Entity.key)
            .attr({
                'startOffset': '50%',
                'xlink:href': function(d) { return '#labelpath-' + d.id; }
            })
            .text(function(d) { return name(d); });

        texts.exit().remove();

    }

    function drawLinePaths(group, entities, filter, classes, labels) {

        var halos = group.selectAll('path')
            .filter(filter)
            .data(entities, iD.Entity.key);

        halos.enter()
            .append('path')
            .style('stroke-width', get(labels, 'font-size'))
            .attr('id', function(d) { return 'labelpath-' + d.id; })
            .attr('class', classes);

        halos.attr('d', get(labels, 'lineString'));

        halos.exit().remove();
    }

    function drawPointLabels(group, entities, filter, classes, labels) {

        var texts = group.selectAll('text.' + classes)
            .filter(filter)
            .data(entities, iD.Entity.key);

        texts.enter()
            .append('text')
            .attr('class', function(d, i) { return classes + ' ' + labels[i].classes; });

        texts.attr('x', get(labels, 'x'))
            .attr('y', get(labels, 'y'))
            .style('text-anchor', get(labels, 'textAnchor'))
            .text(function(d) { return name(d); })
            .each(function(d, i) { textWidth(name(d), labels[i].height, this); });

        texts.exit().remove();
        return texts;
    }

    function drawAreaHalos(group, entities, filter, classes, labels) {
        entities = entities.filter(hasText);
        labels = labels.filter(hasText);
        return drawPointHalos(group, entities, filter, classes, labels);

        function hasText(d, i) {
            return labels[i].hasOwnProperty('x') && labels[i].hasOwnProperty('y');
        }
    }

    function drawAreaLabels(group, entities, filter, classes, labels) {
        entities = entities.filter(hasText);
        labels = labels.filter(hasText);
        return drawPointLabels(group, entities, filter, classes, labels);

        function hasText(d, i) {
            return labels[i].hasOwnProperty('x') && labels[i].hasOwnProperty('y');
        }
    }

    function drawAreaIcons(group, entities, filter, classes, labels) {

        var icons = group.selectAll('use')
            .filter(filter)
            .data(entities, iD.Entity.key);

        icons.enter()
            .append('use')
            .attr('clip-path', 'url(#clip-square-18)')
            .attr('class', 'icon');

        icons.attr('transform', get(labels, 'transform'))
            .attr('xlink:href', function(d) {
                return '#maki-' + context.presets().match(d, context.graph()).icon + '-18';
            });


        icons.exit().remove();
    }

    function reverse(p) {
        var angle = Math.atan2(p[1][1] - p[0][1], p[1][0] - p[0][0]);
        return !(p[0][0] < p[p.length - 1][0] && angle < Math.PI/2 && angle > - Math.PI/2);
    }

    function lineString(nodes) {
        return 'M' + nodes.join('L');
    }

    function subpath(nodes, from, to) {
        function segmentLength(i) {
            var dx = nodes[i][0] - nodes[i + 1][0];
            var dy = nodes[i][1] - nodes[i + 1][1];
            return Math.sqrt(dx * dx + dy * dy);
        }

        var sofar = 0,
            start, end, i0, i1;
        for (var i = 0; i < nodes.length - 1; i++) {
            var current = segmentLength(i);
            var portion;
            if (!start && sofar + current >= from) {
                portion = (from - sofar) / current;
                start = [
                    nodes[i][0] + portion * (nodes[i + 1][0] - nodes[i][0]),
                    nodes[i][1] + portion * (nodes[i + 1][1] - nodes[i][1])
                ];
                i0 = i + 1;
            }
            if (!end && sofar + current >= to) {
                portion = (to - sofar) / current;
                end = [
                    nodes[i][0] + portion * (nodes[i + 1][0] - nodes[i][0]),
                    nodes[i][1] + portion * (nodes[i + 1][1] - nodes[i][1])
                ];
                i1 = i + 1;
            }
            sofar += current;

        }
        var ret = nodes.slice(i0, i1);
        ret.unshift(start);
        ret.push(end);
        return ret;

    }


    function hideOnMouseover() {
        var mouse = mousePosition(d3.event),
            pad = 50,
            rect = new RTree.Rectangle(mouse[0] - pad, mouse[1] - pad, 2*pad, 2*pad),
            labels = _.pluck(rtree.search(rect, this), 'leaf'),
            containsLabel = d3.set(labels),
            selection = d3.select(this);

        // ensures that simply resetting opacity
        // does not force style recalculation
        function resetOpacity() {
            if (this._opacity !== '') {
                this.style.opacity = '';
                this._opacity = '';
            }
        }

        selection.selectAll('.layer-label text, .layer-halo path, .layer-halo text')
            .each(resetOpacity);

        if (!labels.length) return;
        selection.selectAll('.layer-label text, .layer-halo path, .layer-halo text')
            .filter(function(d) {
                return containsLabel.has(d.id);
            })
            .style('opacity', 0)
            .property('_opacity', 0);
    }

    function name(d) {
        return d.tags[lang] || d.tags.name;
    }

    var rtree = new RTree(),
        rectangles = {},
        lang = 'name:' + iD.detect().locale.toLowerCase().split('-')[0],
        supersurface, mousePosition, cacheDimensions;

    return function drawLabels(surface, graph, entities, filter, dimensions, fullRedraw) {

        if (!mousePosition || dimensions.join(',') !== cacheDimensions) {
            mousePosition = iD.util.fastMouse(surface.node().parentNode);
            cacheDimensions = dimensions.join(',');
        }

        if (!supersurface) {
            supersurface = d3.select(surface.node().parentNode)
                .on('mousemove.hidelabels', hideOnMouseover)
                .on('mousedown.hidelabels', function() {
                    supersurface.on('mousemove.hidelabels', null);
                })
                .on('mouseup.hidelabels', function() {
                    supersurface.on('mousemove.hidelabels', hideOnMouseover);
                });
        }

        var hidePoints = !surface.select('.node.point').node();

        var labelable = [], i, k, entity;
        for (i = 0; i < label_stack.length; i++) labelable.push([]);

        if (fullRedraw) {
            rtree = new RTree();
            rectangles = {};
        } else {
            for (i = 0; i < entities.length; i++) {
                rtree.remove(rectangles[entities[i].id], entities[i].id);
            }
        }

        // Split entities into groups specified by label_stack
        for (i = 0; i < entities.length; i++) {
            entity = entities[i];
            var geometry = entity.geometry(graph),
                preset = geometry === 'area' && context.presets().match(entity, graph),
                icon = preset && !blacklisted(preset) && preset.icon;

            if ((name(entity) || icon) && !(hidePoints && geometry === 'point')) {

                for (k = 0; k < label_stack.length; k ++) {
                    if (entity.geometry(graph) === label_stack[k][0] &&
                        entity.tags[label_stack[k][1]]) {
                        labelable[k].push(entity);
                        break;
                    }
                }
            }
        }

        var positions = {
            point: [],
            line: [],
            area: []
        };

        var labelled = {
            point: [],
            line: [],
            area: []
        };

        // Try and find a valid label for labellable entities
        for (k = 0; k < labelable.length; k++) {
            var font_size = font_sizes[k];
            for (i = 0; i < labelable[k].length; i ++) {
                entity = labelable[k][i];
                var width = name(entity) && textWidth(name(entity), font_size),
                    p;
                if (entity.geometry(graph) === 'point') {
                    p = getPointLabel(entity, width, font_size);
                } else if (entity.geometry(graph) === 'line') {
                    p = getLineLabel(entity, width, font_size);
                } else if (entity.geometry(graph) === 'area') {
                    p = getAreaLabel(entity, width, font_size);
                }
                if (p) {
                    p.classes = entity.geometry(graph) + ' tag-' + label_stack[k][1];
                    positions[entity.geometry(graph)].push(p);
                    labelled[entity.geometry(graph)].push(entity);
                }
            }
        }

        function getPointLabel(entity, width, height) {
            var coord = projection(entity.loc),
                m = 5,  // margin
                offset = pointOffsets[0],
                p = {
                    height: height,
                    width: width,
                    x: coord[0] + offset[0],
                    y: coord[1] + offset[1],
                    textAnchor: offset[2]
                };
            var rect = new RTree.Rectangle(p.x - m, p.y - m, width + 2*m, height + 2*m);
            if (tryInsert(rect, entity.id)) return p;
        }


        function getLineLabel(entity, width, height) {
            var nodes = _.pluck(graph.childNodes(entity), 'loc').map(projection),
                length = iD.geo.pathLength(nodes);
            if (length < width + 20) return;

            for (var i = 0; i < lineOffsets.length; i ++) {
                var offset = lineOffsets[i],
                    middle = offset / 100 * length,
                    start = middle - width/2;
                if (start < 0 || start + width > length) continue;
                var sub = subpath(nodes, start, start + width),
                    rev = reverse(sub),
                    rect = new RTree.Rectangle(
                    Math.min(sub[0][0], sub[sub.length - 1][0]) - 10,
                    Math.min(sub[0][1], sub[sub.length - 1][1]) - 10,
                    Math.abs(sub[0][0] - sub[sub.length - 1][0]) + 20,
                    Math.abs(sub[0][1] - sub[sub.length - 1][1]) + 30
                );
                if (rev) sub = sub.reverse();
                if (tryInsert(rect, entity.id)) return {
                    'font-size': height + 2,
                    lineString: lineString(sub),
                    startOffset: offset + '%'
                };
            }
        }

        function getAreaLabel(entity, width, height) {
            var path = d3.geo.path().projection(projection),
                centroid = path.centroid(entity.asGeoJSON(graph, true)),
                extent = entity.extent(graph),
                entitywidth = projection(extent[1])[0] - projection(extent[0])[0],
                rect;

            if (entitywidth < 20) return;

            var iconX = centroid[0] - (iconSize/2),
                iconY = centroid[1] - (iconSize/2),
                textOffset = iconSize + 5;

            var p = {
                transform: 'translate(' + iconX + ',' + iconY + ')'
            };

            if (width && entitywidth >= width + 20) {
                p.x = centroid[0];
                p.y = centroid[1] + textOffset;
                p.textAnchor = 'middle';
                p.height = height;
                rect = new RTree.Rectangle(p.x - width/2, p.y, width, height + textOffset);
            } else {
                rect = new RTree.Rectangle(iconX, iconY, iconSize, iconSize);
            }

            if (tryInsert(rect, entity.id)) return p;

        }

        function tryInsert(rect, id) {
            // Check that label is visible
            if (rect.x1 < 0 || rect.y1 < 0 || rect.x2 > dimensions[0] ||
                rect.y2 > dimensions[1]) return false;
            var v = rtree.search(rect, true).length === 0;
            if (v) {
                rtree.insert(rect, id);
                rectangles[id] = rect;
            }
            return v;
        }

        var label = surface.select('.layer-label'),
            halo = surface.select('.layer-halo'),
            // points
            points = drawPointLabels(label, labelled.point, filter, 'pointlabel', positions.point),
            pointHalos = drawPointLabels(halo, labelled.point, filter, 'pointlabel-halo', positions.point),
            // lines
            linesPaths = drawLinePaths(halo, labelled.line, filter, '', positions.line),
            lines = drawLineLabels(label, labelled.line, filter, 'linelabel', positions.line),
            linesHalos = drawLineLabels(halo, labelled.line, filter, 'linelabel-halo', positions.line),
            // areas
            areas = drawAreaLabels(label, labelled.area, filter, 'arealabel', positions.area),
            areaHalos = drawAreaLabels(halo, labelled.area, filter, 'arealabel-halo', positions.area),
            areaIcons = drawAreaIcons(label, labelled.area, filter, 'arealabel-icon', positions.area);
    };

};
iD.svg.Lines = function(projection) {

    var highway_stack = {
        motorway: 0,
        motorway_link: 1,
        trunk: 2,
        trunk_link: 3,
        primary: 4,
        primary_link: 5,
        secondary: 6,
        tertiary: 7,
        unclassified: 8,
        residential: 9,
        service: 10,
        footway: 11
    };

    function waystack(a, b) {
        if (!a || !b || !a.tags || !b.tags) return 0;
        if (a.tags.layer !== undefined && b.tags.layer !== undefined) {
            return a.tags.layer - b.tags.layer;
        }
        if (a.tags.bridge) return 1;
        if (b.tags.bridge) return -1;
        if (a.tags.tunnel) return -1;
        if (b.tags.tunnel) return 1;
        var as = 0, bs = 0;
        if (a.tags.highway && b.tags.highway) {
            as -= highway_stack[a.tags.highway];
            bs -= highway_stack[b.tags.highway];
        }
        return as - bs;
    }

    // For fixing up rendering of multipolygons with tags on the outer member.
    // https://github.com/systemed/iD/issues/613
    function simpleMultipolygonOuterMember(entity, graph) {
        if (entity.type !== 'way')
            return false;

        var parents = graph.parentRelations(entity);
        if (parents.length !== 1)
            return false;

        var parent = parents[0];
        if (!parent.isMultipolygon() || Object.keys(parent.tags).length > 1)
            return false;

        var members = parent.members, member, outer;
        for (var i = 0; i < members.length; i++) {
            member = members[i];
            if (!member.role || member.role === 'outer') {
                if (outer)
                    return false; // Not a simple multipolygon
                outer = graph.entity(member.id);
            }
        }

        return outer;
    }

    return function drawLines(surface, graph, entities, filter, dimensions) {
        function drawPaths(group, lines, filter, klass, lineString) {
            lines = lines.filter(function(line) {
                return lineString(line);
            });

            var tagClasses = iD.svg.TagClasses();

            if (klass === 'stroke') {
                tagClasses.tags(iD.svg.MultipolygonMemberTags(graph));
            }

            var paths = group.selectAll('path.line')
                .filter(filter)
                .data(lines, iD.Entity.key);

            paths.enter()
                .append('path')
                .attr('class', 'way line ' + klass);

            paths
                .order()
                .attr('d', lineString)
                .call(tagClasses)
                .call(iD.svg.MemberClasses(graph));

            paths.exit()
                .remove();

            return paths;
        }

        var lines = [];

        for (var i = 0; i < entities.length; i++) {
            var entity = entities[i],
                outer = simpleMultipolygonOuterMember(entity, graph);
            if (outer) {
                lines.push(entity.mergeTags(outer.tags));
            } else if (entity.geometry(graph) === 'line') {
                lines.push(entity);
            }
        }

        lines.sort(waystack);

        var lineString = iD.svg.LineString(projection, graph, dimensions);
        var lineStringResampled = iD.svg.LineString(projection, graph, dimensions, 35);

        var shadow = surface.select('.layer-shadow'),
            casing = surface.select('.layer-casing'),
            stroke = surface.select('.layer-stroke'),
            defs   = surface.select('defs'),
            text   = surface.select('.layer-text'),
            shadows = drawPaths(shadow, lines, filter, 'shadow', lineString),
            casings = drawPaths(casing, lines, filter, 'casing', lineString),
            strokes = drawPaths(stroke, lines, filter, 'stroke', lineString);

            strokes
                .filter(function(d) { return d.isOneWay(); })
                .attr('marker-mid', 'url(#oneway-marker)')
                .attr('d', lineStringResampled);
    };
};
iD.svg.MemberClasses = function(graph) {
    var tagClassRe = /^member-?/;

    return function memberClassesSelection(selection) {
        selection.each(function memberClassesEach(d) {
            var classes, value = this.className;

            if (value.baseVal !== undefined) value = value.baseVal;

            classes = value.trim().split(/\s+/).filter(function(name) {
                return name.length && !tagClassRe.test(name);
            }).join(' ');

            var relations = graph.parentRelations(d);

            if (relations.length) {
                classes += ' member';
            }

            relations.forEach(function(relation) {
                classes += ' member-type-' + relation.tags.type;
                classes += ' member-role-' + relation.memberById(d.id).role;
            });

            classes = classes.trim();

            if (classes !== value) {
                d3.select(this).attr('class', classes);
            }
        });
    };
};
iD.svg.Midpoints = function(projection) {
    return function drawMidpoints(surface, graph, entities, filter, extent) {
        var midpoints = {};

        if (!surface.select('.layer-hit g.vertex').node()) {
            return surface.selectAll('.layer-hit g.midpoint').remove();
        }

        for (var i = 0; i < entities.length; i++) {
            if (entities[i].type !== 'way') continue;

            var entity = entities[i],
                nodes = graph.childNodes(entity);

            // skip the last node because it is always repeated
            for (var j = 0; j < nodes.length - 1; j++) {

                var a = nodes[j],
                    b = nodes[j + 1],
                    id = [a.id, b.id].sort().join('-');

                if (!midpoints[id]) {
                    var loc = iD.geo.interp(a.loc, b.loc, 0.5);
                    if (extent.intersects(loc) && iD.geo.dist(projection(a.loc), projection(b.loc)) > 40) {
                        midpoints[id] = {
                            type: 'midpoint',
                            id: id,
                            loc: loc,
                            edge: [a.id, b.id]
                        };
                    }
                }
            }
        }

        var groups = surface.select('.layer-hit').selectAll('g.midpoint')
            .filter(filter)
            .data(_.values(midpoints), function(d) { return d.id; });

        var group = groups.enter()
            .insert('g', ':first-child')
            .attr('class', 'midpoint');

        group.append('circle')
            .attr('r', 7)
            .attr('class', 'shadow');

        group.append('circle')
            .attr('r', 3)
            .attr('class', 'fill');

        groups.attr('transform', iD.svg.PointTransform(projection));

        // Propagate data bindings.
        groups.select('circle.shadow');
        groups.select('circle.fill');

        groups.exit()
            .remove();
    };
};
iD.svg.Points = function(projection, context) {
    function markerPath(selection, klass) {
        selection
            .attr('class', klass)
            .attr('transform', 'translate(-8, -23)')
            .attr('d', 'M 17,8 C 17,13 11,21 8.5,23.5 C 6,21 0,13 0,8 C 0,4 4,-0.5 8.5,-0.5 C 13,-0.5 17,4 17,8 z');
    }

    return function drawPoints(surface, graph, entities, filter) {
        var points = [];

        for (var i = 0; i < entities.length; i++) {
            var entity = entities[i];
            if (entity.geometry(graph) === 'point') {
                points.push(entity);
            }
        }

        if (points.length > 100) {
            return surface.select('.layer-hit').selectAll('g.point').remove();
        }

        var groups = surface.select('.layer-hit').selectAll('g.point')
            .filter(filter)
            .data(points, iD.Entity.key);

        var group = groups.enter()
            .append('g')
            .attr('class', 'node point');

        group.append('path')
            .call(markerPath, 'shadow');

        group.append('path')
            .call(markerPath, 'stroke');

        group.append('use')
            .attr('class', 'icon')
            .attr('transform', 'translate(-6, -20)')
            .attr('clip-path', 'url(#clip-square-12)');

        groups.attr('transform', iD.svg.PointTransform(projection))
            .call(iD.svg.TagClasses())
            .call(iD.svg.MemberClasses(graph));

        // Selecting the following implicitly
        // sets the data (point entity) on the element
        groups.select('.shadow');
        groups.select('.stroke');
        groups.select('.icon')
            .attr('xlink:href', function(entity) {
                var preset = context.presets().match(entity, graph);
                return preset.icon ? '#maki-' + preset.icon + '-12' : '';
            });

        groups.exit()
            .remove();
    };
};
iD.svg.Surface = function() {
    function findStylesheet(name) {
        return _.find(document.styleSheets, function(stylesheet) {
            return stylesheet.href && stylesheet.href.indexOf(name) > 0;
        });
    }

    function autosize(image) {
        var img = document.createElement('img');
        img.src = image.attr('xlink:href');
        img.onload = function() {
            image.attr({
                width: img.width,
                height: img.height
            });
        };
    }

    function sprites(stylesheetName, selectorRegexp) {
        var sprites = [];

        var stylesheet = findStylesheet(stylesheetName);
        if (!stylesheet) {
            return sprites;
        }

        _.forEach(stylesheet.cssRules, function(rule) {
            var klass = rule.selectorText,
                match = klass && klass.match(selectorRegexp);
            if (match) {
                var id = match[1].replace('feature', 'maki');
                match = rule.style.backgroundPosition.match(/(-?\d+)px (-?\d+)px/);
                sprites.push({id: id, x: match[1], y: match[2]});
            }
        });

        return sprites;
    }

    return function drawSurface(selection) {
        var defs = selection.append('defs');

        defs.append('marker')
            .attr({
                id: 'oneway-marker',
                viewBox: '0 0 10 10',
                refY: 2.5,
                markerWidth: 2,
                markerHeight: 2,
                orient: 'auto'
            })
            .append('path')
            .attr('d', 'M 0 0 L 5 2.5 L 0 5 z');

        var patterns = defs.selectAll('pattern')
            .data([
                // pattern name, pattern image name
                ['wetland', 'wetland'],
                ['construction', 'construction'],
                ['cemetery', 'cemetery'],
                ['orchard', 'orchard'],
                ['farmland', 'farmland'],
                ['beach', 'dots'],
                ['scrub', 'dots'],
                ['meadow', 'dots']])
            .enter()
            .append('pattern')
                .attr({
                    id: function(d) { return 'pattern-' + d[0]; },
                    width: 32,
                    height: 32,
                    patternUnits: 'userSpaceOnUse'
                });

        patterns.append('rect')
            .attr({
                x: 0,
                y: 0,
                width: 32,
                height: 32,
                'class': function(d) { return 'pattern-color-' + d[0]; }
            });

        patterns.append('image')
            .attr({
                x: 0,
                y: 0,
                width: 32,
                height: 32
            })
            .attr('xlink:href', function(d) { return 'img/pattern/' + d[1] + '.png'; });

        defs.selectAll()
            .data([12, 18, 20])
            .enter().append('clipPath')
            .attr('id', function(d) { return 'clip-square-' + d; })
            .append('rect')
            .attr('x', 0)
            .attr('y', 0)
            .attr('width', function(d) { return d; })
            .attr('height', function(d) { return d; });

        defs.append('image')
            .attr('id', 'sprite')
            .attr('xlink:href', 'img/sprite.png')
            .call(autosize);

        defs.selectAll()
            .data(sprites("app.css", /^\.(icon-operation-[a-z0-9-]+)$/))
            .enter().append('use')
            .attr('id', function(d) { return d.id; })
            .attr('transform', function(d) { return "translate(" + d.x + "," + d.y + ")"; })
            .attr('xlink:href', '#sprite');

        defs.append('image')
            .attr('id', 'maki-sprite')
            .attr('xlink:href', 'img/feature-icons.png')
            .call(autosize);

        defs.selectAll()
            .data(sprites("feature-icons.css", /^\.(feature-[a-z0-9-]+-(12|18))$/))
            .enter().append('use')
            .attr('id', function(d) { return d.id; })
            .attr('transform', function(d) { return "translate(" + d.x + "," + d.y + ")"; })
            .attr('xlink:href', '#maki-sprite');

        var layers = selection.selectAll('.layer')
            .data(['fill', 'shadow', 'casing', 'stroke', 'text', 'hit', 'halo', 'label']);

        layers.enter().append('g')
            .attr('class', function(d) { return 'layer layer-' + d; });
    };
};
iD.svg.TagClasses = function() {
    var keys = d3.set([
        'highway', 'railway', 'waterway', 'power', 'motorway', 'amenity',
        'natural', 'landuse', 'building', 'oneway', 'bridge', 'boundary',
        'tunnel', 'leisure', 'construction', 'place'
    ]), tagClassRe = /^tag-/,
        tags = function(entity) { return entity.tags; };

    var tagClasses = function(selection) {
        selection.each(function tagClassesEach(entity) {
            var classes, value = this.className;

            if (value.baseVal !== undefined) value = value.baseVal;

            classes = value.trim().split(/\s+/).filter(function(name) {
                return name.length && !tagClassRe.test(name);
            }).join(' ');

            var t = tags(entity);
            for (var k in t) {
                if (!keys.has(k)) continue;
                classes += ' tag-' + k + ' ' + 'tag-' + k + '-' + t[k];
            }

            classes = classes.trim();

            if (classes !== value) {
                d3.select(this).attr('class', classes);
            }
        });
    };

    tagClasses.tags = function(_) {
        if (!arguments.length) return tags;
        tags = _;
        return tagClasses;
    };

    return tagClasses;
};
iD.svg.Vertices = function(projection, context) {
    var radiuses = {
        //       z16-, z17, z18+, tagged
        shadow: [6,    7.5,   7.5,  11.5],
        stroke: [2.5,  3.5,   3.5,  7],
        fill:   [1,    1.5,   1.5,  1.5]
    };

    return function drawVertices(surface, graph, entities, filter, zoom) {
        var vertices = [];

        for (var i = 0; i < entities.length; i++) {
            var entity = entities[i];
            if (entity.geometry(graph) === 'vertex') {
                vertices.push(entity);
            }
        }

        if (vertices.length > 2000) {
            return surface.select('.layer-hit').selectAll('g.vertex').remove();
        }

        var groups = surface.select('.layer-hit').selectAll('g.vertex')
            .filter(filter)
            .data(vertices, iD.Entity.key);

        var group = groups.enter()
            .insert('g', ':first-child')
            .attr('class', 'node vertex');

        if (zoom < 17) {
            zoom = 0;
        } else if (zoom < 18) {
            zoom = 1;
        } else {
            zoom = 2;
        }

        group.append('circle')
            .attr('class', 'node vertex shadow');

        group.append('circle')
            .attr('class', 'node vertex stroke');

        groups.attr('transform', iD.svg.PointTransform(projection))
            .call(iD.svg.TagClasses())
            .call(iD.svg.MemberClasses(graph))
            .classed('tagged', function(entity) { return entity.hasInterestingTags(); })
            .classed('shared', function(entity) { return graph.isShared(entity); });

        function icon(entity) {
            return zoom !== 0 &&
                entity.hasInterestingTags() &&
                context.presets().match(entity, graph).icon;
        }

        function center(entity) {
            if (icon(entity)) {
                d3.select(this)
                    .attr('cx', 0.5)
                    .attr('cy', -0.5);
            } else {
                d3.select(this)
                    .attr('cy', 0)
                    .attr('cx', 0);
            }
        }

        groups.select('circle.shadow')
            .each(center)
            .attr('r', function(entity) {
                return radiuses.shadow[icon(entity) ? 3 : zoom]
            });

        groups.select('circle.stroke')
            .each(center)
            .attr('r', function(entity) {
                return radiuses.stroke[icon(entity) ? 3 : zoom]
            });

        // Each vertex gets either a circle or a use, depending
        // on if it has a icon or not.

        var fill = groups.selectAll('circle.fill')
            .data(function(entity) {
                return icon(entity) ? [] : [entity];
            }, iD.Entity.key);

        fill.enter().append('circle')
            .attr('class', 'node vertex fill')
            .each(center)
            .attr('r', radiuses.fill[zoom]);

        fill.exit()
            .remove();

        var use = groups.selectAll('use')
            .data(function(entity) {
                var i = icon(entity);
                return i ? [i] : [];
            }, function(d) {
                return d;
            });

        use.enter().append('use')
            .attr('transform', 'translate(-6, -6)')
            .attr('clip-path', 'url(#clip-square-12)')
            .attr('xlink:href', function(icon) { return '#maki-' + icon + '-12'; });

        use.exit()
            .remove();

        groups.exit()
            .remove();
    };
};
iD.ui = function(context) {
    return function(container) {
        context.container(container);

        var history = context.history(),
            map = context.map();

        if (!iD.detect().support) {
            container
                .text(t('browser_notice'))
                .style({
                    'text-align': 'center',
                    'font-style': 'italic'
                });
            return;
        }

        if (iD.detect().opera) container.classed('opera', true);

        var hash = iD.behavior.Hash(context);

        hash();

        if (!hash.hadHash) {
            map.centerZoom([-77.02271, 38.90085], 20);
        }

        var m = container.append('div')
            .attr('id', 'map')
            .call(map);

        var bar = container.append('div')
            .attr('id', 'bar')
            .attr('class','pad1 fillD');

        var limiter = bar.append('div')
            .attr('class', 'limiter');

        limiter.append('div')
            .attr('class', 'button-wrap joined col3')
            .call(iD.ui.Modes(context), limiter);

        limiter.append('div')
            .attr('class', 'button-wrap joined col1')
            .call(iD.ui.UndoRedo(context));

        limiter.append('div')
            .attr('class', 'button-wrap col1')
            .call(iD.ui.Save(context));

        bar.append('div')
            .attr('class', 'spinner')
            .call(iD.ui.Spinner(context));

        container.append('div')
            .style('display', 'none')
            .attr('class', 'help-wrap fillL col5');

        container.append('div')
            .attr('class', 'map-control zoombuttons')
            .call(iD.ui.Zoom(context));

        container.append('div')
            .attr('class', 'map-control geocode-control')
            .call(iD.ui.Geocoder(context));

        container.append('div')
            .attr('class', 'map-control background-control')
            .call(iD.ui.Background(context));

        container.append('div')
            .attr('class', 'map-control geolocate-control')
            .call(iD.ui.Geolocate(map));

        container.append('div')
            .attr('class', 'map-control help-control')
            .call(iD.ui.Help(context));

        container.append('div')
            .style('display', 'none')
            .attr('class', 'inspector-wrap fr content col4');

        container.append('idv')
            .attr('class', 'attribution')
            .attr('tabindex', -1)
            .call(iD.ui.Attribution(context));

        var about = container.append('div')
            .attr('class','col12 about-block fillD');

        about.append('div')
            .attr('class', 'account')
            .call(iD.ui.Account(context));

        var linkList = about.append('ul')
            .attr('id', 'about')
            .attr('class', 'link-list');

        linkList.append('li')
            .append('a')
            .attr('target', '_blank')
            .attr('tabindex', -1)
            .attr('href', 'http://github.com/systemed/iD')
            .text(iD.version);

        linkList.append('li')
            .append('a')
            .attr('target', '_blank')
            .attr('tabindex', -1)
            .attr('href', 'https://help.openfloorplan.org/questions/ask/')
            .text(t('report_a_bug'));

        linkList.append('li')
            .attr('class', 'source-switch')
            .call(iD.ui.SourceSwitch(context));

        linkList.append('li')
            .attr('class', 'user-list')
            .attr('tabindex', -1)
            .call(iD.ui.Contributors(context));

        window.onbeforeunload = function() {
            history.save();
            if (history.hasChanges()) return t('save.unsaved_changes');
        };

        d3.select(window).on('resize.editor', function() {
            map.size(m.size());
        });

        function pan(d) {
            return function() {
                context.pan(d);
            };
        }

        // pan amount
        var pa = 5;

        var keybinding = d3.keybinding('main')
            .on('⌫', function() { d3.event.preventDefault(); })
            .on('←', pan([pa, 0]))
            .on('↑', pan([0, pa]))
            .on('→', pan([-pa, 0]))
            .on('↓', pan([0, -pa]));

        d3.select(document)
            .call(keybinding);

        context.enter(iD.modes.Browse(context));

        context.container()
            .call(iD.ui.Splash(context))
            .call(iD.ui.Restore(context));
    };
};

iD.ui.tooltipHtml = function(text, key) {
    return '<span>' + text + '</span>' + '<div class="keyhint-wrap"><span class="keyhint"> ' + key + '</span></div>';
};
iD.ui.Account = function(context) {
    var connection = context.connection();

    function update(selection) {
        if (!connection.authenticated()) {
            selection.html('')
                .style('display', 'none');
            return;
        }

        selection.style('display', 'block');

        connection.userDetails(function(err, details) {
            selection.html('');

            if (err) return;

            // Link
            var userLink = selection.append('a')
                .attr('href', connection.url() + '/user/' + details.display_name)
                .attr('target', '_blank');

            // Add thumbnail or dont
            if (details.image_url) {
                userLink.append('img')
                    .attr('class', 'icon icon-pre-text user-icon')
                    .attr('src', details.image_url);
            } else {
                userLink.append('span')
                    .attr('class', 'icon avatar icon-pre-text');
            }

            // Add user name
            userLink.append('span')
                .attr('class', 'label')
                .text(details.display_name);

            selection.append('a')
                .attr('class', 'logout')
                .attr('href', '#')
                .text(t('logout'))
                .on('click.logout', function() {
                    d3.event.preventDefault();
                    connection.logout();
                });
        });
    }

    return function(selection) {
        connection.on('auth', function() { update(selection); });
        update(selection);
    };
};
iD.ui.Attribution = function(context) {
    var selection;

    function update() {
        var d = context.background().source();

        var provided_by = selection
            .html('')
            .append('span')
            .attr('class', 'provided-by');

        if (!d) return;

        var source = d.data.sourcetag || d.data.name;
        if (d.data.logo) {
            source = '<img class="source-image" src="img/' + d.data.logo + '">';
        }

        if (d.data.terms_url) {
            provided_by.append('a')
                .attr('href', d.data.terms_url)
                .attr('target', '_blank')
                .html(source);
        } else {
            provided_by.text(source);
        }

        var copyright = d.copyrightNotices(context.map().zoom(), context.map().extent());
        if (copyright) {
            provided_by.append('span')
                .text(copyright);
        }
    }

    return function(select) {
        selection = select;

        context.background()
            .on('change.attribution', update);

        context.map()
            .on('move.attribution', _.throttle(update, 400));

        update();
    };
};
iD.ui.Background = function(context) {
    var key = 'b',
        opacities = [1, 0.5, 0],
        directions = [
            ['left', [1, 0]],
            ['top', [0, -1]],
            ['right', [-1, 0]],
            ['bottom', [0, 1]]],
        layers = context.backgroundSources();

    function getSources() {
        var ext = context.map().extent();
        return layers.filter(function(layer) {
            return !layer.data.extent ||
                iD.geo.Extent(layer.data.extent).intersects(ext);
        });
    }

    function background(selection) {

        function toggle() {
            tooltip.hide(button);
            setVisible(content.classed('hide'));
            content.selectAll('.toggle-list li:first-child a').node().focus();
        }

        function setVisible(show) {
            if (show !== shown) {
                button.classed('active', show);
                content.call(iD.ui.Toggle(show));
                shown = show;

                if (show) {
                    selection.on('mousedown.background-inside', function() {
                        return d3.event.stopPropagation();
                    });
                } else {
                    selection.on('mousedown.background-inside', null);
                }
            }
        }

        function setOpacity(d) {
            context.map().layersurface.selectAll('.layer-layer')
                .filter(function(d) { return d == context.map().layers[0]; })
                .transition()
                .style('opacity', d)
                .attr('data-opacity', d);

            opacityList.selectAll('li')
                .classed('selected', false);

            if (d3.event) {
                d3.select(this)
                    .classed('selected', true);
            }
        }

        function selectLayer() {
            content.selectAll('a.layer')
                .classed('selected', function(d) {
                    return d.data.name === context.background().source().data.name;
                });
        }

        function clickSetSource(d) {
            d3.event.preventDefault();
            if (d.data.name === 'Custom') {
                var configured = d();
                if (!configured) return;
                d = configured;
            }
            context.background().source(d);
            if (d.data.name === 'Custom (customized)') {
                context.history()
                    .imagery_used('Custom (' + d.data.template + ')');
            } else {
                context.history()
                    .imagery_used(d.data.sourcetag || d.data.name);
            }
            context.redraw();
            selectLayer();
        }

        function clickGpx(d) {
            d3.event.preventDefault();
            if (!_.isEmpty(context.map().layers[1].geojson())) {
                context.map().layers[1]
                    .enable(!context.map().layers[1].enable());
                d3.select(this)
                    .classed('selected', context.map().layers[1].enable());
                context.redraw();
            }
        }

        function update() {
            var layerLinks = layerList.selectAll('a.layer')
                .data(getSources(), function(d) {
                    return d.data.name;
                });

            var layerInner = layerLinks.enter()
                .append('li')
                .append('a');

            layerInner
                .attr('href', '#')
                .attr('class', 'layer')
                .on('click.set-source', clickSetSource);

            // only set tooltips for layers with tooltips
            layerInner
                .filter(function(d) { return d.data.description; })
                .call(bootstrap.tooltip()
                    .title(function(d) { return d.data.description; })
                    .placement('right')
                );

            layerInner.insert('span')
                .attr('class', 'icon toggle icon-pre-text');

            layerInner.insert('span').text(function(d) {
                return d.data.name;
            });

            gpxLayerItem
                .classed('selected', function() {
                    var gpxLayer = context.map().layers[1];
                    return !_.isEmpty(gpxLayer.geojson()) &&
                        gpxLayer.enable();
                });

            layerLinks.exit()
                .remove();

            selectLayer();
        }

        function clickNudge(d) {
            var interval = window.setInterval(nudge, 100);

            d3.select(this).on('mouseup', function() {
                window.clearInterval(interval);
                nudge();
            });

            function nudge() {
                context.background().nudge(d[1], context.map().zoom());
                context.redraw();
            }
        }

        var content = selection.append('div')
                .attr('class', 'content fillD map-overlay hide'),
            tooltip = bootstrap.tooltip()
                .placement('right')
                .html(true)
                .title(iD.ui.tooltipHtml(t('background.description'), key)),
            button = selection.append('button')
                .attr('tabindex', -1)
                .attr('class', 'fillD')
                .on('click.background-toggle', toggle)
                .call(tooltip),
            opa = content
                .append('div')
                .attr('class', 'opacity-options-wrapper'),
            shown = false;

        button.append('span')
            .attr('class', 'layers icon');

        opa.append('h4')
            .text(t('background.title'));

        context.surface().on('mousedown.background-outside', function() {
            setVisible(false);
        });

        context.container().on('mousedown.background-outside', function() {
            setVisible(false);
        });

        var opacityList = opa.append('ul')
            .attr('class', 'opacity-options');

        opacityList.selectAll('div.opacity')
            .data(opacities)
            .enter()
            .append('li')
            .attr('data-original-title', function(d) {
                return t('background.percent_brightness', { opacity: (d * 100) });
            })
            .on('click.set-opacity', setOpacity)
            .html("<div class='select-box'></div>")
            .call(bootstrap.tooltip()
                .placement('top'))
            .append('div')
            .attr('class', 'opacity')
            .style('opacity', String);

        // Make sure there is an active selection by default
        opa.select('.opacity-options li:nth-child(2)')
            .classed('selected', true);

        var layerList = content
            .append('ul')
            .attr('class', 'toggle-list fillL');

        var gpxLayerItem = content
            .append('ul')
            .style('display', iD.detect().filedrop ? 'block' : 'none')
            .attr('class', 'toggle-list fillL')
            .append('li')
            .append('a')
            .classed('layer-toggle-gpx', true)
            .call(bootstrap.tooltip()
                .title(t('gpx.drag_drop'))
                .placement('right'))
            .on('click.set-gpx', clickGpx);

        gpxLayerItem
            .append('span')
            .attr('class', 'icon toggle icon-pre-text');

        gpxLayerItem.append('span')
            .text(t('gpx.local_layer'));

        gpxLayerItem
            .append('a')
            .attr('class', 'icon geocode layer-extent')
            .on('click', function() {
                d3.event.preventDefault();
                d3.event.stopPropagation();
                context.map()
                    .extent(d3.geo.bounds(context.map().layers[1].geojson()));
            });

        var adjustments = content
            .append('div')
            .attr('class', 'adjustments pad1');

        adjustments.append('a')
            .text(t('background.fix_misalignment'))
            .attr('href', '#')
            .classed('hide-toggle', true)
            .classed('expanded', false)
            .on('click', function() {
                var exp = d3.select(this).classed('expanded');
                nudge_container.style('display', exp ? 'none' : 'block');
                d3.select(this).classed('expanded', !exp);
                d3.event.preventDefault();
            });

        var nudge_container = adjustments
            .append('div')
            .attr('class', 'nudge-container')
            .style('display', 'none');

        nudge_container.selectAll('button')
            .data(directions).enter()
            .append('button')
            .attr('class', function(d) { return d[0] + ' nudge'; })
            .text(function(d) { return d[0]; })
            .on('mousedown', clickNudge);

        nudge_container.append('button')
            .text(t('background.reset'))
            .attr('class', 'reset')
            .on('click', function() {
                context.background().offset([0, 0]);
                context.redraw();
            });

        context.map()
            .on('move.background-update', _.debounce(update, 1000));
        update();
        setOpacity(0.5);

        var keybinding = d3.keybinding('background');
        keybinding.on(key, toggle);

        d3.select(document)
            .call(keybinding);
    }

    return background;
};
// Translate a MacOS key command into the appropriate Windows/Linux equivalent.
// For example, ⌘Z -> Ctrl+Z
iD.ui.cmd = function(code) {
    if (iD.detect().os === 'mac')
        return code;

    var replacements = {
        '⌘': 'Ctrl',
        '⇧': 'Shift',
        '⌥': 'Alt',
        '⌫': 'Backspace',
        '⌦': 'Delete'
    }, keys = [];

    for (var i = 0; i < code.length; i++) {
        if (code[i] in replacements) {
            keys.push(replacements[code[i]]);
        } else {
            keys.push(code[i]);
        }
    }

    return keys.join('+');
};
iD.ui.Commit = function(context) {
    var event = d3.dispatch('cancel', 'save', 'fix');

    function zipSame(d) {
        var c = [], n = -1;
        for (var i = 0; i < d.length; i++) {
            var desc = {
                name: d[i].friendlyName(),
                type: d[i].type,
                count: 1,
                tagText: iD.util.tagText(d[i])
            };
            if (c[n] &&
                c[n].name == desc.name &&
                c[n].tagText == desc.tagText) {
                c[n].count++;
            } else {
                c[++n] = desc;
            }
        }
        return c;
    }

    function commit(selection) {

        function changesLength(d) { return changes[d].length; }

        var changes = selection.datum(),
            connection = changes.connection,
            user = connection.user(),
            header = selection.append('div').attr('class', 'header modal-section'),
            body = selection.append('div').attr('class', 'body');

        header.append('h3')
            .text(t('commit.title'));

        // Comment Section
        var commentSection = body.append('div')
            .attr('class', 'modal-section form-field');

            commentSection.append('label')
                .attr('class','form-label')
                .text(t('commit.message_label'));

        var commentField = commentSection
                .append('textarea')
                .attr('placeholder', t('commit.description_placeholder'))
                .property('value',  context.storage('comment') || '');

        commentField.node().select();

        // Save Section
        var saveSection = body.append('div').attr('class','modal-section cf');

        var userLink = d3.select(document.createElement('div'));

        if (user.image_url) {
            userLink.append('img')
                .attr('src', user.image_url)
                .attr('class', 'icon icon-pre-text user-icon');
        }

        userLink.append('a')
            .attr('class','user-info')
            .text(user.display_name)
            .attr('href', connection.url() + '/user/' + user.display_name)
            .attr('target', '_blank');

        saveSection.append('p')
            .attr('class', 'commit-info')
            .html(t('commit.upload_explanation', {user: userLink.html()}));

        // Confirm Button
        var saveButton = saveSection.append('button')
            .attr('class', 'action col2 button')
            .on('click.save', function() {
                var comment = commentField.node().value;
                localStorage.comment = comment;
                event.save({
                    comment: comment
                });
            });

        saveButton.append('span')
            .attr('class', 'label')
            .text(t('commit.save'));

        var warnings = body.selectAll('div.warning-section')
            .data(iD.validate(changes, context.graph()))
            .enter()
            .append('div')
            .attr('class', 'modal-section warning-section fillL2');

        warnings.append('h3')
            .text(t('commit.warnings'));

        var warningLi = warnings.append('ul')
            .attr('class', 'changeset-list')
            .selectAll('li')
            .data(function(d) { return d; })
            .enter()
            .append('li');

        // only show the fix icon when an entity is given
        warningLi.filter(function(d) { return d.entity; })
            .append('button')
            .attr('class', 'minor')
            .on('click', event.fix)
            .append('span')
            .attr('class', 'icon warning');

        warningLi.append('strong').text(function(d) {
            return d.message;
        });

        var section = body.selectAll('div.commit-section')
            .data(['modified', 'deleted', 'created'].filter(changesLength))
            .enter()
            .append('div')
            .attr('class', 'commit-section modal-section fillL2');

        section.append('h3')
            .text(function(d) { return t('commit.' + d); })
            .append('small')
            .attr('class', 'count')
            .text(changesLength);

        var li = section.append('ul')
            .attr('class', 'changeset-list')
            .selectAll('li')
            .data(function(d) { return zipSame(changes[d]); })
            .enter()
            .append('li');

        li.append('strong')
            .text(function(d) {
                return (d.count > 1) ? d.type + 's ' : d.type + ' ';
            });

        li.append('span')
            .text(function(d) { return d.name; })
            .attr('title', function(d) { return d.tagText; });

        li.filter(function(d) { return d.count > 1; })
            .append('span')
            .attr('class', 'count')
            .text(function(d) { return d.count; });
    }

    return d3.rebind(commit, event, 'on');
};
iD.ui.confirm = function(selection) {
    var modal = iD.ui.modal(selection);

    modal.select('.modal')
        .classed('modal-alert', true);

    var section = modal.select('.content');

    var modalHeader = section.append('div')
        .attr('class', 'modal-section header');

    var description = section.append('div')
        .attr('class', 'modal-section message-text');

    var buttonwrap = section.append('div')
        .attr('class', 'modal-section buttons cf');

    var okbutton = buttonwrap.append('button')
        .attr('class', 'col2 action')
        .on('click.confirm', function() {
            modal.remove();
        })
        .text('Okay');

    return modal;
};
iD.ui.Contributors = function(context) {
    function update(selection) {
        var users = {},
            limit = 4,
            entities = context.intersects(context.map().extent());

        entities.forEach(function(entity) {
            if (entity && entity.user) users[entity.user] = true;
        });

        var u = Object.keys(users),
            subset = u.slice(0, u.length > limit ? limit - 1 : limit);

        selection.html('')
            .append('span')
            .attr('class', 'icon nearby icon-pre-text');

        var userList = d3.select(document.createElement('span'));

        userList.selectAll()
            .data(subset)
            .enter()
            .append('a')
            .attr('class', 'user-link')
            .attr('href', function(d) { return context.connection().userUrl(d); })
            .attr('target', '_blank')
            .attr('tabindex', -1)
            .text(String);

        if (u.length > limit) {
            var count = d3.select(document.createElement('span'));

            count.append('a')
                .attr('target', '_blank')
                .attr('tabindex', -1)
                .attr('href', function() {
                    var ext = context.map().extent();
                    return 'http://localhost:3000/browse/changesets?bbox=' + [
                        ext[0][0], ext[0][1],
                        ext[1][0], ext[1][1]];
                })
                .text(u.length - limit + 1);

            selection.append('span')
                .html(t('contributors.truncated_list', {users: userList.html(), count: count.html()}));
        } else {
            selection.append('span')
                .html(t('contributors.list', {users: userList.html()}));
        }

        if (!u.length) {
            selection.transition().style('opacity', 0);
        } else if (selection.style('opacity') === '0') {
            selection.transition().style('opacity', 1);
        }
    }

    return function(selection) {
        update(selection);

        context.connection().on('load.contributors', function() {
            update(selection);
        });

        context.map().on('move.contributors', _.debounce(function() {
            update(selection);
        }, 500));
    };
};
iD.ui.flash = function(selection) {
    var modal = iD.ui.modal(selection);

    modal.select('.modal').classed('modal-flash', true);

    modal.select('.content')
        .classed('modal-section', true)
        .append('div')
        .attr('class', 'description');

    modal.on('click.flash', function() { modal.remove(); });

    setTimeout(function() {
        modal.remove();
        return true;
    }, 1500);

    return modal;
};
iD.ui.Geocoder = function(context) {

    var key = 'f';

    function resultExtent(bounds) {
        return new iD.geo.Extent(
            [parseFloat(bounds[3]), parseFloat(bounds[0])],
            [parseFloat(bounds[2]), parseFloat(bounds[1])]);
    }

    function geocoder(selection) {

        var shown = false;

        function keydown() {
            if (d3.event.keyCode !== 13) return;
            d3.event.preventDefault();
            var searchVal = this.value;
            inputNode.classed('loading', true);
            d3.json('http://localhost:3000/search/' +
                encodeURIComponent(searchVal) + '?limit=10&format=json', function(err, resp) {
                    inputNode.classed('loading', false);
                    if (err) return hide();
                    if (!resp.length) {
                        return iD.ui.flash(context.container())
                            .select('.content')
                            .append('h3')
                            .text(t('geocoder.no_results', {name: searchVal}));
                    } else if (resp.length > 1) {
                        var spans = resultsList.selectAll('span')
                            .data(resp, function(d) { return d.place_id; });

                        spans.enter()
                            .append('span')
                            .text(function(d) {
                                return d.type.charAt(0).toUpperCase() + d.type.slice(1) + ': ';
                            })
                            .append('a')
                            .attr('tabindex', 1)
                            .text(function(d) {
                                if (d.display_name.length > 80) {
                                    return d.display_name.substr(0, 80) + '…';
                                } else {
                                    return d.display_name;
                                }
                            })
                            .on('click', clickResult)
                            .on('keydown', function(d) {
                                // support tabbing to and accepting this
                                // entry
                                if (d3.event.keyCode == 13) clickResult(d);
                            });
                        spans.exit().remove();
                        resultsList.call(iD.ui.Toggle(true));
                    } else {
                        applyBounds(resultExtent(resp[0].boundingbox));
                    }
                });
        }

        function clickResult(d) {
            applyBounds(resultExtent(d.boundingbox));
        }

        function applyBounds(extent) {
            hide();
            var map = context.map();
            map.extent(extent);
            if (map.zoom() > 19) map.zoom(19);
        }

        function hide() { setVisible(false); }
        function toggle() {
            if (d3.event) d3.event.preventDefault();
            tooltip.hide(button);
            setVisible(gcForm.classed('hide'));
        }

        function setVisible(show) {
            if (show !== shown) {
                button.classed('active', show);
                gcForm.call(iD.ui.Toggle(show));
                if (!show && !resultsList.classed('hide')) {
                    resultsList.call(iD.ui.Toggle(show));
                    // remove results so that they lose focus. if the user has
                    // tabbed into the list, then they will have focus still,
                    // even if they're hidden.
                    resultsList.selectAll('span').remove();
                }
                if (show) inputNode.node().focus();
                else inputNode.node().blur();
                shown = show;

                if (show) {
                    selection.on('mousedown.geocoder-inside', function() {
                        return d3.event.stopPropagation();
                    });
                } else {
                    selection.on('mousedown.geocoder-inside', null);
                }
            }
        }
        var tooltip = bootstrap.tooltip()
            .placement('right')
            .html(true)
            .title(iD.ui.tooltipHtml(t('geocoder.title'), key));

        var button = selection.append('button')
            .attr('tabindex', -1)
            .on('click', toggle)
            .call(tooltip);

        button.append('span')
            .attr('class', 'icon geocode light');

        var gcForm = selection.append('form');

        var inputNode = gcForm.attr('class', 'content fillL map-overlay hide')
            .append('input')
            .attr({ type: 'text', placeholder: t('geocoder.placeholder') })
            .attr('tabindex', 1)
            .on('keydown', keydown);

        var resultsList = selection.append('div')
            .attr('class', 'content fillD map-overlay hide');

        context.surface().on('mousedown.geocoder-outside', hide);
        context.container().on('mousedown.b.geocoder-outside', hide);

        var keybinding = d3.keybinding('geocoder');

        keybinding.on(key, toggle);

        d3.select(document)
            .call(keybinding);
    }

    return geocoder;
};
iD.ui.Geolocate = function(map) {
    function click() {
        navigator.geolocation.getCurrentPosition(
            success, error);
    }

    function success(position) {
        map.center([position.coords.longitude, position.coords.latitude]);
    }

    function error() { }

    return function(selection) {
        if (!navigator.geolocation) return;

        var button = selection.append('button')
            .attr('tabindex', -1)
            .attr('title', t('geolocate.title'))
            .on('click', click)
            .call(bootstrap.tooltip()
                .placement('right'));

         button.append('span')
             .attr('class', 'icon geolocate');
    };
};
iD.ui.Help = function(context) {

    var key = 'h';

    function help(selection) {

        var shown = false, pane;

        function setup() {
            pane = context.container()
                .select('.help-wrap')
                .html('');

            var toc = pane.append('ul')
                .attr('class', 'toc');

            function clickHelp(d) {
                doctitle.text(d.title);
                body.html(d.html);
                body.selectAll('a')
                    .attr('target', '_blank');
                menuItems.classed('selected', function(m) {
                    return m.title === d.title;
                });
            }

            var menuItems = toc.selectAll('li')
                .data(iD.data.doc)
                .enter()
                .append('li')
                .append('a')
                .text(function(d) { return d.title; })
                .on('click', clickHelp);

            var content = pane.append('div')
                    .attr('class', 'left-content'),
                doctitle = content.append('h2')
                    .text(t('help.title')),
                body = content.append('div')
                    .attr('class', 'body');

            clickHelp(iD.data.doc[0]);
        }

        function hide() { setVisible(false); }
        function toggle() {
            if (d3.event) d3.event.preventDefault();
            tooltip.hide(button);
            setVisible(!button.classed('active'));
        }

        function setVisible(show) {
            if (show !== shown) {
                button.classed('active', show);
                shown = show;
                if (show) {
                    function blockClick() {
                        pane.on('mousedown.help-inside', function() {
                            return d3.event.stopPropagation();
                        });
                        selection.on('mousedown.help-inside', function() {
                            return d3.event.stopPropagation();
                        });
                    }
                    pane.style('display', 'block')
                        .style('left', '-500px')
                        .transition()
                        .duration(200)
                        .style('left', '0px')
                        .each('end', blockClick);
                } else {
                    pane.style('left', '0px')
                        .transition()
                        .duration(200)
                        .style('left', '-500px')
                        .each('end', function() {
                            d3.select(this).style('display', 'none');
                        });
                    pane.on('mousedown.help-inside', null);
                }
            }
        }

        var tooltip = bootstrap.tooltip()
            .placement('right')
            .html(true)
            .title(iD.ui.tooltipHtml(t('help.title'), key));

        var button = selection.append('button')
            .attr('tabindex', -1)
            .on('click', toggle)
            .call(tooltip);

        button.append('span')
            .attr('class', 'icon help light');

        context.surface().on('mousedown.help-outside', hide);
        context.container().on('mousedown.b.help-outside', hide);

        setup();

        var keybinding = d3.keybinding('help');
        keybinding.on(key, toggle);
        d3.select(document).call(keybinding);
    }

    return help;
};
iD.ui.Inspector = function(context, entity) {
    var tagEditor;

    function changeTags(tags) {
        entity = context.entity(entity.id);
        if (entity && !_.isEqual(entity.tags, tags)) {
            context.perform(
                iD.actions.ChangeTags(entity.id, tags),
                t('operations.change_tags.annotation'));
        }
    }

    function browse() {
        context.enter(iD.modes.Browse(context));
    }

    function update() {
        entity = context.entity(entity.id);
        if (entity) {
            tagEditor.tags(entity.tags);
        }
    }

    function inspector(selection) {
        selection
            .html('')
            .style('display', 'block')
            .style('right', '-500px')
            .style('opacity', 1)
            .transition()
            .duration(200)
            .style('right', '0px');

        var panewrap = selection
            .append('div')
            .classed('panewrap', true);

        var presetLayer = panewrap
            .append('div')
            .classed('pane', true);

        var tagLayer = panewrap
            .append('div')
            .classed('pane', true);

        var presetGrid = iD.ui.PresetGrid(context, entity)
            .on('close', browse)
            .on('choose', function(preset) {
                panewrap
                    .transition()
                    .style('right', '0%');

                tagLayer.call(tagEditor, preset);
            });

        tagEditor = iD.ui.TagEditor(context, entity)
            .tags(entity.tags)
            .on('changeTags', changeTags)
            .on('close', browse)
            .on('choose', function(preset) {
                panewrap
                    .transition()
                    .style('right', '-100%');

                presetLayer.call(presetGrid, preset);
            });

        var initial = entity.isNew() && _.without(Object.keys(entity.tags), 'area').length === 0;

        if (initial) {
            panewrap.style('right', '-100%');
            presetLayer.call(presetGrid);
        } else {
            panewrap.style('right', '-0%');
            tagLayer.call(tagEditor);
        }

        if (d3.event) {
            // Pan the map if the clicked feature intersects with the position
            // of the inspector
            var inspectorSize = selection.size(),
                mapSize = context.map().size(),
                offset = 50,
                shiftLeft = d3.event.clientX - mapSize[0] + inspectorSize[0] + offset,
                center = (mapSize[0] / 2) + shiftLeft + offset;

            if (shiftLeft > 0 && inspectorSize[1] > d3.event.clientY) {
                context.map().centerEase(context.projection.invert([center, mapSize[1]/2]));
            }
        }

        context.history()
            .on('change.inspector', update);
    }

    inspector.close = function(selection) {
        selection.transition()
            .style('right', '-500px')
            .each('end', function() {
                d3.select(this)
                    .style('display', 'none')
                    .html('');
            });

        // Firefox incorrectly implements blur, so typeahead elements
        // are not correctly removed. Remove any stragglers manually.
        d3.selectAll('div.typeahead').remove();

        context.history()
            .on('change.inspector', null);
    };

    return inspector;
};
iD.ui.Lasso = function() {

    var box, group,
        a = [0, 0],
        b = [0, 0];

    function lasso(selection) {

        d3.select('#iD').classed('lasso', true);

        group = selection.append('g')
            .attr('class', 'lasso hide');

        box = group.append('rect')
            .attr('class', 'lasso-box');

        group.call(iD.ui.Toggle(true));

    }

    // top-left
    function topLeft(d) {
        return 'translate(' + Math.min(d[0][0], d[1][0]) + ',' + Math.min(d[0][1], d[1][1]) + ')';
    }

    function width(d) { return Math.abs(d[0][0] - d[1][0]); }
    function height(d) { return Math.abs(d[0][1] - d[1][1]); }

    function draw() {
        if (box) {
            box.data([[a, b]])
                .attr('transform', topLeft)
                .attr('width', width)
                .attr('height', height);
        }
    }

    lasso.a = function(_) {
        if (!arguments.length) return a;
        a = _;
        draw();
        return lasso;
    };

    lasso.b = function(_) {
        if (!arguments.length) return b;
        b = _;
        draw();
        return lasso;
    };

    lasso.close = function() {
        if (group) {
            group.call(iD.ui.Toggle(false, function() {
                d3.select(this).remove();
            }));
        }
        d3.select('#iD').classed('lasso', false);
    };

    return lasso;
};
iD.ui.loading = function(selection, message, blocking) {
    var modal = iD.ui.modal(selection, blocking);

    var loadertext = modal.select('.content')
        .classed('loading-modal', true)
        .append('div').attr('class','modal-section fillL');

    loadertext.append('img').attr('class','loader').attr('src', 'img/loader.gif');
    loadertext.append('h3').text(message || '');

    modal.select('button.close').attr('class','hide');

    return modal;
};
iD.ui.modal = function(selection, blocking) {

    var previous = selection.select('div.modal');
    var animate = previous.empty();

    var keybinding = d3.keybinding('modal')
        .on('⌫', close)
        .on('⎋', close);

    d3.select(document).call(keybinding);

    previous.transition()
        .style('opacity', 0).remove();

    var shaded = selection
        .append('div')
        .attr('class', 'shaded')
        .style('opacity', 0)
        .on('click.remove-modal', function() {
            if (d3.event.target == this && !blocking) d3.select(this).remove();
        });

    var modal = shaded.append('div')
        .attr('class', 'modal fillL col6');

    modal.append('button')
        .attr('class', 'close')
        .on('click', function() {
            if (!blocking) shaded.remove();
        })
        .append('div')
            .attr('class','icon close');

    modal.append('div')
        .attr('class', 'content');

    if (animate) {
        shaded.transition().style('opacity', 1);
    } else {
        shaded.style('opacity', 1);
    }

    function close() {
        shaded.remove();
        keybinding.off();
    }

    return shaded;
};
iD.ui.Modes = function(context) {
    var modes = [
        iD.modes.AddPoint(context),
        iD.modes.AddLine(context),
        iD.modes.AddArea(context)];

    return function(selection, limiter) {
        var buttons = selection.selectAll('button.add-button')
            .data(modes);

       buttons.enter().append('button')
           .attr('tabindex', -1)
           .attr('class', function(mode) { return mode.id + ' add-button col4'; })
           .on('click.mode-buttons', function(mode) { context.enter(mode); })
           .call(bootstrap.tooltip()
               .placement('bottom')
               .html(true)
               .title(function(mode) {
                   return iD.ui.tooltipHtml(mode.description, mode.key);
               }));

        var notice = iD.ui.notice(limiter)
            .message(false)
            .on('zoom', function() { context.map().zoom(16); });

        function disableTooHigh() {
            if (context.map().editable()) {
                notice.message(false);
                buttons.attr('disabled', null);
            } else {
                buttons.attr('disabled', 'disabled');
                notice.message(true);
                context.enter(iD.modes.Browse(context));
            }
        }

        context.map()
            .on('move.mode-buttons', _.debounce(disableTooHigh, 500));

        buttons.append('span')
            .attr('class', function(mode) { return mode.id + ' icon icon-pre-text'; });

        buttons.append('span')
            .attr('class', 'label')
            .text(function(mode) { return mode.title; });

        context.on('enter.editor', function(entered) {
            buttons.classed('active', function(mode) { return entered.button === mode.button; });
            context.container()
                .classed("mode-" + entered.id, true);
        });

        context.on('exit.editor', function(exited) {
            context.container()
                .classed("mode-" + exited.id, false);
        });

        var keybinding = d3.keybinding('mode-buttons');

        modes.forEach(function(m) {
            keybinding.on(m.key, function() { if (context.map().editable()) context.enter(m); });
        });

        d3.select(document)
            .call(keybinding);
    };
};
iD.ui.notice = function(selection) {
    var event = d3.dispatch('zoom'),
        notice = {};

    var div = selection.append('div')
        .attr('class', 'notice');

    var button = div.append('button')
        .attr('class', 'zoom-to notice')
        .on('click', event.zoom);

    button.append('span')
        .attr('class', 'icon zoom-in-invert');

    button.append('span')
        .attr('class', 'label')
        .text(t('zoom_in_edit'));

    notice.message = function(_) {
        if (_) {
            selection.select('.button-wrap').style('display', 'none');
            div.style('display', 'block');
        } else {
            selection.select('.button-wrap').style('display', 'block');
            div.style('display', 'none');
        }
        return notice;
    };

    return d3.rebind(notice, event, 'on');
};
iD.ui.preset = function(context, entity) {
    var event = d3.dispatch('change', 'setTags', 'close'),
        tags,
        keys,
        preset,
        formwrap,
        formbuttonwrap;

    function presets(selection) {
        selection.html('');

        keys = [];
        formwrap = selection.append('div');

        var geometry = entity.geometry(context.graph()),
            fields = preset.fields.filter(function(f) {
                return f.matchGeometry(geometry);
            });

        fields.unshift(context.presets().field('name'));

        draw(formwrap, fields);

        var wrap = selection.append('div')
            .attr('class', 'col12 more-buttons inspector-inner');

        formbuttonwrap = wrap.append('div')
            .attr('class', 'col12 preset-input');

        formbuttonwrap.selectAll('button')
            .data(context.presets().universal().filter(notInForm))
            .enter()
            .append('button')
            .attr('class', 'preset-add-field')
            .on('click', addForm)
            .call(bootstrap.tooltip()
                .placement('top')
                .title(function(d) { return d.label(); }))
            .append('span')
            .attr('class', function(d) { return 'icon ' + d.icon; });

        function notInForm(p) {
            return preset.fields.indexOf(p) < 0;
        }

        function addForm(d) {
            var field = draw(formwrap, [d]);

            var input = field.selectAll('input, textarea').node();
            if (input) input.focus();

            d3.select(this)
                .style('opacity', 1)
                .transition()
                .style('opacity', 0)
                .remove();

            if (!wrap.selectAll('button').node()) {
                wrap.remove();
            }
        }
    }

    function draw(selection, fields) {
        var sections = selection.selectAll('div.form-field')
            .data(fields, function(field) { return field.id; })
            .enter()
            .append('div')
            .style('opacity', 0)
            .attr('class', function(field) {
                return 'form-field form-field-' + field.id + ' fillL inspector-inner col12';
            });

        var label = sections.append('label')
            .attr('class', 'form-label')
            .attr('for', function(field) { return 'preset-input-' + field.id; })
            .text(function(field) { return field.label(); });

        label.append('button')
            .attr('class', 'fr icon undo modified-icon')
            .attr('tabindex', -1)
            .on('click', function(field) {
                var original = context.graph().base().entities[entity.id];
                var t = {};
                (field.keys || [field.key]).forEach(function(key) {
                    t[key] = original ? original.tags[key] : undefined;
                });
                event.change(t);
            });

        label.append('button')
            .attr('class', 'fr icon inspect')
            .attr('tabindex', -1)
            .on('click', function(field) {
                selection.selectAll('div.tag-help')
                    .style('display', 'none');

                d3.select(d3.select(this).node().parentNode.parentNode)
                    .select('div.tag-help')
                    .style('display', 'block')
                    .call(iD.ui.TagReference(entity, {key: field.key}));
            });

        sections.transition()
            .style('opacity', 1);

        sections.each(function(field) {
            var i = iD.ui.preset[field.type](field, context)
                .on('close', event.close)
                .on('change', event.change);

            event.on('setTags.' + field.id, function(tags) {
                i.tags(_.clone(tags));
            });

            if (field.type === 'address') i.entity(entity);

            keys = keys.concat(field.key ? [field.key] : field.keys);

            d3.select(this).call(i);
        });

        sections.append('div')
            .attr('class', 'tag-help');

        return sections;
    }

    presets.rendered = function() {
        return keys;
    };

    presets.preset = function(_) {
        if (!arguments.length) return preset;
        preset = _;
        return presets;
    };

    presets.change = function(t) {
        tags = t;

        function haveKey(k) { return k && !!tags[k]; }

        formbuttonwrap.selectAll('button').each(function(p) {
            if (haveKey(p.key) || _.any(p.keys, haveKey)) {
                draw(formwrap, [p]);
                d3.select(this).remove();
            }
        });

        formwrap.selectAll('div.form-field')
            .classed('modified', function(d) {
                var original = context.graph().base().entities[entity.id];
                return _.any(d.keys || [d.key], function(key) {
                    return original ? tags[key] !== original.tags[key] : tags[key];
                });
            });

        event.setTags(tags);
        return presets;
    };

    return d3.rebind(presets, event, 'on');
};
iD.ui.PresetGrid = function(context, entity) {
    var event = d3.dispatch('choose', 'close'),
        default_limit = 9,
        currently_drawn = 9,
        presets,
        taginfo = iD.taginfo();

    function presetgrid(selection, preset) {

        selection.html('');

        presets = context.presets().matchGeometry(entity, context.graph());

        var messagewrap = selection.append('div')
            .attr('class', 'header fillL cf');

        var message = messagewrap.append('h3')
            .attr('class', 'inspector-inner')
            .text(t('inspector.choose'));

        if (preset) {
            messagewrap.append('button')
                .attr('class', 'preset-choose')
                .on('click', event.choose)
                .append('span')
                .attr('class', 'icon forward');
        } else {
            messagewrap.append('button')
                .attr('class', 'close')
                .on('click', event.close)
                .append('span')
                .attr('class', 'icon close');
        }

        var gridwrap = selection.append('div')
            .attr('class', 'fillL2 inspector-body inspector-body-' + entity.geometry(context.graph()));

        var grid = gridwrap.append('div')
            .attr('class', 'preset-grid fillL cf')
            .data([context.presets().defaults(entity, 36).collection]);

        var show_more = gridwrap.append('button')
            .attr('class', 'fillL show-more')
            .text(t('inspector.show_more'))
            .on('click', function() {
                grid.call(drawGrid, (currently_drawn += default_limit));
            });

        grid.call(drawGrid, default_limit);

        var searchwrap = selection.append('div')
            .attr('class', 'preset-grid-search-wrap inspector-inner');

        function keydown() {
            // hack to let delete shortcut work when search is autofocused
            if (search.property('value').length === 0 &&
                (d3.event.keyCode === d3.keybinding.keyCodes['⌫'] ||
                 d3.event.keyCode === d3.keybinding.keyCodes['⌦'])) {
                d3.event.preventDefault();
                d3.event.stopPropagation();
                iD.operations.Delete([entity.id], context)();
            } else if (search.property('value').length === 0 &&
                (d3.event.ctrlKey || d3.event.metaKey) &&
                d3.event.keyCode === d3.keybinding.keyCodes.z) {
                d3.event.preventDefault();
                d3.event.stopPropagation();
                context.undo();
            } else if (!d3.event.ctrlKey && !d3.event.metaKey) {
                d3.select(this).on('keydown', null);
            }
        }

        function keyup() {
            // enter
            var value = search.property('value');
            if (d3.event.keyCode === 13 && value.length) {
                choose(grid.selectAll('.grid-entry:first-child').datum());
            } else {
                currently_drawn = default_limit;
                grid.classed('filtered', value.length);
                if (value.length) {
                    var results = presets.search(value);
                    message.text(t('inspector.results', {
                        n: results.collection.length,
                        search: value
                    }));
                    grid.data([results.collection])
                        .call(drawGrid, default_limit);
                } else {
                    grid.data([context.presets().defaults(entity, 36).collection])
                        .call(drawGrid, default_limit);
                }
            }
        }

        var search = searchwrap.append('input')
            .attr('class', 'preset-grid-search major')
            .attr('placeholder','Search')
            .attr('type', 'search')
            .on('keydown', keydown)
            .on('keyup', keyup);

        searchwrap.append('span')
            .attr('class', 'icon search');

        search.node().focus();

        function choose(d) {
            // Category
            if (d.members) {
                var subgrid = insertBox(grid, d, 'subgrid');

                if (subgrid) {
                    subgrid.append('div')
                        .attr('class', 'arrow');

                    subgrid.append('div')
                        .attr('class', 'preset-grid fillL2 cf fl')
                        .data([d.members.collection])
                        .call(drawGrid, 1000);

                    subgrid.style('max-height', '0px')
                        .style('padding-bottom', '0px')
                        .transition()
                        .duration(300)
                        .style('padding-bottom', '20px')
                        .style('max-height', (d.members.collection.length / 3 * 150) + 200 + 'px');
                }

            // Preset
            } else {
                context.presets().choose(d);
                event.choose(d);
            }
        }

        function name(d) { return d.name(); }

        function presetClass(d) {
            var s = 'preset-icon-fill ' + entity.geometry(context.graph());
            if (d.members) {
                s += 'category';
            } else {
                for (var i in d.tags) {
                    s += ' tag-' + i + ' tag-' + i + '-' + d.tags[i];
                }
            }
            return s;
        }

        // Inserts a div inline after the entry for the provided entity
        // Used for preset descriptions, and for expanding categories
        function insertBox(grid, entity, klass) {

            var entries = grid.selectAll('button.grid-entry'),
                shown = grid.selectAll('.box-insert'),
                shownIndex = Infinity,
                index;

            if (shown.node()) {
                shown.transition()
                    .duration(200)
                    .style('opacity','0')
                    .style('max-height', '0px')
                    .style('padding-top', '0px')
                    .style('padding-bottom', '0px')
                    .each('end', function() {
                        shown.remove();
                    });


                if (shown.datum() === entity && shown.classed(klass)) return;
                shownIndex = Array.prototype.indexOf.call(shown.node().parentNode.childNodes, shown.node());
            }

            entries.each(function(d, i) {
                if (d === entity) index = i;
            });

            var insertIndex = index + 3 - index % 3;
            if (insertIndex > shownIndex) insertIndex ++;

            var elem = document.createElement('div');
            grid.node().insertBefore(elem, grid.node().childNodes[insertIndex]);

            var newbox = d3.select(elem)
                .attr('class', 'col12 box-insert ' + klass + ' arrow-' + (index % 3))
                .datum(entity);

            return newbox;
        }

        function drawGrid(selection, limit) {

            function helpClick(d) {
                d3.event.stopPropagation();

                var presetinspect = insertBox(selection, d, 'preset-inspect');

                if (!presetinspect) return;

                presetinspect
                    .style('max-height', '0px')
                    .style('padding-top', '0px')
                    .style('padding-bottom', '0px')
                    .style('opacity', '0')
                    .transition()
                    .duration(200)
                    .style('padding-top', '10px')
                    .style('padding-bottom', '20px')
                    .style('max-height', '200px')
                    .style('opacity', '1');

                presetinspect.append('h3')
                    .text(d.name());

                var tag = {key: Object.keys(d.tags)[0]};

                if (d.tags[tag.key] !== '*') {
                    tag.value = d.tags[tag.key];
                }

                presetinspect.append('div')
                    .call(iD.ui.TagReference(entity, tag));
            }

            if (selection.node() === grid.node()) {
                show_more
                    .style('display', (selection.data()[0].length > limit) ? 'block' : 'none');
            }

            selection.selectAll('.preset-inspect, .subgrid').remove();

            var entries = selection
                .selectAll('div.grid-entry-wrap')
                .data(function(d) { return d.slice(0, limit); }, name);

            entries.exit().remove();

            var entered = entries.enter()
                .append('div')
                .attr('class','grid-button-wrap col4 grid-entry-wrap')
                .classed('category', function(d) { return !!d.members; })
                .classed('current', function(d) { return d === preset; })
                    .append('button')
                    .attr('class', 'grid-entry')
                    .on('click', choose);

            entered.style('opacity', 0)
                    .transition()
                    .style('opacity', 1);

            entered.append('div')
                .attr('class', presetClass);

            var geometry = entity.geometry(context.graph()),
                fallbackIcon = geometry === 'line' ? 'other-line' : 'marker-stroked';

            entered.append('div')
                .attr('class', function(d) {
                    return 'feature-' + (d.icon || fallbackIcon) + ' icon';
                });

            entered.append('span')
                .attr('class','label')
                .text(name);

            entered.filter(function(d) {
                    return !d.members;
                })
                .append('button')
                .attr('tabindex', -1)
                .attr('class', 'preset-help')
                .on('click', helpClick, selection)
                .append('span')
                    .attr('class', 'icon inspect');

            entries.order();
        }
    }

    return d3.rebind(presetgrid, event, 'on');
};
iD.ui.RadialMenu = function(operations) {
    var menu,
        center = [0, 0],
        tooltip;

    var radialMenu = function(selection) {
        if (!operations.length)
            return;

        selection.node().parentNode.focus();

        function click(operation) {
            d3.event.stopPropagation();
            operation();
        }

        menu = selection.append('g')
            .attr('class', 'radial-menu')
            .attr('transform', "translate(" + center + ")")
            .attr('opacity', 0);

        menu.transition()
            .attr('opacity', 1);

        var r = 50,
            a = Math.PI / 4,
            a0 = -Math.PI / 4,
            a1 = a0 + (operations.length - 1) * a;

        menu.append('path')
            .attr('class', 'radial-menu-background')
            .attr('d', 'M' + r * Math.sin(a0) + ',' +
                             r * Math.cos(a0) +
                      ' A' + r + ',' + r + ' 0 0,0 ' +
                             r * Math.sin(a1) + ',' +
                             r * Math.cos(a1))
            .attr('stroke-width', 50)
            .attr('stroke-linecap', 'round');

        var button = menu.selectAll()
            .data(operations)
            .enter().append('g')
            .attr('transform', function(d, i) {
                return 'translate(' + r * Math.sin(a0 + i * a) + ',' +
                                      r * Math.cos(a0 + i * a) + ')';
            });

        button.append('circle')
            .attr('class', function(d) { return 'radial-menu-item radial-menu-item-' + d.id; })
            .attr('r', 15)
            .classed('disabled', function(d) { return !d.enabled(); })
            .on('click', click)
            .on('mouseover', mouseover)
            .on('mouseout', mouseout);

        button.append('use')
            .attr('transform', 'translate(-10, -10)')
            .attr('clip-path', 'url(#clip-square-20)')
            .attr('xlink:href', function(d) { return '#icon-operation-' + d.id; });

        tooltip = d3.select(document.body)
            .append('div')
            .attr('class', 'tooltip-inner radial-menu-tooltip');

        function mouseover(d, i) {
            var angle = a0 + i * a,
                dx = angle < 0 ? -200 : 0,
                dy = 0;

            tooltip
                .style('left', (r + 25) * Math.sin(angle) + dx + center[0] + 'px')
                .style('top', (r + 25) * Math.cos(angle) + dy + center[1]+ 'px')
                .style('display', 'block')
                .html(iD.ui.tooltipHtml(d.description, d.keys[0]));
        }

        function mouseout() {
            tooltip.style('display', 'none');
        }
    };

    radialMenu.close = function() {
        if (menu) {
            menu.transition()
                .attr('opacity', 0)
                .remove();
        }

        if (tooltip) {
            tooltip.remove();
        }
    };

    radialMenu.center = function(_) {
        if (!arguments.length) return center;
        center = _;
        return radialMenu;
    };

    return radialMenu;
};
iD.ui.Restore = function(context) {
    return function(selection) {
        if (!context.history().lock() || !context.history().restorableChanges())
            return;

        var modal = iD.ui.modal(selection);

        modal.select('.modal')
            .attr('class', 'modal fillL col6');

        var introModal = modal.select('.content');

        introModal.attr('class','cf');

        introModal.append('div')
            .attr('class', 'modal-section header')
            .append('h3')
                .text(t('restore.heading'));

        introModal.append('div')
            .attr('class','modal-section')
            .append('p')
                .text(t('restore.description'));


        var buttonWrap = introModal.append('div')
            .attr('class', 'modal-section col12');

        var buttons = buttonWrap
            .append('div')
            .attr('class', 'button-wrap joined col4');

        var restore = buttons.append('button')
            .attr('class', 'save action button col6')
            .text(t('restore.restore'))
            .on('click', function() {
                context.history().load();
                modal.remove();
            });

        buttons.append('button')
            .attr('class', 'cancel button col6')
            .text(t('restore.reset'))
            .on('click', function() {
                context.history().clearSaved();
                modal.remove();
            });

        restore.node().focus();
    };
};
iD.ui.Save = function(context) {
    var map = context.map(),
        history = context.history(),
        connection = context.connection(),
        key = iD.ui.cmd('⌘S'),
        modal;

    function save() {
        d3.event.preventDefault();

        if (!history.hasChanges()) return;

        connection.authenticate(function(err) {
            modal = iD.ui.modal(context.container());
            var changes = history.changes();
            changes.connection = connection;
            modal.select('.content')
                .classed('commit-modal', true)
                .datum(changes)
                .call(iD.ui.Commit(context)
                    .on('cancel', function() {
                        modal.remove();
                    })
                    .on('fix', clickFix)
                    .on('save', commit));
        });
    }

    function commit(e) {
        context.container().select('.shaded')
            .remove();

        var loading = iD.ui.loading(context.container(), t('save.uploading'), true);

        connection.putChangeset(
            history.changes(),
            e.comment,
            history.imagery_used(),
            function(err, changeset_id) {
                loading.remove();
                if (err) {
                    var confirm = iD.ui.confirm(context.container());
                    confirm
                        .select('.modal-section.header')
                        .append('h3')
                        .text(t('save.error'));
                    confirm
                        .select('.modal-section.message-text')
                        .append('p')
                        .text(err.responseText);
                } else {
                    history.reset();
                    map.flush().redraw();
                    success(e, changeset_id);
                }
            });
    }

    function success(e, changeset_id) {
        modal = iD.ui.modal(context.container());
        modal.select('.content')
            .classed('success-modal', true)
            .datum({
                id: changeset_id,
                comment: e.comment
            })
            .call(iD.ui.Success(connection)
                .on('cancel', function() {
                    modal.remove();
                }));
    }

    function clickFix(d) {
        var extent = d.entity.extent(context.graph());
        map.centerZoom(extent.center(), Math.min(19, map.extentZoom(extent)));
        context.enter(iD.modes.Select(context, [d.entity.id]));
        modal.remove();
    }

    return function(selection) {
        var button = selection.append('button')
            .attr('class', 'save col12 disabled')
            .attr('tabindex', -1)
            .on('click', save)
            .attr('data-original-title',
                iD.ui.tooltipHtml(t('save.no_changes'), key))
            .call(bootstrap.tooltip()
                .placement('bottom')
                .html(true));

        button.append('span')
            .attr('class', 'label')
            .text(t('save.title'));

        button.append('span')
            .attr('class', 'count');

        var keybinding = d3.keybinding('undo-redo')
            .on(key, save);

        d3.select(document)
            .call(keybinding);

        context.history().on('change.save', function() {
            var hasChanges = history.hasChanges();

            button
                .attr('data-original-title',
                    iD.ui.tooltipHtml(t(hasChanges ?
                        'save.help' : 'save.no_changes'), key));

            button
                .classed('disabled', !hasChanges)
                .classed('has-count', hasChanges);

            button.select('span.count')
                .text(history.numChanges());
        });
    };
};
iD.ui.SourceSwitch = function(context) {
    function click() {
        d3.event.preventDefault();

        if (context.history().hasChanges() &&
            !window.confirm(t('source_switch.lose_changes'))) return;

        var live = d3.select(this).classed('live');

        context.connection()
            .url(live ? 'http://localhost:3000' : 'http://localhost:3000');

        context.map()
            .flush();

        d3.select(this)
            .text(live ? t('source_switch.dev') : t('source_switch.live'))
            .classed('live', !live);
    }

    return function(selection) {
        selection.append('a')
            .attr('href', '#')
            .text(t('source_switch.live'))
            .classed('live', true)
            .attr('tabindex', -1)
            .on('click', click);
    };
};
iD.ui.Spinner = function(context) {
    var connection = context.connection();

    return function(selection) {
        var img = selection.append('img')
            .attr('src', 'img/loader-black.gif')
            .style('opacity', 0);

        connection.on('loading.spinner', function() {
            img.transition()
                .style('opacity', 1);
        });

        connection.on('loaded.spinner', function() {
            img.transition()
                .style('opacity', 0);
        });
    }
};
iD.ui.Splash = function(context) {
    return function(selection) {
        if (context.storage('sawSplash'))
            return;

        context.storage('sawSplash', true);

        var modal = iD.ui.modal(selection);

        modal.select('.modal')
            .attr('class', 'modal-splash modal');

        var introModal = modal.select('.content')
            .append('div')
            .attr('class', 'modal-section fillL');

        introModal.append('div')
            .attr('class', 'logo');

        var div = introModal.append('div');

        div.append("h2")
            .text(t('splash.welcome'));

        div.append("p")
            .html(t('splash.text', {
                version: iD.version,
                website: '<a href="http://ideditor.com/">ideditor.com</a>',
                github: '<a href="https://github.com/systemed/iD">github.com</a>'
            }));
    };
};
iD.ui.Success = function(connection) {
    var event = d3.dispatch('cancel', 'save');

    function success(selection) {
        var changeset = selection.datum(),
            header = selection.append('div').attr('class', 'header modal-section'),
            body = selection.append('div').attr('class', 'body');

        header.append('h3').text(t('just_edited'));

        var m = '';
        if (changeset.comment) {
            m = '"' + changeset.comment.substring(0, 20) + '" ';
        }

        var message = (m || 'Edited OSM!') +
            connection.changesetUrl(changeset.id);

        var links = body.append('div').attr('class','cf');

        links.append('a')
            .attr('class','col6 success-action modal-section osm')
            .attr('target', '_blank')
            .attr('href', function() {
                return connection.changesetUrl(changeset.id);
            })
            .text(t('view_on_osm'));

        links.append('a')
            .attr('class','col6 success-action modal-section twitter')
            .attr('target', '_blank')
            .attr('href', function() {
                return 'https://twitter.com/intent/tweet?source=webclient&text=' +
                    encodeURIComponent(message);
            })
            .text('Tweet');

        var section = body.append('div').attr('class','modal-section cf');

        section.append('button')
            .attr('class', 'action col2')
            .on('click.save', function() {
                event.cancel();
            })
            .append('span').attr('class','label').text('Okay');
    }

    return d3.rebind(success, event, 'on');
};
iD.ui.TagEditor = function(context, entity) {
    var event = d3.dispatch('changeTags', 'choose', 'close'),
        presets = context.presets(),
        tags,
        preset,
        selection_,
        presetUI,
        tagList;

    function tageditor(selection, newpreset) {
        selection_ = selection;
        var geometry = entity.geometry(context.graph());

        if (!preset) preset = presets.match(entity, context.graph());

        // preset was explicitly chosen
        if (newpreset) {
            tags = preset.removeTags(tags, geometry);

            newpreset.applyTags(tags, geometry);
            preset = newpreset;
        }

        selection.html('');

        var messagewrap = selection.append('div')
            .attr('class', 'header fillL cf');

        messagewrap.append('button')
            .attr('class', 'preset-reset fl ')
            .on('click', function() {
                event.choose(preset);
            })
            .append('span')
            .attr('class', 'icon back');

        var icon = preset.icon || (geometry === 'line' ? 'other-line' : 'marker-stroked');

        messagewrap.append('h3')
            .attr('class', 'inspector-inner')
            .text(t('inspector.editing_feature', { feature: preset.name() }));

        messagewrap.append('button')
            .attr('class', 'preset-close fr')
            .on('click', event.close)
            .append('span')
            .attr('class', 'icon close');

        var editorwrap = selection.append('div')
            .attr('class', 'tag-wrap inspector-body fillL2 inspector-body-' + geometry);

        editorwrap.append('div')
            .attr('class', 'col12 inspector-inner fillL2 preset-icon-wrap')
            .append('div')
                .attr('class','fillL')
                .append('span')
                    .attr('class', geometry + ' preset-icon icon feature-' + icon);

        presetUI = iD.ui.preset(context, entity)
            .preset(preset)
            .on('change', changeTags)
            .on('close', event.close);

        tagList = iD.ui.Taglist(context, entity)
            .on('change', changeTags);

        var tageditorpreset = editorwrap.append('div')
            .attr('class', 'inspector-preset cf fillL col12')
            .call(presetUI);

        editorwrap.append('div')
            .attr('class', 'inspector-inner col12 fillL2 additional-tags')
            .call(tagList, preset.id === 'other');

        if (!entity.isNew()) {
            tageditorpreset.append('div')
                .attr('class', 'col12 inspector-inner')
                .append('a')
                .attr('href', 'http:/localhost:3000/browse/' + entity.type + '/' + entity.osmId())
                .attr('target', '_blank')
                .text(t('inspector.view_on_osm'));
        }

        tageditor.tags(tags);
        changeTags();
    }

    function clean(o) {
        var out = {};
        for (var k in o) {
            if (o[k] && o[k] !== '') out[k] = o[k];
        }
        return out;
    }

    function changeTags(changed) {
        tags = clean(_.extend(tags, changed));
        event.changeTags(_.clone(tags));
    }

    tageditor.tags = function(newtags) {
        tags = _.clone(newtags);
        if (presetUI && tagList) {

            // change preset if necessary (undos/redos)
            var newmatch = presets
                .matchGeometry(entity, context.graph())
                .matchTags(entity.update({ tags: tags }));
            if (newmatch !== preset) {
                return tageditor(selection_, newmatch);
            }

            presetUI.change(tags);
            var rendered = []
                .concat(Object.keys(preset.tags))
                .concat(presetUI.rendered());
            tagList.tags(_.omit(tags, rendered));
        }
        return tageditor;
    };

    return d3.rebind(tageditor, event, 'on');
};
iD.ui.TagReference = function(entity, tag) {
    var taginfo = iD.taginfo();

    function findLocal(docs) {
        var locale = iD.detect().locale.toLowerCase(),
            localized;

        localized = _.find(docs, function(d) {
            return d.lang.toLowerCase() === locale;
        });
        if (localized) return localized;

        // try the non-regional version of a language, like
        // 'en' if the language is 'en-US'
        if (locale.indexOf('-') !== -1) {
            var first = locale.split('-')[0];
            localized = _.find(docs, function(d) {
                return d.lang.toLowerCase() === first;
            });
            if (localized) return localized;
        }

        // finally fall back to english
        return _.find(docs, function(d) {
            return d.lang.toLowerCase() === 'en';
        });
    }

    return function(selection) {
        selection.html('');

        taginfo.docs(tag, function(err, docs) {
            if (!err && docs) {
                docs = findLocal(docs);
            }

            if (!docs || !docs.description) {
                return selection.text(t('inspector.no_documentation_key'));
            }

            var referenceBody = selection.append('div')
                .attr('class','modal-section fillL2');

            if (docs.image && docs.image.thumb_url_prefix) {
                referenceBody
                    .append('img')
                    .attr('class', 'wiki-image')
                    .attr('src', docs.image.thumb_url_prefix + "100" + docs.image.thumb_url_suffix);
            }

            referenceBody
                .append('p')
                .text(docs.description);

            referenceBody
                .append('a')
                .attr('target', '_blank')
                .attr('href', 'http://wiki.openfloorplan.org/wiki/' + docs.title)
                .text(t('inspector.reference'));
        });
    }
};
iD.ui.Taglist = function(context, entity) {
    var event = d3.dispatch('change'),
        taginfo = iD.taginfo(),
        collapsebutton,
        list;

    function taglist(selection, other) {

        collapsebutton = selection.append('a')
            .attr('href','#')
            .attr('class','hide-toggle')
            .text(t('inspector.additional'))
            .on('click', function() {
                iD.ui.Taglist.expanded = wrap.classed('hide');
                collapsebutton.classed('expanded', iD.ui.Taglist.expanded);
                wrap.call(iD.ui.Toggle(iD.ui.Taglist.expanded));
                selection.node().parentNode.scrollTop += 200;
            })
            .classed('expanded', iD.ui.Taglist.expanded || other);

        var wrap = selection.append('div')
            .classed('hide', !iD.ui.Taglist.expanded && !other);

        list = wrap.append('ul')
            .attr('class', 'tag-list');

        var newTag = wrap.append('button')
            .attr('class', 'add-tag col6')
            .on('click', addTag);

        newTag.append('span')
            .attr('class', 'icon plus');

        newTag.append('span')
            .attr('class', 'label')
            .text(t('inspector.new_tag'));
    }

    function drawTags(tags) {
        collapsebutton.text(t('inspector.additional') + ' (' + Object.keys(tags).length + ')');

        tags = d3.entries(tags);

        if (!tags.length) {
            tags = [{key: '', value: ''}];
        }

        var li = list.html('')
            .selectAll('li')
            .data(tags, function(d) { return d.key; });

        li.exit().remove();

        var row = li.enter().append('li')
            .attr('class', 'tag-row');

        row.append('div')
            .attr('class', 'key-wrap col6')
            .append('input')
            .property('type', 'text')
            .attr('class', 'key')
            .attr('maxlength', 255)
            .property('value', function(d) { return d.key; })
            .on('blur', function(d) {
                d.key = this.value;
                event.change(taglist.tags());
            });

        row.append('div')
            .attr('class', 'input-wrap-position col6')
            .append('input')
            .property('type', 'text')
            .attr('class', 'value')
            .attr('maxlength', 255)
            .property('value', function(d) { return d.value; })
            .on('blur', function(d) {
                d.value = this.value;
                event.change(taglist.tags());
            })
            .on('keydown.push-more', pushMore);

        row.each(bindTypeahead);

        row.append('button')
            .attr('tabindex', -1)
            .attr('class','remove minor')
            .on('click', removeTag)
            .append('span')
            .attr('class', 'icon delete');

        row.append('button')
            .attr('tabindex', -1)
            .attr('class', 'tag-help minor')
            .on('click', function(tag) {
                row.selectAll('div.tag-help')
                    .style('display', 'none');

                d3.select(d3.select(this).node().parentNode)
                    .select('div.tag-help')
                    .style('display', 'block')
                    .call(iD.ui.TagReference(entity, {key: tag.key}));
            })
            .append('span')
            .attr('class', 'icon inspect');

        row.append('div')
            .attr('class', 'tag-help');

        return li;
    }

    function pushMore() {
        if (d3.event.keyCode === 9 &&
            list.selectAll('li:last-child input.value').node() === this &&
            !d3.event.shiftKey) {
            addTag();
            d3.event.preventDefault();
        }
    }

    function bindTypeahead() {
        var geometry = entity.geometry(context.graph()),
            row = d3.select(this),
            key = row.selectAll('input.key'),
            value = row.selectAll('input.value');

        function sort(value, data) {
            var sameletter = [],
                other = [];
            for (var i = 0; i < data.length; i++) {
                if (data[i].value.substring(0, value.length) === value) {
                    sameletter.push(data[i]);
                } else {
                    other.push(data[i]);
                }
            }
            return sameletter.concat(other);
        }

        key.call(d3.combobox()
            .fetcher(function(value, __, callback) {
                taginfo.keys({
                    debounce: true,
                    geometry: geometry,
                    query: value
                }, function(err, data) {
                    if (!err) callback(sort(value, data));
                });
            }));

        value.call(d3.combobox()
            .fetcher(function(value, __, callback) {
                taginfo.values({
                    debounce: true,
                    key: key.property('value'),
                    geometry: geometry,
                    query: value
                }, function(err, data) {
                    if (!err) callback(sort(value, data));
                });
            }));
    }

    function addTag() {
        var tags = taglist.tags();
        tags[''] = '';
        drawTags(tags);
        list.selectAll('li:last-child input.key').node().focus();
    }

    function removeTag(d) {
        var tags = taglist.tags();
        tags[d.key] = '';
        event.change(tags);
        delete tags[d.key];
        drawTags(tags);
    }

    taglist.tags = function(tags) {
        if (!arguments.length) {
            tags = {};
            list.selectAll('li').each(function() {
                var row = d3.select(this),
                    key = row.selectAll('.key').property('value'),
                    value = row.selectAll('.value').property('value');
                if (key !== '') tags[key] = value;
            });
            return tags;
        } else {
            drawTags(tags);
        }
    };

    return d3.rebind(taglist, event, 'on');
};
iD.ui.Tail = function() {
    var text = false,
        container,
        inner,
        xmargin = 25,
        tooltip_size = [0, 0],
        selection_size = [0, 0],
        transformProp = iD.util.prefixCSSProperty('Transform');

    function tail(selection) {
        d3.select(window).on('resize.tail-size', function() {
            selection_size = selection.size();
        });

        function setup() {
            container = d3.select(document.body)
                .append('div')
                .style('display', 'none')
                .attr('class', 'tail tooltip-inner');

            inner = container.append('div');

            selection
                .on('mousemove.tail', mousemove)
                .on('mouseover.tail', mouseover)
                .on('mouseout.tail', mouseout);

            container
                .on('mousemove.tail', mousemove);

            selection_size = selection.size();
        }

        function show() {
            container.style('display', 'block');
            tooltip_size = container.size();
        }

        function mousemove() {
            if (text === false) return;
            if (container.style('display') === 'none') show();
            var xoffset = ((d3.event.clientX + tooltip_size[0] + xmargin) > selection_size[0]) ?
                -tooltip_size[0] - xmargin : xmargin;
            container.classed('left', xoffset > 0);
            container.style(transformProp, 'translate(' +
                (~~d3.event.clientX + xoffset) + 'px,' +
                ~~d3.event.clientY + 'px)');
        }

        function mouseout() {
            if (d3.event.relatedTarget !== container.node() &&
                text !== false) container.style('display', 'none');
        }

        function mouseover() {
            if (d3.event.relatedTarget !== container.node() &&
                text !== false) show();
        }

        if (!container) setup();
    }

    tail.text = function(_) {
        if (!arguments.length) return text;
        if (_ === false) {
            text = _;
            container.style('display', 'none');
            return tail;
        }
        text = _;
        inner.text(text);
        tooltip_size = container.size();
        return tail;
    };

    return tail;
};
// toggles the visibility of ui elements, using a combination of the
// hide class, which sets display=none, and a d3 transition for opacity.
// this will cause blinking when called repeatedly, so check that the
// value actually changes between calls.
iD.ui.Toggle = function(show, callback) {
    return function(selection) {
        selection.style('opacity', show ? 0 : 1)
            .classed('hide', false)
            .transition()
            .style('opacity', show ? 1 : 0)
            .each('end', function() {
                d3.select(this).classed('hide', !show);
                if (callback) callback.apply(this);
            });
    };
};
iD.ui.UndoRedo = function(context) {
    return function(selection) {
        var tooltip = bootstrap.tooltip()
            .placement('bottom')
            .html(true);

        var undoButton = selection.append('button')
            .attr('class', 'col6 disabled')
            .html('<span class="undo icon"/>')
            .on('click', context.undo)
            .call(tooltip);

        var redoButton = selection.append('button')
            .attr('class', 'col6 disabled')
            .html('<span class="redo icon"/>')
            .on('click', context.redo)
            .call(tooltip);

        var keybinding = d3.keybinding('undo')
            .on(iD.ui.cmd('⌘Z'), context.undo)
            .on(iD.ui.cmd('⌘⇧Z'), context.redo);

        d3.select(document)
            .call(keybinding);

        context.history().on('change.editor', function() {
            var undo = context.history().undoAnnotation(),
                redo = context.history().redoAnnotation();

            function refreshTooltip(selection) {
                if (selection.property('tooltipVisible')) {
                    selection.call(tooltip.show);
                }
            }

            undoButton
                .classed('disabled', !undo)
                .attr('data-original-title', iD.ui.tooltipHtml(undo || t('nothing_to_undo'), iD.ui.cmd('⌘Z')))
                .call(refreshTooltip);

            redoButton
                .classed('disabled', !redo)
                .attr('data-original-title', iD.ui.tooltipHtml(redo || t('nothing_to_redo'), iD.ui.cmd('⌘⇧Z')))
                .call(refreshTooltip);
        });
    };
};
iD.ui.Zoom = function(context) {
    var zooms = [{
        id: 'zoom-in',
        title: t('zoom.in'),
        action: context.zoomIn,
        key: '+'
    }, {
        id: 'zoom-out',
        title: t('zoom.out'),
        action: context.zoomOut,
        key: '-'
    }];

    return function(selection) {
        var button = selection.selectAll('button')
            .data(zooms)
            .enter().append('button')
            .attr('tabindex', -1)
            .attr('class', function(d) { return d.id; })
            .on('click.editor', function(d) { d.action(); })
            .call(bootstrap.tooltip()
                .placement('right')
                .html(true)
                .title(function(d) {
                    return iD.ui.tooltipHtml(d.title, d.key);
                }));

        button.append('span')
            .attr('class', function(d) { return d.id + ' icon'; });

        var keybinding = d3.keybinding('zoom')
            .on('+', function() { context.zoomIn(); })
            .on('-', function() { context.zoomOut(); })
            .on('⇧=', function() { context.zoomIn(); })
            .on('dash', function() { context.zoomOut(); });

        d3.select(document)
            .call(keybinding);
    };
};
iD.ui.preset.address = function(field, context) {

    var event = d3.dispatch('change', 'close'),
        housename,
        housenumber,
        street,
        city,
        entity;

    function getStreets() {

        var extent = entity.extent(context.graph()),
            l = extent.center(),
            dist = iD.geo.metersToCoordinates(l, [200, 200]),
            box = iD.geo.Extent(
                    [extent[0][0] - dist[0], extent[0][1] - dist[1]],
                    [extent[1][0] + dist[0], extent[1][1] + dist[1]]);

        return context.intersects(box)
            .filter(isAddressable)
            .map(function(d) {
                var loc = context.projection([
                    (extent[0][0] + extent[1][0]) / 2,
                    (extent[0][1] + extent[1][1]) / 2]),
                    closest = context.projection(iD.geo.chooseIndex(d, loc, context).loc);
                return {
                    title: d.tags.name,
                    value: d.tags.name,
                    dist: iD.geo.dist(closest, loc)
                };
            }).sort(function(a, b) {
                return a.dist - b.dist;
            });

        function isAddressable(d) {
            return d.tags.highway && d.tags.name && d.type === 'way';
        }
    }

    function address(selection) {

        function close() { return iD.behavior.accept().on('accept', event.close); }

        var wrap = selection.append('div')
            .attr('class', 'preset-input-wrap');

        housename = wrap.append('input')
            .property('type', 'text')
            .attr('placeholder', field.t('placeholders.housename'))
            .attr('class', 'addr-housename')
            .attr('id', 'preset-input-' + field.id)
            .on('blur', change)
            .on('change', change)
            .call(close());

        housenumber = wrap.append('input')
            .property('type', 'text')
            .attr('placeholder', field.t('placeholders.number'))
            .attr('class', 'addr-number')
            .on('blur', change)
            .on('change', change)
            .call(close());

        street = wrap.append('input')
            .property('type', 'text')
            .attr('placeholder', field.t('placeholders.street'))
            .attr('class', 'addr-street')
            .on('blur', change)
            .on('change', change)
            .call(d3.combobox().data(getStreets()));

        city = wrap.append('input')
            .property('type', 'text')
            .attr('placeholder', field.t('placeholders.city'))
            .attr('class', 'addr-city')
            .on('blur', change)
            .on('change', change)
            .call(close());
    }

    function change() {
        event.change({
            'addr:housename': housename.property('value'),
            'addr:housenumber': housenumber.property('value'),
            'addr:street': street.property('value'),
            'addr:city': city.property('value')
        });
    }

    address.entity = function(_) {
        if (!arguments.length) return entity;
        entity = _;
        return address;
    };

    address.tags = function(tags) {
        housename.property('value', tags['addr:housename'] || '');
        housenumber.property('value', tags['addr:housenumber'] || '');
        street.property('value', tags['addr:street'] || '');
        city.property('value', tags['addr:city'] || '');
        return address;
    };

    return d3.rebind(address, event, 'on');
};
iD.ui.preset.check = function(field) {

    var event = d3.dispatch('change', 'close'),
        values = ['', 'yes', 'no'],
        value = '',
        box,
        text,
        label;

    var check = function(selection) {

        selection.classed('checkselect', 'true');

        label = selection.append('label')
            .attr('class', 'preset-input-wrap');

        box = label.append('input')
            .property('indeterminate', true)
            .attr('type', 'checkbox')
            .attr('id', 'preset-input-' + field.id);

        text = label.append('span')
            .text('unknown')
            .attr('class', 'value');

        box.on('click', function() {
            var t = {};
            t[field.key] = values[(values.indexOf(value) + 1) % 3];
            check.tags(t);
            event.change(t);
            d3.event.stopPropagation();
        });
    };

    check.tags = function(tags) {
        value = tags[field.key] || '';
        box.property('indeterminate', !value);
        box.property('checked', value === 'yes');
        text.text(value || 'unknown');
        label.classed('set', !!value);
    };

    return d3.rebind(check, event, 'on');
};
iD.ui.preset.combo = function(field) {

    var event = d3.dispatch('change', 'close'),
        input;

    function combo(selection) {
        var combobox = d3.combobox();

        input = selection.append('input')
            .attr('type', 'text')
            .attr('id', 'preset-input-' + field.id)
            .on('change', change)
            .on('blur', change)
            .call(combobox);

        if (field.options) {
            options(field.options);
        } else {
            iD.taginfo().values({
                key: field.key
            }, function(err, data) {
                if (!err) options(_.pluck(data, 'value'));
            });
        }

        function options(opts) {
            combobox.data(opts.map(function(d) {
                var o = {};
                o.title = o.value = d.replace('_', ' ');
                return o;
            }));

            input.attr('placeholder', function() {
                if (opts.length < 3) return '';
                return opts.slice(0, 3).join(', ') + '...';
            });
        }
    }


    function change() {
        var t = {};
        t[field.key] = input.property('value').replace(' ', '_');
        event.change(t);
    }

    combo.tags = function(tags) {
        input.property('value', tags[field.key] || '');
    };

    return d3.rebind(combo, event, 'on');
};
iD.ui.preset.defaultcheck = function(field) {

    var event = d3.dispatch('change', 'close'),
        input;

    var check = function(selection) {

        input = selection.append('input')
            .attr('type', 'checkbox')
            .attr('id', 'preset-input-' + field.id)
            .on('change', function() {
                var t = {};
                t[field.key] = input.property('checked') ? field.value || 'yes' : undefined;
                event.change(t);
            });
    };

    check.tags = function(tags) {
        input.property('checked', !!tags[field.key] && tags[field.key] !== 'no');
    };

    return d3.rebind(check, event, 'on');
};
iD.ui.preset.text =
iD.ui.preset.number =
iD.ui.preset.tel =
iD.ui.preset.email =
iD.ui.preset.url = function(field) {

    var event = d3.dispatch('change', 'close'),
        input;

    function i(selection) {
        input = selection.append('input')
            .attr('type', field.type)
            .attr('id', 'preset-input-' + field.id)
            .attr('placeholder', field.placeholder || '')
            .on('blur', change)
            .on('change', change)
            .call(iD.behavior.accept().on('accept', event.close));

        function pm(elem, x) {
            var num = elem.value ?
                parseInt(elem.value, 10) : 0;
            if (!isNaN(num)) elem.value = num + x;
            change();
        }

        if (field.type == 'number') {
            var numbercontrols = selection.append('div')
                .attr('class', 'spin-control');

            numbercontrols
                .append('button')
                .attr('class', 'increment')
                .on('click', function() {
                    pm(input.node(), 1);
                });
            numbercontrols
                .append('button')
                .attr('class', 'decrement')
                .on('click', function() {
                    pm(input.node(), -1);
                });
        }
    }

    function change() {
        var t = {};
        t[field.key] = input.property('value');
        event.change(t);
    }

    i.tags = function(tags) {
        input.property('value', tags[field.key] || '');
    };

    return d3.rebind(i, event, 'on');
};
iD.ui.preset.radio = function(field) {

    var event = d3.dispatch('change', 'close'),
        buttons;

    function radio(selection) {
        selection.classed('preset-radio', true);

        var buttonwrap = selection.append('div')
            .attr('class', 'preset-input-wrap radio-wrap');

        buttons = buttonwrap.selectAll('button')
            .data(field.keys || field.options)
            .enter()
            .append('button')
            .text(function(d) { return field.t('options.' + d, { 'default': d }); })
            .on('click', function(d) {
                buttons.classed('active', function(e) { return d === e; });
                change();
            });

        buttonwrap.append('button')
            .on('click', function() {
                buttons.classed('active', false);
                change();
            })
            .append('span')
                .attr('class', 'icon remove');
    }

    function change() {
        var t = {};
        if (field.key) t[field.key] = null;
        buttons.each(function(d) {
            var active = d3.select(this).classed('active');
            if (field.key) {
                if (active) t[field.key] = d;
            } else {
                t[d] = active ? 'yes' : '';
            }
        });
        event.change(t);
    }

    radio.tags = function(tags) {
        buttons.classed('active', function(d) {
            if (field.key) {
                return tags[field.key] === d;
            } else {
                return tags[d] && tags[d] !== 'no';
            }
        });
    };

    return d3.rebind(radio, event, 'on');
};
iD.ui.preset.textarea = function(field) {

    var event = d3.dispatch('change', 'close'),
        input;

    function i(selection) {
        input = selection.append('textarea')
            .attr('id', 'preset-input-' + field.id)
            .attr('placeholder', field.placeholder || '')
            .attr('maxlength', 255)
            .on('blur', change)
            .on('change', change)
            .call(iD.behavior.accept().on('accept', event.close));
    }

    function change() {
        var t = {};
        t[field.key] = input.text();
        event.change(t);
    }

    i.tags = function(tags) {
        input.text(tags[field.key] || '');
    };

    return d3.rebind(i, event, 'on');
};
iD.presets = function(context) {

    // an iD.presets.Collection with methods for
    // loading new data and returning defaults

    var other = iD.presets.Preset('other', {
            tags: {},
            geometry: ['point', 'vertex', 'line', 'area']
        }),
        otherarea = iD.presets.Preset('other/area', {
            tags: { area: 'yes' },
            geometry: ['area']
        }),
        all = iD.presets.Collection([other, otherarea]),
        defaults = { area: all, line: all, point: all, vertex: all },
        fields = {},
        universal = [],
        recent = iD.presets.Collection([]);

    all.load = function(d) {

        if (d.fields) {
            _.forEach(d.fields, function(d, id) {
                fields[id] = iD.presets.Field(id, d);
                if (d.universal) universal.push(fields[id]);
            });
        }

        if (d.presets) {
            _.forEach(d.presets, function(d, id) {
                all.collection.push(iD.presets.Preset(id, d, fields));
            });
        }


        if (d.categories) {
            d.categories.forEach(function(d) {
                all.collection.push(iD.presets.Category(d, all));
            });
        }

        if (d.defaults) {
            var getItem = _.bind(all.item, all);
            defaults = {
                area: iD.presets.Collection(d.defaults.area.map(getItem)),
                line: iD.presets.Collection(d.defaults.line.map(getItem)),
                point: iD.presets.Collection(d.defaults.point.map(getItem)),
                vertex: iD.presets.Collection(d.defaults.vertex.map(getItem))
            };
        }

        return all;
    };

    all.field = function(id) {
        return fields[id];
    };

    all.universal = function() {
        return universal;
    };

    all.defaults = function(entity, n) {
        var rec = recent.matchGeometry(entity, context.graph()).collection.slice(0, 4),
            def = _.uniq(rec.concat(defaults[entity.geometry(context.graph())].collection)).slice(0, n - 1);
        return iD.presets.Collection(_.unique(rec.concat(def).concat(other)));
    };

    all.choose = function(preset) {
        if (preset !== other) {
            recent = iD.presets.Collection(_.unique([preset].concat(recent.collection)));
        }
        return all;
    };

    return all;
};
iD.presets.Category = function(category, all) {
    category = _.clone(category);

    category.members = iD.presets.Collection(category.members.map(function(id) {
        return all.item(id);
    }));

    category.matchGeometry = function(entity, resolver) {
        return category.geometry.indexOf(entity.geometry(resolver)) >= 0;
    };

    category.matchTags = function() { return false; };

    category.name = function() {
        return category.id;
    };

    category.terms = function() {
        return [];
    };

    return category;
};
iD.presets.Collection = function(collection) {

    var presets = {

        collection: collection,

        item: function(id) {
            return _.find(collection, function(d) {
                return d.id === id;
            });
        },

        match: function(entity, resolver) {
            return presets.matchGeometry(entity, resolver).matchTags(entity);
        },

        matchGeometry: function(entity, resolver) {
            return iD.presets.Collection(collection.filter(function(d) {
                return d.matchGeometry(entity, resolver);
            }));
        },

        matchTags: function(entity) {

            var best = -1,
                match;

            for (var i = 0; i < collection.length; i++) {
                var score = collection[i].matchTags(entity);
                if (score > best) {
                    best = score;
                    match = collection[i];
                }
            }

            return match;
        },

        search: function(value) {
            if (!value) return this;

            value = value.toLowerCase();

            var searchable = _.filter(collection, function(a) {
                return a.searchable !== false;
            });

            var leading_name = _.filter(searchable, function(a) {
                    return leading(a.name().toLowerCase());
                }).sort(function(a, b) {
                    var i = a.name().toLowerCase().indexOf(value) - b.name().toLowerCase().indexOf(value);
                    if (i === 0) return a.name().length - b.name().length;
                    else return i;
                }),
                leading_terms = _.filter(searchable, function(a) {
                    return _.any(a.terms() || [], leading);
                });

            function leading(a) {
                var index = a.indexOf(value);
                return index === 0 || a[index - 1] === ' ';
            }

            var levenstein_name = searchable.map(function(a) {
                    return {
                        preset: a,
                        dist: iD.util.editDistance(value, a.name().toLowerCase())
                    };
                }).filter(function(a) {
                    return a.dist + Math.min(value.length - a.preset.name().length, 0) < 3;
                }).sort(function(a, b) {
                    return a.dist - b.dist;
                }).map(function(a) {
                    return a.preset;
                }),
                leventstein_terms = _.filter(searchable, function(a) {
                    return _.any(a.terms() || [], function(b) {
                        return iD.util.editDistance(value, b) + Math.min(value.length - b.length, 0) < 3;
                    });
                });

            var other = presets.item('other');

            return iD.presets.Collection(
                _.unique(
                    leading_name.concat(
                        leading_terms,
                        levenstein_name,
                        leventstein_terms,
                        other)));
        }
    };

    return presets;
};
iD.presets.Field = function(id, field) {
    field = _.clone(field);

    field.id = id;

    field.matchGeometry = function(geometry) {
        return !field.geometry || field.geometry.indexOf(geometry) >= 0;
    };

    field.t = function(scope, options) {
        return t('presets.fields.' + id + '.' + scope, options);
    };

    field.label = function() {
        return field.t('label', {'default': id});
    };

    return field;
};
iD.presets.Preset = function(id, preset, fields) {
    preset = _.clone(preset);

    preset.id = id;
    preset.fields = (preset.fields || []).map(getFields);

    function getFields(f) {
        return fields[f];
    }

    preset.matchGeometry = function(entity, resolver) {
        return preset.geometry.indexOf(entity.geometry(resolver)) >= 0;
    };

    preset.matchTags = function(entity) {
        var tags = preset.tags,
            score = 0;
        for (var t in tags) {
            if (entity.tags[t] === tags[t]) {
                if (t === 'area') {
                    // score area tag lower to prevent other/area preset
                    // from being chosen over something more specific
                    score += 0.5;
                } else {
                    score += 1;
                }
            } else if (tags[t] === '*' && t in entity.tags) {
                score += 0.5;
            } else {
                return -1;
            }
        }
        return score;
    };

    preset.t = function(scope, options) {
        return t('presets.presets.' + id + '.' + scope, options);
    };

    preset.name = function() {
        return preset.t('name', {'default': id});
    };

    preset.terms = function() {
        return preset.t('terms', {'default': ''}).split(',');
    };

    preset.removeTags = function(tags, geometry) {
        tags = _.omit(tags, _.keys(preset.tags));

        for (var i in preset.fields) {
            var field = preset.fields[i];
            if (field.matchGeometry(geometry) && field['default'] === tags[field.key]) {
                delete tags[field.key];
            }
        }
        return tags;

    };

    preset.applyTags = function(tags, geometry) {
        for (var k in preset.tags) {
            if (preset.tags[k] !== '*') tags[k] = preset.tags[k];
        }

        for (var f in preset.fields) {
            f = preset.fields[f];
            if (f.matchGeometry(geometry) && f.key && !tags[f.key]) {
                tags[f.key] = f['default'];
            }
        }
        return tags;
    };

    return preset;
};
iD.validate = function(changes, graph) {
    var warnings = [], change;

    // https://github.com/openstreetmap/josm/blob/mirror/src/org/
    // openstreetmap/josm/data/validation/tests/UnclosedWays.java#L80
    function tagSuggestsArea(change) {
        if (_.isEmpty(change.tags)) return false;
        var tags = change.tags;
        var presence = ['landuse', 'amenities', 'tourism', 'shop'];
        for (var i = 0; i < presence.length; i++) {
            if (tags[presence[i]] !== undefined) {
                return presence[i] + '=' + tags[presence[i]];
            }
        }
        if (tags.building && tags.building === 'yes') return 'building=yes';
    }

    if (changes.deleted.length > 100) {
        warnings.push({
            message: t('validations.many_deletions', { n: changes.deleted.length })
        });
    }

    for (var i = 0; i < changes.created.length; i++) {
        change = changes.created[i];

        if (change.geometry(graph) === 'point' && _.isEmpty(change.tags)) {
            warnings.push({
                message: t('validations.untagged_point'),
                entity: change
            });
        }

        if (change.geometry(graph) === 'line' && _.isEmpty(change.tags)) {
            warnings.push({ message: t('validations.untagged_line'), entity: change });
        }

        var deprecatedTags = change.deprecatedTags();
        if (!_.isEmpty(deprecatedTags)) {
            warnings.push({
                message: t('validations.deprecated_tags', {
                    tags: iD.util.tagText({ tags: deprecatedTags })
                }), entity: change });
        }

        if (change.geometry(graph) === 'area' && _.isEmpty(change.tags)) {
            warnings.push({ message: t('validations.untagged_area'), entity: change });
        }

        if (change.geometry(graph) === 'line' && tagSuggestsArea(change)) {
            warnings.push({
                message: t('validations.tag_suggests_area', {tag: tagSuggestsArea(change)}),
                entity: change
            });
        }
    }

    return warnings.length ? [warnings] : [];
};
})();
window.locale = { _current: 'en' };

locale.current = function(_) {
    if (!arguments.length) return locale._current;
    if (locale[_] !== undefined) locale._current = _;
    else if (locale[_.split('-')[0]]) locale._current = _.split('-')[0];
    return locale;
};

function t(s, o, loc) {
    loc = loc || locale._current;

    var path = s.split(".").reverse(),
        rep = locale[loc];

    while (rep !== undefined && path.length) rep = rep[path.pop()];

    if (rep !== undefined) {
        if (o) for (var k in o) rep = rep.replace('{' + k + '}', o[k]);
        return rep;
    } else if (o && 'default' in o) {
        return o.default;
    } else {
        var missing = 'Missing translation: ' + s;
        if (console) console.error(missing);
        if (loc !== 'en') return t(s, o, 'en');
        return missing;
    }
}
locale.en = {
    "modes": {
        "add_area": {
            "title": "Area",
            "description": "Add parks, buildings, lakes or other areas to the map.",
            "tail": "Click on the map to start drawing an area, like a park, lake, or building."
        },
        "add_line": {
            "title": "Line",
            "description": "Add highways, streets, pedestrian paths, canals or other lines to the map.",
            "tail": "Click on the map to start drawing a road, path, or route."
        },
        "add_point": {
            "title": "Point",
            "description": "Add restaurants, monuments, postal boxes or other points to the map.",
            "tail": "Click on the map to add a point."
        },
        "browse": {
            "title": "Browse",
            "description": "Pan and zoom the map."
        },
        "draw_area": {
            "tail": "Click to add points to your area. Click the first point to finish the area."
        },
        "draw_line": {
            "tail": "Click to add more points to the line. Click on other lines to connect to them, and double-click to end the line."
        }
    },
    "operations": {
        "add": {
            "annotation": {
                "point": "Added a point.",
                "vertex": "Added a node to a way."
            }
        },
        "start": {
            "annotation": {
                "line": "Started a line.",
                "area": "Started an area."
            }
        },
        "continue": {
            "annotation": {
                "line": "Continued a line.",
                "area": "Continued an area."
            }
        },
        "cancel_draw": {
            "annotation": "Canceled drawing."
        },
        "change_tags": {
            "annotation": "Changed tags."
        },
        "circularize": {
            "title": "Circularize",
            "description": "Make this round.",
            "key": "O",
            "annotation": {
                "line": "Made a line circular.",
                "area": "Made an area circular."
            }
        },
        "orthogonalize": {
            "title": "Orthogonalize",
            "description": "Square these corners.",
            "key": "Q",
            "annotation": {
                "line": "Squared the corners of a line.",
                "area": "Squared the corners of an area."
            }
        },
        "delete": {
            "title": "Delete",
            "description": "Remove this from the map.",
            "annotation": {
                "point": "Deleted a point.",
                "vertex": "Deleted a node from a way.",
                "line": "Deleted a line.",
                "area": "Deleted an area.",
                "relation": "Deleted a relation.",
                "multiple": "Deleted {n} objects."
            }
        },
        "connect": {
            "annotation": {
                "point": "Connected a way to a point.",
                "vertex": "Connected a way to another.",
                "line": "Connected a way to a line.",
                "area": "Connected a way to an area."
            }
        },
        "disconnect": {
            "title": "Disconnect",
            "description": "Disconnect these ways from each other.",
            "key": "D",
            "annotation": "Disconnected ways."
        },
        "merge": {
            "title": "Merge",
            "description": "Merge these lines.",
            "key": "C",
            "annotation": "Merged {n} lines."
        },
        "move": {
            "title": "Move",
            "description": "Move this to a different location.",
            "key": "M",
            "annotation": {
                "point": "Moved a point.",
                "vertex": "Moved a node in a way.",
                "line": "Moved a line.",
                "area": "Moved an area.",
                "multiple": "Moved multiple objects."
            }
        },
        "rotate": {
            "title": "Rotate",
            "description": "Rotate this object around its centre point.",
            "key": "R",
            "annotation": {
                "line": "Rotated a line.",
                "area": "Rotated an area."
            }
        },
        "reverse": {
            "title": "Reverse",
            "description": "Make this line go in the opposite direction.",
            "key": "V",
            "annotation": "Reversed a line."
        },
        "split": {
            "title": "Split",
            "description": "Split this into two ways at this point.",
            "key": "X",
            "annotation": "Split a way."
        }
    },
    "nothing_to_undo": "Nothing to undo.",
    "nothing_to_redo": "Nothing to redo.",
    "just_edited": "You just edited OpenStreetMap!",
    "browser_notice": "This editor is supported in Firefox, Chrome, Safari, Opera, and Internet Explorer 9 and above. Please upgrade your browser or use Potlatch 2 to edit the map.",
    "view_on_osm": "View on OSM →",
    "zoom_in_edit": "zoom in to edit the map",
    "logout": "logout",
    "report_a_bug": "report a bug",
    "commit": {
        "title": "Save Changes",
        "description_placeholder": "Brief description of your contributions",
        "message_label": "Commit message",
        "upload_explanation": "The changes you upload as {user} will be visible on all maps that use OpenStreetMap data.",
        "save": "Save",
        "cancel": "Cancel",
        "warnings": "Warnings",
        "modified": "Modified",
        "deleted": "Deleted",
        "created": "Created"
    },
    "contributors": {
        "list": "Contributed by {users}",
        "truncated_list": "Contributed by {users} and {count} others"
    },
    "geocoder": {
        "title": "Find a place",
        "placeholder": "Find a place",
        "no_results": "Couldn't locate a place named '{name}'"
    },
    "geolocate": {
        "title": "Show My Location"
    },
    "inspector": {
        "no_documentation_combination": "There is no documentation available for this tag combination",
        "no_documentation_key": "There is no documentation available for this key",
        "show_more": "Show More",
        "new_tag": "New tag",
        "view_on_osm": "View on OSM",
        "editing_feature": "Editing {feature}",
        "additional": "Additional tags",
        "choose": "Select feature type",
        "results": "{n} results for {search}",
        "reference": "View on OpenStreetMap Wiki →",
        "back_tooltip": "Change feature type"
    },
    "background": {
        "title": "Background",
        "description": "Background settings",
        "percent_brightness": "{opacity}% brightness",
        "fix_misalignment": "Fix misalignment",
        "reset": "reset"
    },
    "restore": {
        "heading": "You have unsaved changes",
        "description": "Do you wish to restore changes from a previous editing session?",
        "restore": "Restore",
        "reset": "Reset"
    },
    "save": {
        "title": "Save",
        "help": "Save changes to OpenStreetMap, making them visible to other users.",
        "no_changes": "No changes to save.",
        "error": "An error occurred while trying to save",
        "uploading": "Uploading changes to OpenStreetMap.",
        "unsaved_changes": "You have unsaved changes"
    },
    "splash": {
        "welcome": "Welcome to the iD OpenStreetMap editor",
        "text": "This is development version {version}. For more information see {website} and report bugs at {github}."
    },
    "source_switch": {
        "live": "live",
        "lose_changes": "You have unsaved changes. Switching the map server will discard them. Are you sure you want to switch servers?",
        "dev": "dev"
    },
    "tag_reference": {
        "description": "Description",
        "on_wiki": "{tag} on wiki.osm.org",
        "used_with": "used with {type}"
    },
    "validations": {
        "untagged_point": "Untagged point which is not part of a line or area",
        "untagged_line": "Untagged line",
        "untagged_area": "Untagged area",
        "many_deletions": "You're deleting {n} objects. Are you sure you want to do this? This will delete them from the map that everyone else sees on openfloorplan.org.",
        "tag_suggests_area": "The tag {tag} suggests line should be area, but it is not an area",
        "deprecated_tags": "Deprecated tags: {tags}"
    },
    "zoom": {
        "in": "Zoom In",
        "out": "Zoom Out"
    },
    "gpx": {
        "local_layer": "Local GPX file",
        "drag_drop": "Drag and drop a .gpx file on the page"
    },
    "help": {
        "title": "Help"
    },
    "presets": {
        "fields": {
            "access": {
                "label": "Access"
            },
            "address": {
                "label": "Address",
                "placeholders": {
                    "housename": "Housename",
                    "number": "123",
                    "street": "Street",
                    "city": "City"
                }
            },
            "aeroway": {
                "label": "Type"
            },
            "amenity": {
                "label": "Type"
            },
            "atm": {
                "label": "ATM"
            },
            "barrier": {
                "label": "Type"
            },
            "bicycle_parking": {
                "label": "Type"
            },
            "building": {
                "label": "Building"
            },
            "building_area": {
                "label": "Building"
            },
            "building_yes": {
                "label": "Building"
            },
            "capacity": {
                "label": "Capacity"
            },
            "collection_times": {
                "label": "Collection Times"
            },
            "construction": {
                "label": "Type"
            },
            "country": {
                "label": "Country"
            },
            "crossing": {
                "label": "Type"
            },
            "cuisine": {
                "label": "Cuisine"
            },
            "denomination": {
                "label": "Denomination"
            },
            "denotation": {
                "label": "Denotation"
            },
            "elevation": {
                "label": "Elevation"
            },
            "emergency": {
                "label": "Emergency"
            },
            "entrance": {
                "label": "Type"
            },
            "fax": {
                "label": "Fax"
            },
            "fee": {
                "label": "Fee"
            },
            "highway": {
                "label": "Type"
            },
            "historic": {
                "label": "Type"
            },
            "internet_access": {
                "label": "Internet Access",
                "options": {
                    "yes": "Yes",
                    "no": "No",
                    "wlan": "Wifi",
                    "wired": "Wired",
                    "terminal": "Terminal"
                }
            },
            "landuse": {
                "label": "Type"
            },
            "layer": {
                "label": "Layer"
            },
            "leisure": {
                "label": "Type"
            },
            "levels": {
                "label": "Levels"
            },
            "man_made": {
                "label": "Type"
            },
            "maxspeed": {
                "label": "Speed Limit"
            },
            "name": {
                "label": "Name"
            },
            "natural": {
                "label": "Natural"
            },
            "network": {
                "label": "Network"
            },
            "note": {
                "label": "Note"
            },
            "office": {
                "label": "Type"
            },
            "oneway": {
                "label": "One Way"
            },
            "oneway_yes": {
                "label": "One Way"
            },
            "opening_hours": {
                "label": "Hours"
            },
            "operator": {
                "label": "Operator"
            },
            "phone": {
                "label": "Phone"
            },
            "place": {
                "label": "Type"
            },
            "power": {
                "label": "Type"
            },
            "railway": {
                "label": "Type"
            },
            "ref": {
                "label": "Reference"
            },
            "religion": {
                "label": "Religion",
                "options": {
                    "christian": "Christian",
                    "muslim": "Muslim",
                    "buddhist": "Buddhist",
                    "jewish": "Jewish",
                    "hindu": "Hindu",
                    "shinto": "Shinto",
                    "taoist": "Taoist"
                }
            },
            "service": {
                "label": "Type"
            },
            "shelter": {
                "label": "Shelter"
            },
            "shop": {
                "label": "Type"
            },
            "source": {
                "label": "Source"
            },
            "sport": {
                "label": "Sport"
            },
            "structure": {
                "label": "Structure",
                "options": {
                    "bridge": "Bridge",
                    "tunnel": "Tunnel",
                    "embankment": "Embankment",
                    "cutting": "Cutting"
                }
            },
            "surface": {
                "label": "Surface"
            },
            "tourism": {
                "label": "Type"
            },
            "water": {
                "label": "Type"
            },
            "waterway": {
                "label": "Type"
            },
            "website": {
                "label": "Website"
            },
            "wetland": {
                "label": "Type"
            },
            "wheelchair": {
                "label": "Wheelchair Access"
            },
            "wikipedia": {
                "label": "Wikipedia"
            },
            "wood": {
                "label": "Type"
            }
        },
        "presets": {
            "aeroway": {
                "name": "Aeroway",
                "terms": ""
            },
            "aeroway/aerodrome": {
                "name": "Airport",
                "terms": "airplane,airport,aerodrome"
            },
            "aeroway/helipad": {
                "name": "Helipad",
                "terms": "helicopter,helipad,heliport"
            },
            "amenity": {
                "name": "Amenity",
                "terms": ""
            },
            "amenity/bank": {
                "name": "Bank",
                "terms": "coffer,countinghouse,credit union,depository,exchequer,fund,hoard,investment firm,repository,reserve,reservoir,safe,savings,stock,stockpile,store,storehouse,thrift,treasury,trust company,vault"
            },
            "amenity/bar": {
                "name": "Bar",
                "terms": ""
            },
            "amenity/bench": {
                "name": "Bench",
                "terms": ""
            },
            "amenity/bicycle_parking": {
                "name": "Bicycle Parking",
                "terms": ""
            },
            "amenity/bicycle_rental": {
                "name": "Bicycle Rental",
                "terms": ""
            },
            "amenity/cafe": {
                "name": "Cafe",
                "terms": "coffee,tea,coffee shop"
            },
            "amenity/cinema": {
                "name": "Cinema",
                "terms": "big screen,bijou,cine,drive-in,film,flicks,motion pictures,movie house,movie theater,moving pictures,nabes,photoplay,picture show,pictures,playhouse,show,silver screen"
            },
            "amenity/courthouse": {
                "name": "Courthouse",
                "terms": ""
            },
            "amenity/embassy": {
                "name": "Embassy",
                "terms": ""
            },
            "amenity/fast_food": {
                "name": "Fast Food",
                "terms": ""
            },
            "amenity/fire_station": {
                "name": "Fire Station",
                "terms": ""
            },
            "amenity/fuel": {
                "name": "Gas Station",
                "terms": ""
            },
            "amenity/grave_yard": {
                "name": "Graveyard",
                "terms": ""
            },
            "amenity/hospital": {
                "name": "Hospital",
                "terms": "clinic,emergency room,health service,hospice,infirmary,institution,nursing home,rest home,sanatorium,sanitarium,sick bay,surgery,ward"
            },
            "amenity/library": {
                "name": "Library",
                "terms": ""
            },
            "amenity/marketplace": {
                "name": "Marketplace",
                "terms": ""
            },
            "amenity/parking": {
                "name": "Parking",
                "terms": ""
            },
            "amenity/pharmacy": {
                "name": "Pharmacy",
                "terms": ""
            },
            "amenity/place_of_worship": {
                "name": "Place of Worship",
                "terms": "abbey,basilica,bethel,cathedral,chancel,chantry,chapel,church,fold,house of God,house of prayer,house of worship,minster,mission,mosque,oratory,parish,sacellum,sanctuary,shrine,synagogue,tabernacle,temple"
            },
            "amenity/place_of_worship/christian": {
                "name": "Church",
                "terms": "christian,abbey,basilica,bethel,cathedral,chancel,chantry,chapel,church,fold,house of God,house of prayer,house of worship,minster,mission,oratory,parish,sacellum,sanctuary,shrine,tabernacle,temple"
            },
            "amenity/place_of_worship/jewish": {
                "name": "Synagogue",
                "terms": "jewish,synagogue"
            },
            "amenity/place_of_worship/muslim": {
                "name": "Mosque",
                "terms": "muslim,mosque"
            },
            "amenity/police": {
                "name": "Police",
                "terms": "badge,bear,blue,bluecoat,bobby,boy scout,bull,constable,constabulary,cop,copper,corps,county mounty,detective,fed,flatfoot,force,fuzz,gendarme,gumshoe,heat,law,law enforcement,man,narc,officers,patrolman,police"
            },
            "amenity/post_box": {
                "name": "Mailbox",
                "terms": "letter drop,letterbox,mail drop,mailbox,pillar box,postbox"
            },
            "amenity/post_office": {
                "name": "Post Office",
                "terms": ""
            },
            "amenity/pub": {
                "name": "Pub",
                "terms": ""
            },
            "amenity/restaurant": {
                "name": "Restaurant",
                "terms": "bar,cafeteria,café,canteen,chophouse,coffee shop,diner,dining room,dive*,doughtnut shop,drive-in,eatery,eating house,eating place,fast-food place,greasy spoon,grill,hamburger stand,hashery,hideaway,hotdog stand,inn,joint*,luncheonette,lunchroom,night club,outlet*,pizzeria,saloon,soda fountain,watering hole"
            },
            "amenity/school": {
                "name": "School",
                "terms": "academy,alma mater,blackboard,college,department,discipline,establishment,faculty,hall,halls of ivy,institute,institution,jail*,schoolhouse,seminary,university"
            },
            "amenity/swimming_pool": {
                "name": "Swimming Pool",
                "terms": ""
            },
            "amenity/telephone": {
                "name": "Telephone",
                "terms": ""
            },
            "amenity/theatre": {
                "name": "Theater",
                "terms": "theatre,performance,play,musical"
            },
            "amenity/toilets": {
                "name": "Toilets",
                "terms": ""
            },
            "amenity/townhall": {
                "name": "Town Hall",
                "terms": "village hall,city government,courthouse,municipal building,municipal center"
            },
            "amenity/university": {
                "name": "University",
                "terms": ""
            },
            "barrier": {
                "name": "Barrier",
                "terms": ""
            },
            "barrier/block": {
                "name": "Block",
                "terms": ""
            },
            "barrier/bollard": {
                "name": "Bollard",
                "terms": ""
            },
            "barrier/cattle_grid": {
                "name": "Cattle Grid",
                "terms": ""
            },
            "barrier/city_wall": {
                "name": "City Wall",
                "terms": ""
            },
            "barrier/cycle_barrier": {
                "name": "Cycle Barrier",
                "terms": ""
            },
            "barrier/ditch": {
                "name": "Ditch",
                "terms": ""
            },
            "barrier/entrance": {
                "name": "Entrance",
                "terms": ""
            },
            "barrier/fence": {
                "name": "Fence",
                "terms": ""
            },
            "barrier/gate": {
                "name": "Gate",
                "terms": ""
            },
            "barrier/hedge": {
                "name": "Hedge",
                "terms": ""
            },
            "barrier/kissing_gate": {
                "name": "Kissing Gate",
                "terms": ""
            },
            "barrier/lift_gate": {
                "name": "Lift Gate",
                "terms": ""
            },
            "barrier/retaining_wall": {
                "name": "Retaining Wall",
                "terms": ""
            },
            "barrier/stile": {
                "name": "Stile",
                "terms": ""
            },
            "barrier/toll_booth": {
                "name": "Toll Booth",
                "terms": ""
            },
            "barrier/wall": {
                "name": "Wall",
                "terms": ""
            },
            "building": {
                "name": "Building",
                "terms": ""
            },
            "building/entrance": {
                "name": "Entrance",
                "terms": ""
            },
            "entrance": {
                "name": "Entrance",
                "terms": ""
            },
            "highway": {
                "name": "Highway",
                "terms": ""
            },
            "highway/bridleway": {
                "name": "Bridle Path",
                "terms": "bridleway,equestrian trail,horse riding path,bridle road,horse trail"
            },
            "highway/bus_stop": {
                "name": "Bus Stop",
                "terms": ""
            },
            "highway/crossing": {
                "name": "Crossing",
                "terms": "crosswalk,zebra crossing"
            },
            "highway/cycleway": {
                "name": "Cycle Path",
                "terms": ""
            },
            "highway/footway": {
                "name": "Foot Path",
                "terms": "beaten path,boulevard,clearing,course,cut*,drag*,footpath,highway,lane,line,orbit,passage,pathway,rail,rails,road,roadway,route,street,thoroughfare,trackway,trail,trajectory,walk"
            },
            "highway/motorway": {
                "name": "Motorway",
                "terms": ""
            },
            "highway/motorway_link": {
                "name": "Motorway Link",
                "terms": "ramp,on ramp,off ramp"
            },
            "highway/path": {
                "name": "Path",
                "terms": ""
            },
            "highway/primary": {
                "name": "Primary Road",
                "terms": ""
            },
            "highway/primary_link": {
                "name": "Primary Link",
                "terms": "ramp,on ramp,off ramp"
            },
            "highway/residential": {
                "name": "Residential Road",
                "terms": ""
            },
            "highway/road": {
                "name": "Unknown Road",
                "terms": ""
            },
            "highway/secondary": {
                "name": "Secondary Road",
                "terms": ""
            },
            "highway/secondary_link": {
                "name": "Secondary Link",
                "terms": "ramp,on ramp,off ramp"
            },
            "highway/service": {
                "name": "Service Road",
                "terms": ""
            },
            "highway/steps": {
                "name": "Steps",
                "terms": "stairs,staircase"
            },
            "highway/tertiary": {
                "name": "Tertiary Road",
                "terms": ""
            },
            "highway/tertiary_link": {
                "name": "Tertiary Link",
                "terms": "ramp,on ramp,off ramp"
            },
            "highway/track": {
                "name": "Track",
                "terms": ""
            },
            "highway/traffic_signals": {
                "name": "Traffic Signals",
                "terms": "light,stoplight,traffic light"
            },
            "highway/trunk": {
                "name": "Trunk Road",
                "terms": ""
            },
            "highway/trunk_link": {
                "name": "Trunk Link",
                "terms": "ramp,on ramp,off ramp"
            },
            "highway/turning_circle": {
                "name": "Turning Circle",
                "terms": ""
            },
            "highway/unclassified": {
                "name": "Unclassified Road",
                "terms": ""
            },
            "historic": {
                "name": "Historic Site",
                "terms": ""
            },
            "historic/archaeological_site": {
                "name": "Archaeological Site",
                "terms": ""
            },
            "historic/boundary_stone": {
                "name": "Boundary Stone",
                "terms": ""
            },
            "historic/castle": {
                "name": "Castle",
                "terms": ""
            },
            "historic/memorial": {
                "name": "Memorial",
                "terms": ""
            },
            "historic/monument": {
                "name": "Monument",
                "terms": ""
            },
            "historic/ruins": {
                "name": "Ruins",
                "terms": ""
            },
            "historic/wayside_cross": {
                "name": "Wayside Cross",
                "terms": ""
            },
            "historic/wayside_shrine": {
                "name": "Wayside Shrine",
                "terms": ""
            },
            "landuse": {
                "name": "Landuse",
                "terms": ""
            },
            "landuse/allotments": {
                "name": "Allotments",
                "terms": ""
            },
            "landuse/basin": {
                "name": "Basin",
                "terms": ""
            },
            "landuse/cemetery": {
                "name": "Cemetery",
                "terms": ""
            },
            "landuse/commercial": {
                "name": "Commercial",
                "terms": ""
            },
            "landuse/construction": {
                "name": "Construction",
                "terms": ""
            },
            "landuse/farm": {
                "name": "Farm",
                "terms": ""
            },
            "landuse/farmyard": {
                "name": "Farmyard",
                "terms": ""
            },
            "landuse/forest": {
                "name": "Forest",
                "terms": ""
            },
            "landuse/grass": {
                "name": "Grass",
                "terms": ""
            },
            "landuse/industrial": {
                "name": "Industrial",
                "terms": ""
            },
            "landuse/meadow": {
                "name": "Meadow",
                "terms": ""
            },
            "landuse/orchard": {
                "name": "Orchard",
                "terms": ""
            },
            "landuse/quarry": {
                "name": "Quarry",
                "terms": ""
            },
            "landuse/residential": {
                "name": "Residential",
                "terms": ""
            },
            "landuse/vineyard": {
                "name": "Vineyard",
                "terms": ""
            },
            "leisure": {
                "name": "Leisure",
                "terms": ""
            },
            "leisure/garden": {
                "name": "Garden",
                "terms": ""
            },
            "leisure/golf_course": {
                "name": "Golf Course",
                "terms": ""
            },
            "leisure/marina": {
                "name": "Marina",
                "terms": ""
            },
            "leisure/park": {
                "name": "Park",
                "terms": "esplanade,estate,forest,garden,grass,green,grounds,lawn,lot,meadow,parkland,place,playground,plaza,pleasure garden,recreation area,square,tract,village green,woodland"
            },
            "leisure/pitch": {
                "name": "Sport Pitch",
                "terms": ""
            },
            "leisure/pitch/american_football": {
                "name": "American Football Field",
                "terms": ""
            },
            "leisure/pitch/baseball": {
                "name": "Baseball Diamond",
                "terms": ""
            },
            "leisure/pitch/basketball": {
                "name": "Basketball Court",
                "terms": ""
            },
            "leisure/pitch/soccer": {
                "name": "Soccer Field",
                "terms": ""
            },
            "leisure/pitch/tennis": {
                "name": "Tennis Court",
                "terms": ""
            },
            "leisure/playground": {
                "name": "Playground",
                "terms": ""
            },
            "leisure/slipway": {
                "name": "Slipway",
                "terms": ""
            },
            "leisure/stadium": {
                "name": "Stadium",
                "terms": ""
            },
            "leisure/swimming_pool": {
                "name": "Swimming Pool",
                "terms": ""
            },
            "man_made": {
                "name": "Man Made",
                "terms": ""
            },
            "man_made/lighthouse": {
                "name": "Lighthouse",
                "terms": ""
            },
            "man_made/pier": {
                "name": "Pier",
                "terms": ""
            },
            "man_made/survey_point": {
                "name": "Survey Point",
                "terms": ""
            },
            "man_made/water_tower": {
                "name": "Water Tower",
                "terms": ""
            },
            "natural": {
                "name": "Natural",
                "terms": ""
            },
            "natural/bay": {
                "name": "Bay",
                "terms": ""
            },
            "natural/beach": {
                "name": "Beach",
                "terms": ""
            },
            "natural/cliff": {
                "name": "Cliff",
                "terms": ""
            },
            "natural/coastline": {
                "name": "Coastline",
                "terms": "shore"
            },
            "natural/glacier": {
                "name": "Glacier",
                "terms": ""
            },
            "natural/grassland": {
                "name": "Grassland",
                "terms": ""
            },
            "natural/heath": {
                "name": "Heath",
                "terms": ""
            },
            "natural/peak": {
                "name": "Peak",
                "terms": "acme,aiguille,alp,climax,crest,crown,hill,mount,mountain,pinnacle,summit,tip,top"
            },
            "natural/scrub": {
                "name": "Scrub",
                "terms": ""
            },
            "natural/spring": {
                "name": "Spring",
                "terms": ""
            },
            "natural/tree": {
                "name": "Tree",
                "terms": ""
            },
            "natural/water": {
                "name": "Water",
                "terms": ""
            },
            "natural/water/lake": {
                "name": "Lake",
                "terms": "lakelet,loch,mere"
            },
            "natural/water/pond": {
                "name": "Pond",
                "terms": "lakelet,millpond,tarn,pool,mere"
            },
            "natural/water/reservoir": {
                "name": "Reservoir",
                "terms": ""
            },
            "natural/wetland": {
                "name": "Wetland",
                "terms": ""
            },
            "natural/wood": {
                "name": "Wood",
                "terms": ""
            },
            "office": {
                "name": "Office",
                "terms": ""
            },
            "place": {
                "name": "Place",
                "terms": ""
            },
            "place/hamlet": {
                "name": "Hamlet",
                "terms": ""
            },
            "place/island": {
                "name": "Island",
                "terms": "archipelago,atoll,bar,cay,isle,islet,key,reef"
            },
            "place/locality": {
                "name": "Locality",
                "terms": ""
            },
            "place/village": {
                "name": "Village",
                "terms": ""
            },
            "power": {
                "name": "Power",
                "terms": ""
            },
            "power/generator": {
                "name": "Power Plant",
                "terms": ""
            },
            "power/line": {
                "name": "Power Line",
                "terms": ""
            },
            "power/pole": {
                "name": "Power Pole",
                "terms": ""
            },
            "power/sub_station": {
                "name": "Substation",
                "terms": ""
            },
            "power/tower": {
                "name": "High-Voltage Tower",
                "terms": ""
            },
            "power/transformer": {
                "name": "Transformer",
                "terms": ""
            },
            "railway": {
                "name": "Railway",
                "terms": ""
            },
            "railway/abandoned": {
                "name": "Abandoned Railway",
                "terms": ""
            },
            "railway/disused": {
                "name": "Disused Railway",
                "terms": ""
            },
            "railway/level_crossing": {
                "name": "Level Crossing",
                "terms": "crossing,railroad crossing,railway crossing,grade crossing,road through railroad,train crossing"
            },
            "railway/monorail": {
                "name": "Monorail",
                "terms": ""
            },
            "railway/rail": {
                "name": "Rail",
                "terms": ""
            },
            "railway/subway": {
                "name": "Subway",
                "terms": ""
            },
            "railway/subway_entrance": {
                "name": "Subway Entrance",
                "terms": ""
            },
            "railway/tram": {
                "name": "Tram",
                "terms": "streetcar"
            },
            "shop": {
                "name": "Shop",
                "terms": ""
            },
            "shop/alcohol": {
                "name": "Liquor Store",
                "terms": ""
            },
            "shop/bakery": {
                "name": "Bakery",
                "terms": ""
            },
            "shop/beauty": {
                "name": "Beauty Shop",
                "terms": ""
            },
            "shop/beverages": {
                "name": "Beverage Store",
                "terms": ""
            },
            "shop/bicycle": {
                "name": "Bicycle Shop",
                "terms": ""
            },
            "shop/books": {
                "name": "Bookstore",
                "terms": ""
            },
            "shop/boutique": {
                "name": "Boutique",
                "terms": ""
            },
            "shop/butcher": {
                "name": "Butcher",
                "terms": ""
            },
            "shop/car": {
                "name": "Car Dealership",
                "terms": ""
            },
            "shop/car_parts": {
                "name": "Car Parts Store",
                "terms": ""
            },
            "shop/car_repair": {
                "name": "Car Repair Shop",
                "terms": ""
            },
            "shop/chemist": {
                "name": "Chemist",
                "terms": ""
            },
            "shop/clothes": {
                "name": "Clothing Store",
                "terms": ""
            },
            "shop/computer": {
                "name": "Computer Store",
                "terms": ""
            },
            "shop/confectionery": {
                "name": "Confectionery",
                "terms": ""
            },
            "shop/convenience": {
                "name": "Convenience Store",
                "terms": ""
            },
            "shop/deli": {
                "name": "Deli",
                "terms": ""
            },
            "shop/department_store": {
                "name": "Department Store",
                "terms": ""
            },
            "shop/doityourself": {
                "name": "DIY Store",
                "terms": ""
            },
            "shop/dry_cleaning": {
                "name": "Dry Cleaners",
                "terms": ""
            },
            "shop/electronics": {
                "name": "Electronics Store",
                "terms": ""
            },
            "shop/fishmonger": {
                "name": "Fishmonger",
                "terms": ""
            },
            "shop/florist": {
                "name": "Florist",
                "terms": ""
            },
            "shop/furniture": {
                "name": "Furniture Store",
                "terms": ""
            },
            "shop/garden_centre": {
                "name": "Garden Center",
                "terms": ""
            },
            "shop/gift": {
                "name": "Gift Shop",
                "terms": ""
            },
            "shop/greengrocer": {
                "name": "Greengrocer",
                "terms": ""
            },
            "shop/hairdresser": {
                "name": "Hairdresser",
                "terms": ""
            },
            "shop/hardware": {
                "name": "Hardware Store",
                "terms": ""
            },
            "shop/hifi": {
                "name": "Hifi Store",
                "terms": ""
            },
            "shop/jewelry": {
                "name": "Jeweler",
                "terms": ""
            },
            "shop/kiosk": {
                "name": "Kiosk",
                "terms": ""
            },
            "shop/laundry": {
                "name": "Laundry",
                "terms": ""
            },
            "shop/mall": {
                "name": "Mall",
                "terms": ""
            },
            "shop/mobile_phone": {
                "name": "Mobile Phone Store",
                "terms": ""
            },
            "shop/motorcycle": {
                "name": "Motorcycle Dealership",
                "terms": ""
            },
            "shop/music": {
                "name": "Music Store",
                "terms": ""
            },
            "shop/newsagent": {
                "name": "Newsagent",
                "terms": ""
            },
            "shop/optician": {
                "name": "Optician",
                "terms": ""
            },
            "shop/outdoor": {
                "name": "Outdoor Store",
                "terms": ""
            },
            "shop/pet": {
                "name": "Pet Store",
                "terms": ""
            },
            "shop/shoes": {
                "name": "Shoe Store",
                "terms": ""
            },
            "shop/sports": {
                "name": "Sporting Goods Store",
                "terms": ""
            },
            "shop/stationery": {
                "name": "Stationery Store",
                "terms": ""
            },
            "shop/supermarket": {
                "name": "Supermarket",
                "terms": "bazaar,boutique,chain,co-op,cut-rate store,discount store,five-and-dime,flea market,galleria,mall,mart,outlet,outlet store,shop,shopping center,shopping plaza,stand,store,supermarket,thrift shop"
            },
            "shop/toys": {
                "name": "Toy Store",
                "terms": ""
            },
            "shop/travel_agency": {
                "name": "Travel Agency",
                "terms": ""
            },
            "shop/tyres": {
                "name": "Tire Store",
                "terms": ""
            },
            "shop/vacant": {
                "name": "Vacant Shop",
                "terms": ""
            },
            "shop/variety_store": {
                "name": "Variety Store",
                "terms": ""
            },
            "shop/video": {
                "name": "Video Store",
                "terms": ""
            },
            "tourism": {
                "name": "Tourism",
                "terms": ""
            },
            "tourism/alpine_hut": {
                "name": "Alpine Hut",
                "terms": ""
            },
            "tourism/artwork": {
                "name": "Artwork",
                "terms": ""
            },
            "tourism/attraction": {
                "name": "Tourist Attraction",
                "terms": ""
            },
            "tourism/camp_site": {
                "name": "Camp Site",
                "terms": ""
            },
            "tourism/caravan_site": {
                "name": "RV Park",
                "terms": ""
            },
            "tourism/chalet": {
                "name": "Chalet",
                "terms": ""
            },
            "tourism/guest_house": {
                "name": "Guest House",
                "terms": "B&B,Bed & Breakfast,Bed and Breakfast"
            },
            "tourism/hostel": {
                "name": "Hostel",
                "terms": ""
            },
            "tourism/hotel": {
                "name": "Hotel",
                "terms": ""
            },
            "tourism/information": {
                "name": "Information",
                "terms": ""
            },
            "tourism/motel": {
                "name": "Motel",
                "terms": ""
            },
            "tourism/museum": {
                "name": "Museum",
                "terms": "exhibition,exhibits archive,foundation,gallery,hall,institution,library,menagerie,repository,salon,storehouse,treasury,vault"
            },
            "tourism/picnic_site": {
                "name": "Picnic Site",
                "terms": ""
            },
            "tourism/theme_park": {
                "name": "Theme Park",
                "terms": ""
            },
            "tourism/viewpoint": {
                "name": "Viewpoint",
                "terms": ""
            },
            "tourism/zoo": {
                "name": "Zoo",
                "terms": ""
            },
            "waterway": {
                "name": "Waterway",
                "terms": ""
            },
            "waterway/canal": {
                "name": "Canal",
                "terms": ""
            },
            "waterway/dam": {
                "name": "Dam",
                "terms": ""
            },
            "waterway/ditch": {
                "name": "Ditch",
                "terms": ""
            },
            "waterway/drain": {
                "name": "Drain",
                "terms": ""
            },
            "waterway/river": {
                "name": "River",
                "terms": "beck,branch,brook,course,creek,estuary,rill,rivulet,run,runnel,stream,tributary,watercourse"
            },
            "waterway/riverbank": {
                "name": "Riverbank",
                "terms": ""
            },
            "waterway/stream": {
                "name": "Stream",
                "terms": "beck,branch,brook,burn,course,creek,current,drift,flood,flow,freshet,race,rill,rindle,rivulet,run,runnel,rush,spate,spritz,surge,tide,torrent,tributary,watercourse"
            },
            "waterway/weir": {
                "name": "Weir",
                "terms": ""
            }
        }
    }
};
locale.zh = {
    "modes": {
        "add_area": {
            "title": "面",
            "description": "在地图上添加公园，建筑物，湖泊或其他面状区域。",
            "tail": "在地图上点击开始绘制一个区域，像一个公园，湖边，或建筑物。"
        },
        "add_line": {
            "title": "线",
            "description": "在地图上添加公路，街道，行人路，运河或其他线路。",
            "tail": "在地图上点击开始绘制道路，路径或路线。"
        },
        "add_point": {
            "title": "点",
            "description": "在地图上添加餐馆，古迹，邮箱或其他点。",
            "tail": "在地图上点击添加一个点。"
        },
        "browse": {
            "title": "浏览",
            "description": "平移和缩放地图。"
        },
        "draw_area": {
            "tail": "通过点击给你的面添加结点。单击第一个点完成面的绘制。"
        },
        "draw_line": {
            "tail": "通过单击给线添加更多的点。点击其他线路连接它们，双击结束。"
        }
    },
    "operations": {
        "add": {
            "annotation": {
                "point": "添加一个点。",
                "vertex": "给线添加一个节点。"
            }
        },
        "start": {
            "annotation": {
                "line": "开始一条线。",
                "area": "开始一个面。"
            }
        },
        "continue": {
            "annotation": {
                "line": "接着绘制一条线。",
                "area": "接着绘制一个面。"
            }
        },
        "cancel_draw": {
            "annotation": "取消绘图。"
        },
        "change_tags": {
            "annotation": "改变标签。"
        },
        "circularize": {
            "title": "圆",
            "description": "制作圆形。",
            "key": "O",
            "annotation": {
                "line": "把线制作成圆形。",
                "area": "把面制作成圆形。"
            }
        },
        "orthogonalize": {
            "title": "直角化",
            "description": "边角直角化。",
            "key": "Q",
            "annotation": {
                "line": "线直角化。",
                "area": "面直角化。"
            }
        },
        "delete": {
            "title": "删除",
            "description": "从地图中删除此。",
            "annotation": {
                "point": "删除一个点。",
                "vertex": "删除线上一个结点。",
                "line": "删除一条点。",
                "area": "删除一个面。",
                "relation": "删除一个关系。",
                "multiple": "删除{n}个对象。"
            }
        },
        "connect": {
            "annotation": {
                "point": "连接线到一个点上。",
                "vertex": "连接线到另一条线上。",
                "line": "连接线到一条线上。",
                "area": "连接线到一个面上。"
            }
        },
        "disconnect": {
            "title": "断开",
            "description": "断开这些线。",
            "key": "D",
            "annotation": "断开线。"
        },
        "merge": {
            "title": "合并",
            "description": "合并这些线。",
            "key": "C",
            "annotation": "合并{n}条线。"
        },
        "move": {
            "title": "移动",
            "description": "移动到其他的位置。",
            "key": "M",
            "annotation": {
                "point": "移动一个点。",
                "vertex": "移动线上一个结点",
                "line": "移动一条线。",
                "area": "移动一个面。",
                "multiple": "移动多个对象。"
            }
        },
        "rotate": {
            "title": "旋转",
            "description": "绕其中心点旋转该对象。",
            "key": "R",
            "annotation": {
                "line": "旋转一条线。",
                "area": "旋转一个面。"
            }
        },
        "reverse": {
            "title": "反转",
            "description": "这条线走在相反的方向。",
            "key": "V",
            "annotation": "反转一条线。"
        },
        "split": {
            "title": "分割",
            "description": "在这点上分成两条线。",
            "key": "X",
            "annotation": "分割一条线。"
        }
    },
    "nothing_to_undo": "没有可撤消的。",
    "nothing_to_redo": "没有可重做的。",
    "just_edited": "你正在编辑的OpenStreetMap！",
    "browser_notice": "该编辑器支持Firefox、Chrome、Safari、Opera和Internet Explorer9及以上的浏览器。请升级您的浏览器或者使用Potlatch 2来编辑地图。",
    "view_on_osm": "在OSM上查看",
    "zoom_in_edit": "放大编辑地图",
    "logout": "退出",
    "report_a_bug": "报告bug",
    "commit": {
        "title": "保存更改",
        "description_placeholder": "简要说明你的贡献",
        "message_label": "提交说明",
        "upload_explanation": "{user}你上传的更新将会显示在所有使用OpenStreetMap数据的地图上。",
        "save": "保存",
        "cancel": "取消",
        "warnings": "警告",
        "modified": "修改的",
        "deleted": "删除的",
        "created": "创建的"
    },
    "contributors": {
        "list": "查看{users}的贡献",
        "truncated_list": "查看{users}和其他{count}个成员的贡献"
    },
    "geocoder": {
        "title": "查找位置",
        "placeholder": "查找位置",
        "no_results": "无法找到叫'{name}'的地方"
    },
    "geolocate": {
        "title": "显示我的位置"
    },
    "inspector": {
        "no_documentation_combination": "没有关于此标签组合的文档",
        "no_documentation_key": "没有关于此键的文档",
        "show_more": "显示更多",
        "new_tag": "新建标签",
        "view_on_osm": "在OSM上查看",
        "editing_feature": "编辑{feature}",
        "additional": "附加标签",
        "choose": "选择对象的类型",
        "results": "{search}共有{n}个结果",
        "reference": "查看 OpenStreetMap Wiki →",
        "back_tooltip": "修改对象的类型"
    },
    "background": {
        "title": "背景",
        "description": "设置背景",
        "percent_brightness": "{opacity}% 亮度",
        "fix_misalignment": "修复错位",
        "reset": "重置"
    },
    "restore": {
        "description": "上次您有未保存的更改。你想恢复这些更改吗？",
        "restore": "恢复",
        "reset": "重置"
    },
    "save": {
        "title": "保存",
        "help": "保存更改到OpenStreetMap上，使其他用户可以看见。",
        "no_changes": "没有可以保存的更改。",
        "error": "保存发生错误",
        "uploading": "正在向OpenStreetMap上传更改。",
        "unsaved_changes": "您有未保存的更改"
    },
    "splash": {
        "welcome": "欢迎使用OpenStreetMap编辑器iD",
        "text": "这是开发版本{version}。欲了解更多信息，请参阅{website}，在{github}报告bug。"
    },
    "source_switch": {
        "live": "live",
        "dev": "dev"
    },
    "tag_reference": {
        "description": "描述",
        "on_wiki": "在wiki.osm.org查看{tag}",
        "used_with": "使用{type}"
    },
    "validations": {
        "untagged_point": "未标记点，他并不是线或面的一部分",
        "untagged_line": "未标记的线",
        "untagged_area": "未标记的面",
        "many_deletions": "您正在删除{n}个对象。你确定你想这样做吗？所有的其他openstreetmap.org用户都将在地图上看不到这些数据。",
        "tag_suggests_area": "{tag}这个标签建议使用在面上，但是他不是一个面",
        "deprecated_tags": "已过时标签：{tags}"
    },
    "zoom": {
        "in": "放大",
        "out": "缩小"
    },
    "imagery": {
        "provided_by": "影像由{source}提供"
    },
    "gpx": {
        "local_layer": "本地GPX文件",
        "drag_drop": "把GPX文件拖到页面上。"
    },
    "presets": {
        "fields": {
            "access": {
                "label": "通道"
            },
            "address": {
                "label": "地址",
                "placeholders": {
                    "housename": "房屋名称",
                    "number": "123",
                    "street": "街道",
                    "city": "城市"
                }
            },
            "aeroway": {
                "label": "类型"
            },
            "amenity": {
                "label": "类型"
            },
            "atm": {
                "label": "ATM"
            },
            "barrier": {
                "label": "类型"
            },
            "bicycle_parking": {
                "label": "类型"
            },
            "building": {
                "label": "建筑物"
            },
            "building_area": {
                "label": "建筑物"
            },
            "building_yes": {
                "label": "建筑物"
            },
            "capacity": {
                "label": "容量"
            },
            "collection_times": {
                "label": "收集时间"
            },
            "construction": {
                "label": "类型"
            },
            "country": {
                "label": "国家"
            },
            "crossing": {
                "label": "类型"
            },
            "cuisine": {
                "label": "美食"
            },
            "denomination": {
                "label": "教派"
            },
            "denotation": {
                "label": "意思"
            },
            "elevation": {
                "label": "海拔"
            },
            "emergency": {
                "label": "急诊"
            },
            "entrance": {
                "label": "类型"
            },
            "fax": {
                "label": "传真"
            },
            "fee": {
                "label": "费用"
            },
            "highway": {
                "label": "类型"
            },
            "historic": {
                "label": "类型"
            },
            "internet_access": {
                "label": "互联网接入",
                "options": {
                    "wlan": "无线网络",
                    "wired": "有线网络",
                    "terminal": "终端"
                }
            },
            "landuse": {
                "label": "类型"
            },
            "layer": {
                "label": "层"
            },
            "leisure": {
                "label": "类型"
            },
            "levels": {
                "label": "级别"
            },
            "man_made": {
                "label": "类型"
            },
            "maxspeed": {
                "label": "限速"
            },
            "name": {
                "label": "名称"
            },
            "natural": {
                "label": "自然"
            },
            "network": {
                "label": "网络"
            },
            "note": {
                "label": "备注"
            },
            "office": {
                "label": "类型"
            },
            "oneway": {
                "label": "单行"
            },
            "oneway_yes": {
                "label": "单行"
            },
            "opening_hours": {
                "label": "小时"
            },
            "operator": {
                "label": "经营者"
            },
            "phone": {
                "label": "手机"
            },
            "place": {
                "label": "类型"
            },
            "power": {
                "label": "类型"
            },
            "railway": {
                "label": "类型"
            },
            "ref": {
                "label": "参考"
            },
            "religion": {
                "label": "宗教",
                "options": {
                    "christian": "基督教",
                    "muslim": "穆斯林",
                    "buddhist": "佛教",
                    "jewish": "犹太教",
                    "hindu": "印度教",
                    "shinto": "神道教",
                    "taoist": "道教"
                }
            },
            "service": {
                "label": "类型"
            },
            "shelter": {
                "label": "避难所"
            },
            "shop": {
                "label": "类型"
            },
            "source": {
                "label": "来源"
            },
            "sport": {
                "label": "运动"
            },
            "structure": {
                "label": "结构",
                "options": {
                    "bridge": "桥",
                    "tunnel": "隧道",
                    "embankment": "堤岸",
                    "cutting": "开凿"
                }
            },
            "surface": {
                "label": "表面"
            },
            "tourism": {
                "label": "类型"
            },
            "water": {
                "label": "类型"
            },
            "waterway": {
                "label": "类型"
            },
            "website": {
                "label": "网站"
            },
            "wetland": {
                "label": "类型"
            },
            "wheelchair": {
                "label": "轮椅通道"
            },
            "wikipedia": {
                "label": "维基百科"
            },
            "wood": {
                "label": "类型"
            }
        },
        "presets": {
            "aeroway": {
                "name": "机场相关道路"
            },
            "aeroway/aerodrome": {
                "name": "机场",
                "terms": "飞机,机场,机场"
            },
            "aeroway/helipad": {
                "name": "直升机场",
                "terms": "直升机,直升机停机坪,直升机场"
            },
            "amenity": {
                "name": "便利设施"
            },
            "amenity/bank": {
                "name": "银行"
            },
            "amenity/bar": {
                "name": "酒吧"
            },
            "amenity/bench": {
                "name": "长凳"
            },
            "amenity/bicycle_parking": {
                "name": "自行车停放处"
            },
            "amenity/bicycle_rental": {
                "name": "自行车租赁处"
            },
            "amenity/cafe": {
                "name": "咖啡",
                "terms": "咖啡,茶,咖啡馆"
            },
            "amenity/cinema": {
                "name": "电影院"
            },
            "amenity/courthouse": {
                "name": "法院"
            },
            "amenity/embassy": {
                "name": "使馆"
            },
            "amenity/fast_food": {
                "name": "快餐"
            },
            "amenity/fire_station": {
                "name": "消防站"
            },
            "amenity/fuel": {
                "name": "加油站"
            },
            "amenity/grave_yard": {
                "name": "墓地"
            },
            "amenity/hospital": {
                "name": "医院"
            },
            "amenity/library": {
                "name": "图书馆"
            },
            "amenity/marketplace": {
                "name": "市场"
            },
            "amenity/parking": {
                "name": "停车场"
            },
            "amenity/pharmacy": {
                "name": "药房"
            },
            "amenity/place_of_worship": {
                "name": "礼拜场所"
            },
            "amenity/place_of_worship/christian": {
                "name": "教堂"
            },
            "amenity/place_of_worship/jewish": {
                "name": "犹太教堂",
                "terms": "犹太人,犹太教堂"
            },
            "amenity/place_of_worship/muslim": {
                "name": "清真寺",
                "terms": "穆斯林,清真寺"
            },
            "amenity/police": {
                "name": "警察局"
            },
            "amenity/post_box": {
                "name": "邮箱",
                "terms": "邮件投递,信箱,邮筒,邮箱"
            },
            "amenity/post_office": {
                "name": "邮局"
            },
            "amenity/pub": {
                "name": "酒馆"
            },
            "amenity/restaurant": {
                "name": "餐馆"
            },
            "amenity/school": {
                "name": "学校"
            },
            "amenity/swimming_pool": {
                "name": "游泳池"
            },
            "amenity/telephone": {
                "name": "电话"
            },
            "amenity/theatre": {
                "name": "剧院"
            },
            "amenity/toilets": {
                "name": "厕所"
            },
            "amenity/townhall": {
                "name": "市政府"
            },
            "amenity/university": {
                "name": "大学"
            },
            "barrier": {
                "name": "屏障"
            },
            "barrier/block": {
                "name": "街区"
            },
            "barrier/bollard": {
                "name": "短柱"
            },
            "barrier/cattle_grid": {
                "name": "家畜栅栏"
            },
            "barrier/city_wall": {
                "name": "城墙"
            },
            "barrier/ditch": {
                "name": "沟"
            },
            "barrier/entrance": {
                "name": "入口"
            },
            "barrier/fence": {
                "name": "篱笆"
            },
            "barrier/gate": {
                "name": "门"
            },
            "barrier/lift_gate": {
                "name": "电梯门"
            },
            "barrier/retaining_wall": {
                "name": "挡土墙"
            },
            "barrier/toll_booth": {
                "name": "收费站"
            },
            "barrier/wall": {
                "name": "墙"
            },
            "building": {
                "name": "建筑物"
            },
            "building/entrance": {
                "name": "入口"
            },
            "entrance": {
                "name": "入口"
            },
            "highway": {
                "name": "公路"
            },
            "highway/bridleway": {
                "name": "马道",
                "terms": "楼梯"
            },
            "highway/bus_stop": {
                "name": "公交车站"
            },
            "highway/crossing": {
                "name": "路口",
                "terms": "人行横道,斑马线"
            },
            "highway/cycleway": {
                "name": "自行车道"
            },
            "highway/footway": {
                "name": "人行道"
            },
            "highway/motorway": {
                "name": "高速公路"
            },
            "highway/motorway_link": {
                "name": "高速公路匝道"
            },
            "highway/path": {
                "name": "路"
            },
            "highway/primary": {
                "name": "主要道路"
            },
            "highway/primary_link": {
                "name": "主要道路匝道"
            },
            "highway/residential": {
                "name": "住宅区道路"
            },
            "highway/road": {
                "name": "未知道路"
            },
            "highway/secondary": {
                "name": "次要道路"
            },
            "highway/secondary_link": {
                "name": "次要道路匝道"
            },
            "highway/service": {
                "name": "辅助道路"
            },
            "highway/steps": {
                "name": "台阶",
                "terms": "楼梯"
            },
            "highway/tertiary": {
                "name": "三级道路"
            },
            "highway/tertiary_link": {
                "name": "三级道路匝道"
            },
            "highway/track": {
                "name": "小路"
            },
            "highway/traffic_signals": {
                "name": "红绿灯",
                "terms": "灯,刹车灯,交通灯"
            },
            "highway/trunk": {
                "name": "干线道路"
            },
            "highway/trunk_link": {
                "name": "干线道路匝道"
            },
            "highway/turning_circle": {
                "name": "环岛"
            },
            "highway/unclassified": {
                "name": "未分级的道路"
            },
            "historic": {
                "name": "历史遗迹"
            },
            "historic/archaeological_site": {
                "name": "考古遗址"
            },
            "historic/boundary_stone": {
                "name": "界桩"
            },
            "historic/castle": {
                "name": "城堡"
            },
            "historic/memorial": {
                "name": "纪念馆"
            },
            "historic/monument": {
                "name": "纪念碑"
            },
            "historic/ruins": {
                "name": "废墟"
            },
            "historic/wayside_cross": {
                "name": "路边的十字架"
            },
            "historic/wayside_shrine": {
                "name": "路边的神社"
            },
            "landuse": {
                "name": "土地用途"
            },
            "landuse/allotments": {
                "name": "社区花园"
            },
            "landuse/basin": {
                "name": "水池"
            },
            "landuse/cemetery": {
                "name": "墓地"
            },
            "landuse/commercial": {
                "name": "商业区"
            },
            "landuse/construction": {
                "name": "建筑物"
            },
            "landuse/farm": {
                "name": "农场"
            },
            "landuse/farmyard": {
                "name": "农场"
            },
            "landuse/forest": {
                "name": "森林"
            },
            "landuse/grass": {
                "name": "草坪"
            },
            "landuse/industrial": {
                "name": "工业区"
            },
            "landuse/meadow": {
                "name": "牧场"
            },
            "landuse/orchard": {
                "name": "果园"
            },
            "landuse/quarry": {
                "name": "采石场"
            },
            "landuse/residential": {
                "name": "住宅区"
            },
            "landuse/vineyard": {
                "name": "葡萄园"
            },
            "leisure": {
                "name": "休闲场所"
            },
            "leisure/garden": {
                "name": "花园"
            },
            "leisure/golf_course": {
                "name": "高尔夫球场"
            },
            "leisure/marina": {
                "name": "码头"
            },
            "leisure/park": {
                "name": "公园"
            },
            "leisure/pitch": {
                "name": "运动场所"
            },
            "leisure/pitch/american_football": {
                "name": "美式足球场"
            },
            "leisure/pitch/baseball": {
                "name": "棒球场"
            },
            "leisure/pitch/basketball": {
                "name": "篮球场"
            },
            "leisure/pitch/soccer": {
                "name": "足球场"
            },
            "leisure/pitch/tennis": {
                "name": "网球场"
            },
            "leisure/playground": {
                "name": "运动场"
            },
            "leisure/slipway": {
                "name": "下水滑道"
            },
            "leisure/stadium": {
                "name": "体育场"
            },
            "leisure/swimming_pool": {
                "name": "游泳池"
            },
            "man_made": {
                "name": "人造的"
            },
            "man_made/lighthouse": {
                "name": "灯塔"
            },
            "man_made/pier": {
                "name": "码头"
            },
            "man_made/survey_point": {
                "name": "测量点"
            },
            "man_made/water_tower": {
                "name": "水塔"
            },
            "natural": {
                "name": "自然"
            },
            "natural/bay": {
                "name": "海湾"
            },
            "natural/beach": {
                "name": "海滩"
            },
            "natural/cliff": {
                "name": "悬崖"
            },
            "natural/coastline": {
                "name": "海岸线",
                "terms": "岸"
            },
            "natural/glacier": {
                "name": "冰川"
            },
            "natural/grassland": {
                "name": "草原"
            },
            "natural/heath": {
                "name": "荒野"
            },
            "natural/peak": {
                "name": "山峰"
            },
            "natural/scrub": {
                "name": "灌木丛"
            },
            "natural/spring": {
                "name": "泉水"
            },
            "natural/tree": {
                "name": "树"
            },
            "natural/water": {
                "name": "水"
            },
            "natural/water/lake": {
                "name": "湖泊",
                "terms": "小湖,湖"
            },
            "natural/water/pond": {
                "name": "池塘"
            },
            "natural/water/reservoir": {
                "name": "水库"
            },
            "natural/wetland": {
                "name": "湿地"
            },
            "natural/wood": {
                "name": "树林"
            },
            "office": {
                "name": "办公室"
            },
            "place": {
                "name": "地点"
            },
            "place/hamlet": {
                "name": "小村庄"
            },
            "place/island": {
                "name": "岛屿"
            },
            "place/locality": {
                "name": "位置"
            },
            "place/village": {
                "name": "村庄"
            },
            "power": {
                "name": "电力设施"
            },
            "power/generator": {
                "name": "发电厂"
            },
            "power/line": {
                "name": "电路线"
            },
            "power/pole": {
                "name": "电线杆"
            },
            "power/sub_station": {
                "name": "变电站"
            },
            "power/tower": {
                "name": "高压电塔"
            },
            "power/transformer": {
                "name": "变压器"
            },
            "railway": {
                "name": "铁路"
            },
            "railway/abandoned": {
                "name": "废弃的铁路"
            },
            "railway/disused": {
                "name": "废弃的铁路"
            },
            "railway/level_crossing": {
                "name": "平交路口"
            },
            "railway/monorail": {
                "name": "单轨铁路"
            },
            "railway/rail": {
                "name": "铁轨"
            },
            "railway/subway": {
                "name": "地铁"
            },
            "railway/subway_entrance": {
                "name": "地铁口"
            },
            "railway/tram": {
                "name": "电车",
                "terms": "电车"
            },
            "shop": {
                "name": "商店"
            },
            "shop/alcohol": {
                "name": "酒品店"
            },
            "shop/bakery": {
                "name": "面包店"
            },
            "shop/beauty": {
                "name": "美容店"
            },
            "shop/beverages": {
                "name": "饮料店"
            },
            "shop/bicycle": {
                "name": "自行车店"
            },
            "shop/books": {
                "name": "书店"
            },
            "shop/boutique": {
                "name": "精品店"
            },
            "shop/butcher": {
                "name": "肉贩"
            },
            "shop/car": {
                "name": "汽车经销商"
            },
            "shop/car_parts": {
                "name": "汽车配件店"
            },
            "shop/car_repair": {
                "name": "汽车修理店"
            },
            "shop/chemist": {
                "name": "药房"
            },
            "shop/clothes": {
                "name": "服装店"
            },
            "shop/computer": {
                "name": "电脑店"
            },
            "shop/confectionery": {
                "name": "糕饼"
            },
            "shop/convenience": {
                "name": "便利店"
            },
            "shop/deli": {
                "name": "熟食店"
            },
            "shop/department_store": {
                "name": "百货店"
            },
            "shop/doityourself": {
                "name": "DIY商店"
            },
            "shop/dry_cleaning": {
                "name": "干洗店"
            },
            "shop/electronics": {
                "name": "家电店"
            },
            "shop/fishmonger": {
                "name": "鱼贩"
            },
            "shop/florist": {
                "name": "花店"
            },
            "shop/furniture": {
                "name": "家具店"
            },
            "shop/garden_centre": {
                "name": "花店"
            },
            "shop/gift": {
                "name": "礼品店"
            },
            "shop/greengrocer": {
                "name": "蔬菜水果店"
            },
            "shop/hairdresser": {
                "name": "理发师"
            },
            "shop/hardware": {
                "name": "五金商店"
            },
            "shop/hifi": {
                "name": "音响店"
            },
            "shop/jewelry": {
                "name": "珠宝店"
            },
            "shop/kiosk": {
                "name": "报刊亭"
            },
            "shop/laundry": {
                "name": "洗衣店"
            },
            "shop/mall": {
                "name": "购物中心"
            },
            "shop/mobile_phone": {
                "name": "手机店"
            },
            "shop/motorcycle": {
                "name": "摩托车经销商"
            },
            "shop/music": {
                "name": "音乐店"
            },
            "shop/newsagent": {
                "name": "书报"
            },
            "shop/optician": {
                "name": "眼镜店"
            },
            "shop/outdoor": {
                "name": "户外店"
            },
            "shop/pet": {
                "name": "宠物店"
            },
            "shop/shoes": {
                "name": "鞋店"
            },
            "shop/sports": {
                "name": "体育用品店"
            },
            "shop/stationery": {
                "name": "文化用品店"
            },
            "shop/supermarket": {
                "name": "超级市场"
            },
            "shop/toys": {
                "name": "玩具店"
            },
            "shop/travel_agency": {
                "name": "旅行社"
            },
            "shop/tyres": {
                "name": "轮胎店"
            },
            "shop/vacant": {
                "name": "空置铺位"
            },
            "shop/variety_store": {
                "name": "杂货店"
            },
            "shop/video": {
                "name": "影像店"
            },
            "tourism": {
                "name": "旅游业"
            },
            "tourism/alpine_hut": {
                "name": "高山小屋"
            },
            "tourism/artwork": {
                "name": "艺术品"
            },
            "tourism/attraction": {
                "name": "旅游景点"
            },
            "tourism/camp_site": {
                "name": "露营区"
            },
            "tourism/caravan_site": {
                "name": "房车营地"
            },
            "tourism/chalet": {
                "name": "木屋"
            },
            "tourism/guest_house": {
                "name": "宾馆"
            },
            "tourism/hostel": {
                "name": "招待所"
            },
            "tourism/hotel": {
                "name": "旅馆"
            },
            "tourism/information": {
                "name": "信息板"
            },
            "tourism/motel": {
                "name": "汽车旅馆"
            },
            "tourism/museum": {
                "name": "博物馆"
            },
            "tourism/picnic_site": {
                "name": "郊游地点"
            },
            "tourism/theme_park": {
                "name": "主题公园"
            },
            "tourism/viewpoint": {
                "name": "景点"
            },
            "tourism/zoo": {
                "name": "动物园"
            },
            "waterway": {
                "name": "航道"
            },
            "waterway/canal": {
                "name": "运河"
            },
            "waterway/dam": {
                "name": "水坝"
            },
            "waterway/ditch": {
                "name": "沟渠"
            },
            "waterway/drain": {
                "name": "下水道"
            },
            "waterway/river": {
                "name": "河流"
            },
            "waterway/riverbank": {
                "name": "河堤"
            },
            "waterway/stream": {
                "name": "溪流"
            },
            "waterway/weir": {
                "name": "堤坝"
            }
        }
    }
};
locale.zh_TW = {
    "modes": {
        "add_area": {
            "title": "區域",
            "description": "在地圖上添加公園、建築物、湖泊或其他區域。",
            "tail": "按一下地圖來開始繪製一個區域，如公園、湖泊或建築物。"
        },
        "add_line": {
            "title": "線",
            "description": "在地圖上添加公路、街道、行人徑、運河或其他線段。",
            "tail": "按一下地圖來開始繪製道路、小徑或路徑。"
        },
        "add_point": {
            "title": "點",
            "description": "在地圖上添加餐廳、古蹪、郵箱或其他地點。",
            "tail": "按一下地圖來添加一個點。"
        },
        "browse": {
            "title": "瀏覽",
            "description": "平移及縮放地圖。"
        },
        "draw_area": {
            "tail": "按一下你的區域來為它添加點。按第一點來完成繪製這個區域。"
        },
        "draw_line": {
            "tail": "點擊線段以便添加更多點。按一下其他線段去連接它們，按兩下去完成繒製。"
        }
    },
    "operations": {
        "add": {
            "annotation": {
                "point": "添加了一點。",
                "vertex": "給路徑添加了一節點。"
            }
        },
        "start": {
            "annotation": {
                "line": "開始繪製一線段。",
                "area": "開始繪製一區域。"
            }
        },
        "continue": {
            "annotation": {
                "line": "繼續繪製一線段。",
                "area": "繼續繪製一區域。"
            }
        },
        "cancel_draw": {
            "annotation": "取消了繪圖。"
        },
        "change_tags": {
            "annotation": "修改了標籤。"
        },
        "circularize": {
            "title": "環形化",
            "description": "把這個物件製成圓形。",
            "key": "O",
            "annotation": {
                "line": "把一線段製成圓形。",
                "area": "把一區域製成圓形。"
            }
        },
        "orthogonalize": {
            "title": "直角化",
            "description": "把角落轉換成轉角。",
            "key": "Q",
            "annotation": {
                "line": "把線段上的角落換成轉角。",
                "area": "把區域的角落換成轉角"
            }
        },
        "delete": {
            "title": "刪除",
            "description": "從地圖上移除這個物件。",
            "annotation": {
                "point": "刪除了一點。",
                "vertex": "刪除了路徑上的一個節點。",
                "line": "刪除了一線段。",
                "area": "刪除了一區域。",
                "relation": "刪除了一關係",
                "multiple": "刪除了 {n} 個物件。"
            }
        },
        "connect": {
            "annotation": {
                "point": "已連接路徑到一點。",
                "vertex": "已連接路徑到另一路徑。",
                "line": "已連接路徑到一線段。",
                "area": "已連接路徑到一區域。"
            }
        },
        "disconnect": {
            "title": "斷開",
            "description": "斷開這些路徑。",
            "key": "D",
            "annotation": "斷開了路徑。"
        },
        "merge": {
            "title": "合併",
            "description": "合併這些線段。",
            "key": "C",
            "annotation": "合併了 {n} 條線段。"
        },
        "move": {
            "title": "移動",
            "description": "移動這物件到另一處。",
            "key": "M",
            "annotation": {
                "point": "移動了一點。",
                "vertex": "移動了路徑上的一節點。",
                "line": "移動了一線段。",
                "area": "移動了一區域。",
                "multiple": "移動了數個物件。"
            }
        },
        "rotate": {
            "title": "旋轉",
            "description": "讓這物件圍繞其中心點旋轉。",
            "key": "R",
            "annotation": {
                "line": "旋轉了一線段。",
                "area": "旋轉了一區域。"
            }
        },
        "reverse": {
            "title": "反轉",
            "description": "讓這線段循相反方向走。",
            "key": "V",
            "annotation": "反轉一線段。"
        },
        "split": {
            "title": "分割",
            "description": "在這一點分割成兩條線段。",
            "key": "X",
            "annotation": "分割一路徑。"
        }
    },
    "nothing_to_undo": "沒有動作可以撤銷。",
    "nothing_to_redo": "沒有動作可以重做。",
    "just_edited": "你剛剛編輯了OpenStreetMap！",
    "browser_notice": "這編輯器支援Firefox、Chrome、Safari、Opera及Internet Explorer 9或以上。請先把你的瀏覽器升級或使用Potlatch 2來編輯地圖。",
    "view_on_osm": "於OSM上顯示",
    "zoom_in_edit": "放大地圖以開始編輯",
    "logout": "登出",
    "report_a_bug": "報導錯誤",
    "commit": {
        "title": "儲存修改",
        "description_placeholder": "簡要描述你的貢獻",
        "upload_explanation": "你以 {user} 具名的修改將會在所有使用OpenStreetMap數據的地圖上看得見。",
        "save": "儲存",
        "cancel": "取消",
        "warnings": "警告",
        "modified": "已修改",
        "deleted": "已刪除",
        "created": "已創建"
    },
    "contributors": {
        "list": "正在觀看 {users} 的貢獻",
        "truncated_list": "正在觀看 {users} 和另外 {count} 個用戶的貢獻"
    },
    "geocoder": {
        "title": "尋找一地方",
        "placeholder": "尋找一地方",
        "no_results": "找不到名為 '{name}' 的地方"
    },
    "geolocate": {
        "title": "顯示我的位置"
    },
    "inspector": {
        "no_documentation_combination": "這個標籤組合沒有可用的文檔",
        "no_documentation_key": "這個鍵值沒有可用的文檔",
        "show_more": "顯示更多",
        "new_tag": "新的標籤",
        "view_on_osm": "在OSM上顯示",
        "editing_feature": "正在編輯 {feature}",
        "additional": "附加的標籤",
        "choose": "選擇功能種類",
        "results": "{search} 的 {n} 個結果",
        "reference": "查看OpenStreetMap Wiki →",
        "back_tooltip": "修改功能種類"
    },
    "background": {
        "title": "背景",
        "description": "背景設定",
        "percent_brightness": "{opacity}%的光度",
        "fix_misalignment": "校準",
        "reset": "重設"
    },
    "restore": {
        "description": "上一次你仍有未儲存的修改，你想恢復這些修改嗎﹖",
        "restore": "恢復",
        "reset": "重設"
    },
    "save": {
        "title": "儲存",
        "help": "儲存修改至OpenStreetMap，使其他用戶均可觀看你的修改。",
        "no_changes": "沒有修改需要儲存。",
        "error": "儲存時發生錯誤",
        "uploading": "正在上傳修改至OpenStreetMap。",
        "unsaved_changes": "你有未儲存的修改"
    },
    "splash": {
        "welcome": "歡迎使用iD OpenStreetMap編輯器",
        "text": "這是開發版本 {version}。欲知詳情請瀏覽 {website} 及於 {github} 報告錯誤。"
    },
    "source_switch": {
        "live": "實況模式",
        "dev": "開發模式"
    },
    "tag_reference": {
        "description": "描述",
        "on_wiki": "於wiki.osm.org上的 {tag}",
        "used_with": "可與 {type} 使用"
    },
    "validations": {
        "untagged_point": "未標記的點—不在任何線段或區域內",
        "untagged_line": "未標記的線段",
        "untagged_area": "未標記的區域",
        "many_deletions": "你正在刪除 {n} 個物件。這樣會從openstreetmap.org的地圖上刪除，你是否確定需要這樣做？",
        "tag_suggests_area": "{tag} 標籤所建議的線段應為區域，但這個不是一區域",
        "deprecated_tags": "已棄用的標籤︰{tags}"
    },
    "zoom": {
        "in": "放大",
        "out": "縮小"
    },
    "imagery": {
        "provided_by": "影像由 {source} 提供"
    },
    "gpx": {
        "local_layer": "本機GPX檔案",
        "drag_drop": "拖放一個.gpx格式的檔案到本頁"
    },
    "presets": {
        "fields": {
            "access": {
                "label": "通道"
            },
            "address": {
                "label": "地址",
                "placeholders": {
                    "housename": "屋宇名稱",
                    "number": "123",
                    "street": "街道",
                    "city": "城市"
                }
            },
            "aeroway": {
                "label": "種類"
            },
            "amenity": {
                "label": "種類"
            },
            "atm": {
                "label": "自動取款機"
            },
            "bicycle_parking": {
                "label": "種類"
            },
            "building": {
                "label": "建築物"
            },
            "building_area": {
                "label": "建築物"
            },
            "building_yes": {
                "label": "建築物"
            },
            "capacity": {
                "label": "容量"
            },
            "collection_times": {
                "label": "收集時間"
            },
            "construction": {
                "label": "種類"
            },
            "country": {
                "label": "國家"
            },
            "crossing": {
                "label": "種類"
            },
            "cuisine": {
                "label": "美饌"
            },
            "denomination": {
                "label": "教派"
            },
            "denotation": {
                "label": "表示"
            },
            "elevation": {
                "label": "高度"
            },
            "emergency": {
                "label": "緊急"
            },
            "entrance": {
                "label": "種類"
            },
            "fax": {
                "label": "傳真"
            },
            "fee": {
                "label": "費用"
            },
            "highway": {
                "label": "種類"
            },
            "historic": {
                "label": "種類"
            },
            "internet_access": {
                "label": "網際網絡連接",
                "options": {
                    "wlan": "無線網絡",
                    "wired": "有線網絡",
                    "terminal": "終端"
                }
            },
            "landuse": {
                "label": "種類"
            },
            "layer": {
                "label": "層"
            },
            "leisure": {
                "label": "種類"
            },
            "levels": {
                "label": "級別"
            },
            "man_made": {
                "label": "種類"
            },
            "maxspeed": {
                "label": "速度限制"
            },
            "natural": {
                "label": "自然"
            },
            "network": {
                "label": "網絡"
            },
            "note": {
                "label": "備註"
            },
            "office": {
                "label": "種類"
            },
            "oneway": {
                "label": "單程"
            },
            "opening_hours": {
                "label": "小時"
            },
            "operator": {
                "label": "營運商"
            },
            "phone": {
                "label": "電話"
            },
            "place": {
                "label": "種類"
            },
            "railway": {
                "label": "種類"
            },
            "ref": {
                "label": "參考"
            },
            "religion": {
                "label": "宗教",
                "options": {
                    "christian": "基督教徒",
                    "muslim": "穆斯林",
                    "buddhist": "佛教徒",
                    "jewish": "猶太教徒",
                    "hindu": "印度教徒",
                    "shinto": "神道教徒",
                    "taoist": "道教徒"
                }
            },
            "service": {
                "label": "種類"
            },
            "shelter": {
                "label": "遮雨棚／涼亭"
            },
            "shop": {
                "label": "種類"
            },
            "source": {
                "label": "來源"
            },
            "sport": {
                "label": "運動"
            },
            "structure": {
                "label": "結構",
                "options": {
                    "bridge": "橋樑",
                    "tunnel": "隧道",
                    "embankment": "堤岸",
                    "cutting": "切割"
                }
            },
            "surface": {
                "label": "表面"
            },
            "tourism": {
                "label": "種類"
            },
            "water": {
                "label": "種類"
            },
            "waterway": {
                "label": "種類"
            },
            "website": {
                "label": "網站"
            },
            "wetland": {
                "label": "種類"
            },
            "wheelchair": {
                "label": "輪椅通道"
            },
            "wikipedia": {
                "label": "維基百科"
            },
            "wood": {
                "label": "種類"
            }
        },
        "presets": {
            "aeroway": {
                "name": "機場相關設施"
            },
            "aeroway/aerodrome": {
                "name": "機場",
                "terms": "飛機，飛機場，飛行場"
            },
            "aeroway/helipad": {
                "name": "直昇機場",
                "terms": "直升機，直升機坪，直升機場"
            },
            "amenity": {
                "name": "便利設施"
            },
            "amenity/bank": {
                "name": "銀行",
                "terms": "保險箱，帳房，信用合作社，受托人，國庫，基金，窖藏，投資機構，儲存庫，儲備，儲備，保險箱，存款，庫存，庫存，倉庫，倉庫，儲蓄及貸款協會，國庫，信託公司，窖"
            },
            "amenity/bar": {
                "name": "酒吧"
            },
            "amenity/bench": {
                "name": "長凳"
            },
            "amenity/bicycle_parking": {
                "name": "腳踏車停泊處"
            },
            "amenity/bicycle_rental": {
                "name": "腳踏車租賃"
            },
            "amenity/cafe": {
                "name": "咖啡廳",
                "terms": "咖啡，茶，咖啡店"
            },
            "amenity/cinema": {
                "name": "戲院",
                "terms": "大銀幕，電影院，電影，得來速影院，電影，電影，電影，電影院，電影院，電影，電影院，電影院，電影，電影，劇場，表演，銀幕"
            },
            "amenity/courthouse": {
                "name": "法院"
            },
            "amenity/embassy": {
                "name": "使館"
            },
            "amenity/fast_food": {
                "name": "快餐店"
            },
            "amenity/fire_station": {
                "name": "消防局"
            },
            "amenity/fuel": {
                "name": "加油站"
            },
            "amenity/grave_yard": {
                "name": "墓地"
            },
            "amenity/hospital": {
                "name": "醫院",
                "terms": "診所，急診室，衛生服務，安養院，醫院，醫院，療養院，療養院，療養院，療養院，醫務室，手術室，病房"
            },
            "amenity/library": {
                "name": "圖書館"
            },
            "amenity/parking": {
                "name": "停車場"
            },
            "amenity/pharmacy": {
                "name": "藥房"
            },
            "amenity/place_of_worship": {
                "name": "禮拜地方",
                "terms": "隱修院，宗座聖殿，伯特利，座堂，聖壇，附屬小教堂，小聖堂，教堂，信徒，神殿，祈禱場所，宗教場所，修道院附屬的教堂，傳道部，清真寺，小教堂，教區，小聖堂，聖所，聖地，猶太教堂，禮拜堂，寺廟"
            },
            "amenity/place_of_worship/christian": {
                "name": "教堂",
                "terms": "基督教，隱修院，宗座聖殿，伯特利，座堂，聖壇，附屬小教堂，小聖堂，教堂，信徒，神殿，祈禱場所，宗教場所，修道院附屬的教堂，傳道部，清真寺，小教堂，教區，小聖堂，聖所，聖地，猶太教堂，禮拜堂，寺廟"
            },
            "amenity/place_of_worship/jewish": {
                "name": "猶太教堂",
                "terms": "猶太教，猶太教堂"
            },
            "amenity/place_of_worship/muslim": {
                "name": "清真寺",
                "terms": "穆斯林，清真寺"
            },
            "amenity/police": {
                "name": "警察局",
                "terms": "徽章，警官，警官，警官，警官，男童軍，警官，警官，警官，警官，警官，軍團，警車，偵探，警官，警官，部隊，警官，憲兵，刑警，警官， 法律，執法，警官，警官，警官，警官，警察"
            },
            "amenity/post_box": {
                "name": "郵箱",
                "terms": "信箱，信箱，郵箱，郵箱，郵筒，郵箱"
            },
            "amenity/post_office": {
                "name": "郵政局"
            },
            "amenity/pub": {
                "name": "酒館"
            },
            "amenity/restaurant": {
                "name": "餐廳"
            },
            "amenity/school": {
                "name": "學校"
            },
            "amenity/swimming_pool": {
                "name": "游泳池"
            },
            "amenity/telephone": {
                "name": "電話"
            },
            "amenity/theatre": {
                "name": "劇院"
            },
            "amenity/toilets": {
                "name": "廁所"
            },
            "amenity/townhall": {
                "name": "市政廳"
            },
            "amenity/university": {
                "name": "大學"
            },
            "building": {
                "name": "建築物"
            },
            "building/entrance": {
                "name": "入口"
            },
            "entrance": {
                "name": "入口"
            },
            "highway": {
                "name": "公路"
            },
            "highway/bus_stop": {
                "name": "公共汽車站"
            },
            "highway/crossing": {
                "name": "路口"
            },
            "highway/cycleway": {
                "name": "自行車道"
            },
            "highway/footway": {
                "name": "小徑"
            },
            "highway/motorway": {
                "name": "高速公路"
            },
            "highway/path": {
                "name": "路徑"
            },
            "highway/primary": {
                "name": "主要道路"
            },
            "highway/residential": {
                "name": "住宅區道路"
            },
            "highway/secondary": {
                "name": "次要道路"
            },
            "highway/service": {
                "name": "輔助道路"
            },
            "highway/steps": {
                "name": "樓梯"
            },
            "highway/tertiary": {
                "name": "三級道路"
            },
            "highway/track": {
                "name": "軌道"
            },
            "highway/traffic_signals": {
                "name": "交通訊號"
            },
            "highway/trunk": {
                "name": "幹道"
            },
            "highway/turning_circle": {
                "name": "回轉圈"
            },
            "highway/unclassified": {
                "name": "未分類的道路"
            },
            "historic": {
                "name": "歷史遺址"
            },
            "historic/monument": {
                "name": "古蹟"
            },
            "landuse": {
                "name": "土地用途"
            },
            "landuse/allotments": {
                "name": "社區花園"
            },
            "landuse/basin": {
                "name": "水池"
            },
            "landuse/cemetery": {
                "name": "墳場"
            },
            "landuse/commercial": {
                "name": "商業區"
            },
            "landuse/construction": {
                "name": "施工"
            },
            "landuse/farm": {
                "name": "農場"
            },
            "landuse/farmyard": {
                "name": "農莊"
            },
            "landuse/forest": {
                "name": "森林"
            },
            "landuse/grass": {
                "name": "草地"
            },
            "landuse/industrial": {
                "name": "工業區"
            },
            "landuse/meadow": {
                "name": "牧場"
            },
            "landuse/orchard": {
                "name": "果園"
            },
            "landuse/quarry": {
                "name": "礦場"
            },
            "landuse/residential": {
                "name": "住宅區"
            },
            "landuse/vineyard": {
                "name": "酒莊"
            },
            "leisure": {
                "name": "優閒設施"
            },
            "leisure/garden": {
                "name": "花園"
            },
            "leisure/golf_course": {
                "name": "高爾夫球場"
            },
            "leisure/park": {
                "name": "公園"
            },
            "leisure/pitch": {
                "name": "運動場所"
            },
            "leisure/pitch/american_football": {
                "name": "美式足球場"
            },
            "leisure/pitch/baseball": {
                "name": "棒球場"
            },
            "leisure/pitch/basketball": {
                "name": "籃球場"
            },
            "leisure/pitch/soccer": {
                "name": "足球場"
            },
            "leisure/pitch/tennis": {
                "name": "網球場"
            },
            "leisure/playground": {
                "name": "遊樂場"
            },
            "leisure/stadium": {
                "name": "體育場"
            },
            "leisure/swimming_pool": {
                "name": "游泳池"
            },
            "man_made": {
                "name": "人造"
            },
            "man_made/lighthouse": {
                "name": "燈塔"
            },
            "man_made/pier": {
                "name": "碼頭"
            },
            "man_made/survey_point": {
                "name": "測量點"
            },
            "man_made/water_tower": {
                "name": "水塔"
            },
            "natural": {
                "name": "自然"
            },
            "natural/bay": {
                "name": "海灣"
            },
            "natural/beach": {
                "name": "沙灘"
            },
            "natural/cliff": {
                "name": "懸崖"
            },
            "natural/coastline": {
                "name": "海岸線",
                "terms": "岸"
            },
            "natural/glacier": {
                "name": "冰川"
            },
            "natural/grassland": {
                "name": "草原"
            },
            "natural/heath": {
                "name": "荒地"
            },
            "natural/peak": {
                "name": "山頂"
            },
            "natural/scrub": {
                "name": "灌木叢"
            },
            "natural/spring": {
                "name": "溫泉"
            },
            "natural/tree": {
                "name": "樹"
            },
            "natural/water": {
                "name": "水"
            },
            "natural/water/lake": {
                "name": "湖泊"
            },
            "natural/water/pond": {
                "name": "池塘"
            },
            "natural/water/reservoir": {
                "name": "水塘"
            },
            "natural/wetland": {
                "name": "濕地"
            },
            "natural/wood": {
                "name": "樹林"
            },
            "office": {
                "name": "辦公室"
            },
            "place": {
                "name": "可歸類的地方"
            },
            "place/hamlet": {
                "name": "村莊"
            },
            "place/island": {
                "name": "島嶼"
            },
            "place/locality": {
                "name": "未能歸類的地方"
            },
            "place/village": {
                "name": "村鎮"
            },
            "power/sub_station": {
                "name": "變電站"
            },
            "railway": {
                "name": "火車站"
            },
            "railway/level_crossing": {
                "name": "平交道"
            },
            "railway/rail": {
                "name": "鐵路"
            },
            "railway/subway": {
                "name": "地鐵"
            },
            "railway/subway_entrance": {
                "name": "地鐵入口"
            },
            "shop": {
                "name": "商店"
            },
            "shop/butcher": {
                "name": "肉販"
            },
            "shop/supermarket": {
                "name": "超級市場"
            },
            "tourism": {
                "name": "旅遊業"
            },
            "tourism/alpine_hut": {
                "name": "高山小屋"
            },
            "tourism/artwork": {
                "name": "藝術品"
            },
            "tourism/attraction": {
                "name": "觀光點"
            },
            "tourism/camp_site": {
                "name": "營地"
            },
            "tourism/caravan_site": {
                "name": "露營車停車場"
            },
            "tourism/chalet": {
                "name": "木屋"
            },
            "tourism/guest_house": {
                "name": "賓館"
            },
            "tourism/hostel": {
                "name": "旅舍"
            },
            "tourism/hotel": {
                "name": "酒店"
            },
            "tourism/information": {
                "name": "資訊"
            },
            "tourism/motel": {
                "name": "汽車旅館"
            },
            "tourism/museum": {
                "name": "博物館"
            },
            "tourism/picnic_site": {
                "name": "野餐地點"
            },
            "tourism/theme_park": {
                "name": "主題公園"
            },
            "tourism/viewpoint": {
                "name": "觀景點"
            },
            "tourism/zoo": {
                "name": "動物園"
            },
            "waterway": {
                "name": "水道"
            },
            "waterway/canal": {
                "name": "運河"
            },
            "waterway/dam": {
                "name": "堤壩"
            },
            "waterway/ditch": {
                "name": "溝"
            },
            "waterway/drain": {
                "name": "渠"
            },
            "waterway/river": {
                "name": "河流"
            },
            "waterway/riverbank": {
                "name": "河床"
            },
            "waterway/stream": {
                "name": "溪流"
            },
            "waterway/weir": {
                "name": "堤堰"
            }
        }
    }
};
locale.da = {
    "modes": {
        "add_area": {
            "title": "Område",
            "description": "Tilføj parker, bygninger, søer, eller andre områder til kortet.",
            "tail": "Klik på kortet for at indtegne et område fx en park, sø eller bygning."
        },
        "add_line": {
            "title": "Linje",
            "description": "Linjer kan være veje, gader eller stier selv kanaler kan være linjer.",
            "tail": "Klik på kortet for at indtegne en vej, sti eller rute."
        },
        "add_point": {
            "title": "Punkt",
            "description": "Restauranter, mindesmærker og postkasser er punkter.",
            "tail": "Klik på kortet for at tilføje et punkt."
        },
        "browse": {
            "title": "Gennemse",
            "description": "Træk rundt og zoom på kortet."
        },
        "draw_area": {
            "tail": "Klik her for at tilføje punkter til dit område. Klik på første punkt igen for at færdiggøre området."
        },
        "draw_line": {
            "tail": "Klik her for at tilføje flere punkter til linjen. Klik på andre linjer for at forbinde dem og dobbeltklik for at afslutte linjen."
        }
    },
    "operations": {
        "add": {
            "annotation": {
                "point": "Tilføjede et punkt.",
                "vertex": "Tilføjede en node til en vej."
            }
        },
        "start": {
            "annotation": {
                "line": "Startede en linje.",
                "area": "Startede et område."
            }
        },
        "continue": {
            "annotation": {
                "line": "Fortsatte en linje.",
                "area": "Fortsatte et område."
            }
        },
        "cancel_draw": {
            "annotation": "Annullerede indtegning."
        },
        "change_tags": {
            "annotation": "Ændret tags."
        },
        "circularize": {
            "title": "Cirkularisere",
            "description": "Lav denne rund.",
            "key": "O",
            "annotation": {
                "line": "Lavede en linje rund.",
                "area": "Lave et område rundt."
            }
        },
        "orthogonalize": {
            "title": "Ortogonalisering",
            "description": "Gør disse hjørner firkantet.",
            "key": "Q",
            "annotation": {
                "line": "Lavede hjørner på en linje firkantet.",
                "area": "Lavede hjørner på et område firkantet."
            }
        },
        "delete": {
            "title": "Slet",
            "description": "Fjern dette fra kortet.",
            "annotation": {
                "point": "Slettede et punkt.",
                "vertex": "Slettede en node fra en vej.",
                "line": "Slettede en linje.",
                "area": "Slettede et område.",
                "relation": "Sletede en relation.",
                "multiple": "Slettede {n} objekter."
            }
        },
        "connect": {
            "annotation": {
                "point": "Forbandt en vej til et punkt.",
                "vertex": "Forbandt en vej til en anden vej.",
                "line": "Forbandt en vej til en linje.",
                "area": "Forbandt en vej til et område."
            }
        },
        "disconnect": {
            "title": "Afbryd",
            "description": "Afbryd disse veje fra hinanden.",
            "key": "D",
            "annotation": "Afbrød vejene."
        },
        "merge": {
            "title": "Flet",
            "description": "Flet disse linjer.",
            "key": "C",
            "annotation": "Flettede {n} linjer."
        },
        "move": {
            "title": "Flyt",
            "description": "Flyt dette til en anden lokation.",
            "key": "M",
            "annotation": {
                "point": "Flyttede et punkt.",
                "vertex": "Flyttede en node i en vej.",
                "line": "Flyttede en linje.",
                "area": "Flyttede et område."
            }
        },
        "reverse": {
            "title": "Omvendt",
            "description": "Lad denne linje gå i modsat retning.",
            "key": "V",
            "annotation": "Omvendte en linje."
        },
        "split": {
            "title": "Del op",
            "description": "Del op i to veje ved dette punkt.",
            "key": "X",
            "annotation": "Del en vej op."
        }
    },
    "nothing_to_undo": "Ingenting at fortryde.",
    "nothing_to_redo": "Ingenting at gendanne.",
    "just_edited": "Du har lige rettet i OpenStreetMap!",
    "browser_notice": "Dette værktøj er understøttet i Firefox, Chrome, Safari, Opera og Internet Explorer 9 og højere. Vær venlig at opgradere din browser eller benyt Potlatch 2 for at rette i kortet.",
    "view_on_osm": "Vis på OSM",
    "zoom_in_edit": "zoom ind for at rette på kortet",
    "logout": "log ud",
    "report_a_bug": "rapportere en fejl",
    "commit": {
        "title": "Gem ændringer",
        "description_placeholder": "Kort beskrivelse af dine bidrag",
        "upload_explanation": "Dine ændringer vil som brugernavn {user} blive synligt på alle kort der bruger OpenStreetMap data.",
        "save": "Gem",
        "cancel": "Fortryd",
        "warnings": "Advarsler",
        "modified": "Modificeret",
        "deleted": "Slettede",
        "created": "Lavede"
    },
    "contributors": {
        "list": "Vis bidrag fra {users}",
        "truncated_list": "Vis bidrag fra {users} og {count} andre"
    },
    "geocoder": {
        "title": "Find et sted",
        "placeholder": "find et sted",
        "no_results": "Kunne ikke finde '{name}'"
    },
    "geolocate": {
        "title": "Vis min lokalitet"
    },
    "inspector": {
        "no_documentation_combination": "Der er ingen dokumentation for denne tag kombination",
        "no_documentation_key": "Der er ingen dokumentation tilgængelig for denne nøgle",
        "new_tag": "Nyt tag",
        "view_on_osm": "Vis på OSM"
    },
    "background": {
        "title": "Baggrund",
        "description": "Baggrundsindstillinger",
        "percent_brightness": "{opacity}% lysstyrke",
        "fix_misalignment": "Lav fejljustering",
        "reset": "nulstil"
    },
    "restore": {
        "description": "Du har ændringer fra forrige session som ikke er gemt. Ønsker du at gendanne disse ændringer?",
        "restore": "Gendan",
        "reset": "Nulstil"
    },
    "save": {
        "title": "Gem",
        "help": "Gem ændringer til OpenStreetMap vil gøre dem synlige for andre brugere.",
        "error": "Der skete en fejl da du prøvede at gemme",
        "uploading": "Gemmer nu ændringer til OpenStreetMap.",
        "unsaved_changes": "Du har ændringer der ikke er gemt endnu"
    },
    "splash": {
        "welcome": "Velkommen til iD OpenStreetMap værktøjet",
        "text": "Dette er udviklingsversion {version}. Mere information se {website} og rapportere fejl på {github}."
    },
    "source_switch": {
        "live": "live",
        "dev": "dev"
    },
    "tag_reference": {
        "description": "Beskrivelse",
        "on_wiki": "{tag} på wiki.osm.org",
        "used_with": "brugt med {type}"
    },
    "validations": {
        "untagged_point": "Mangler et tag på punkt som ikke er del af en linje eller område",
        "untagged_line": "Mangler tag på linje",
        "untagged_area": "Mangler tag på område",
        "many_deletions": "You're deleting {n} objects. Are you sure you want to do this? This will delete them from the map that everyone else sees on openstreetmap.org.",
        "tag_suggests_area": "Dette tag {tag} mener denne linje skule være et område, men dette er ikke et område",
        "deprecated_tags": "Uønskede tags: {tags}"
    },
    "zoom": {
        "in": "Zoom ind",
        "out": "Zoom ud"
    }
};
locale.nl = {
    "modes": {
        "add_area": {
            "title": "Vlak",
            "description": "Voeg parken, gebouwen, meren of andere vlakken aan de kaart toe.",
            "tail": "Klik in de kaart om het tekenen van een vlak zoals een park, gebouw of meer te starten."
        },
        "add_line": {
            "title": "Lijn",
            "description": "Lijnen zijn bijvoorbeeld rijkswegen, straten, voetpaden of kanalen.",
            "tail": "Klik in de kaart om het tekenen van straat, pad of route te starten."
        },
        "add_point": {
            "title": "Punt",
            "description": "Restaurants, monumenten en brievenbussen zijn bijvoorbeeld punten.",
            "tail": "Klik in de kaart om een punt toe te voegen."
        },
        "browse": {
            "title": "Navigatie",
            "description": "Verschuif en zoom in op de kaart."
        },
        "draw_area": {
            "tail": "Klik om punten aan het vlak toe te voegen. Klik op het eerste punt om het vlak te sluiten."
        },
        "draw_line": {
            "tail": "Klik om meer punten aan de lijn toe te voegen. Klik op een andere lijn om de lijnen te verbinden en dubbelklik om de lijn af te sluiten."
        }
    },
    "operations": {
        "add": {
            "annotation": {
                "point": "Punt toegevoegd.",
                "vertex": "Knoop aan een weg toegevoegd."
            }
        },
        "start": {
            "annotation": {
                "line": "Lijn begonnen.",
                "area": "Vlak begonnen."
            }
        },
        "continue": {
            "annotation": {
                "line": "Lijn voortgezet.",
                "area": "Vlak voortgezet."
            }
        },
        "cancel_draw": {
            "annotation": "Tekenen afgebroken."
        },
        "change_tags": {
            "annotation": "Tags aangepast."
        },
        "circularize": {
            "title": "Rond maken",
            "description": "Maak dit rond.",
            "key": "O",
            "annotation": {
                "line": "Maak een lijn rond.",
                "area": "Maak een vlak rond."
            }
        },
        "orthogonalize": {
            "title": "Haaks maken",
            "description": "Maak deze hoeken haaks.",
            "key": "Q",
            "annotation": {
                "line": "Hoeken van een lijn zijn haaks gemaakt.",
                "area": "Hoeken van een vlak zijn haaks gemaakt."
            }
        },
        "delete": {
            "title": "Verwijderen",
            "description": "Verwijder dit van de kaart.",
            "annotation": {
                "point": "Punt verwijderd.",
                "vertex": "Knoop uit een weg verwijderd.",
                "line": "Lijn verwijderd.",
                "area": "Vlak verwijderd.",
                "relation": "Relatie verwijderd.",
                "multiple": "{n} objecten verwijderd."
            }
        },
        "connect": {
            "annotation": {
                "point": "Weg aan een punt verbonden.",
                "vertex": "Weg aan een andere weg verbonden.",
                "line": "Weg aan een lijn  verbonden.",
                "area": "Weg aan een vlak verbonden."
            }
        },
        "disconnect": {
            "title": "Losmaken",
            "description": "Maak deze wegen van elkaar los.",
            "key": "D",
            "annotation": "Wegen losgemaakt."
        },
        "merge": {
            "title": "Samenvoegen",
            "description": "Voeg deze lijnen samen.",
            "key": "C",
            "annotation": "{n} lijnen samengevoegd."
        },
        "move": {
            "title": "Verschuiven",
            "description": "Verschuif dit object naar een andere plek.",
            "key": "M",
            "annotation": {
                "point": "Punt verschoven.",
                "vertex": "Knoop van een weg verschoven.",
                "line": "Lijn verschoven.",
                "area": "Vlak verschoven."
            }
        },
        "reverse": {
            "title": "Omdraaien",
            "description": "Draai de richting van deze lijn om.",
            "key": "V",
            "annotation": "Lijnrichting omgedraaid."
        },
        "split": {
            "title": "Splitsen",
            "description": "Splits deze weg op het geselecteerde punt.",
            "key": "X",
            "annotation": "Weg opgesplitst."
        }
    },
    "nothing_to_undo": "Niets om ongedaan te maken.",
    "nothing_to_redo": "Niets om opnieuw uit te voeren.",
    "just_edited": "Je hebt zojuist OpenStreetMap aangepast!",
    "browser_notice": "Deze editor wordt door Firefox, Chrome, Safari, Opera en Internet Explorer (versie 9 en hoger) ondersteund. Download een nieuwere versie van je browser of gebruik Potlatch 2 om de kaart aan te passen.",
    "view_on_osm": "Bekijk op OSM",
    "zoom_in_edit": "Zoom in om de kaart aan te passen.",
    "logout": "Afmelden",
    "report_a_bug": "Meld een softwareprobleem",
    "commit": {
        "title": "Aanpassingen opslaan",
        "description_placeholder": "Een korte omschrijving van je bijdragen",
        "upload_explanation": "Aanpassingen die je als {user} uploadt worden zichtbaar op alle kaarten die de gegevens van OpenStreetMap gebruiken.",
        "save": "Opslaan",
        "cancel": "Afbreken",
        "warnings": "Waarschuwingen",
        "modified": "Aangepast",
        "deleted": "Verwijderd",
        "created": "Aangemaakt"
    },
    "contributors": {
        "list": "Deze kaartuitsnede bevat bijdragen van:",
        "truncated_list": "Deze kaartuitsnede bevat bijdragen van: {users} en {count} anderen"
    },
    "geocoder": {
        "title": "Zoek een plaats",
        "placeholder": "Zoek een plaats",
        "no_results": "De plaats '{name}' kan niet worden gevonden"
    },
    "geolocate": {
        "title": "Toon mijn locatie"
    },
    "inspector": {
        "no_documentation_combination": "Voor deze tag is geen documentatie beschikbaar.",
        "no_documentation_key": "Voor deze sleutel is geen documentatie beschikbaar",
        "new_tag": "Nieuwe tag",
        "view_on_osm": "Bekijk op OSM",
        "additional": "Additional tags",
        "choose": "What are you adding?",
        "results": "{n} results for {search}"
    },
    "background": {
        "title": "Achtergrond",
        "description": "Achtergrondinstellingen",
        "percent_brightness": "{opacity}% helderheid",
        "fix_misalignment": "Repareer de verkeerde ligging",
        "reset": "Ongedaan maken"
    },
    "restore": {
        "description": "Er zijn niet-opgeslagen aanpassingen uit een vorige sessie. Wil je deze aanpassingen behouden?",
        "restore": "Behouden",
        "reset": "Ongedaan maken"
    },
    "save": {
        "title": "Opslaan",
        "help": "Sla de aanpassingen bij OpenStreetMap op om deze voor andere gebruikers zichtbaar te maken",
        "error": "Bij het opslaan is een fout opgetreden",
        "uploading": "De aanpassingen worden naar OpenStreetMap geüpload.",
        "unsaved_changes": "Je hebt niet-opgeslagen aanpassingen"
    },
    "splash": {
        "welcome": "Welkom bij de iD OpenStreetMap editor",
        "text": " Dit is een ontwikkelversie {version}. Voor meer informatie bezoek {website} of meld problemen op {github}."
    },
    "source_switch": {
        "live": "live",
        "dev": "dev"
    },
    "tag_reference": {
        "description": "Omschrijving",
        "on_wiki": "{tag} op wiki.osm.org",
        "used_with": "gebruikt met {type}"
    },
    "validations": {
        "untagged_point": "Punt zonder tags, dat geen onderdeel is van een lijn of vlak",
        "untagged_line": "Lijn zonder tags",
        "untagged_area": "Vlak zonder tags",
        "many_deletions": "You're deleting {n} objects. Are you sure you want to do this? This will delete them from the map that everyone else sees on openstreetmap.org.",
        "tag_suggests_area": "De tag {tag} suggereert dat de lijn een vlak is, maar het is geen vlak",
        "deprecated_tags": "Afgeschafte tags: {tags}"
    },
    "zoom": {
        "in": "Inzoomen",
        "out": "Uitzoomen"
    }
};
locale.fr = {
    "modes": {
        "add_area": {
            "title": "Polygone",
            "description": "Les polygones peuvent être des parcs, des batîments, des lacs ou tout autre objet surfacique.",
            "tail": "Cliquez sur la carte pour ajouter un polygone tel qu'un parc, un lac ou un bâtiment."
        },
        "add_line": {
            "title": "Ligne",
            "description": "Les lignes peuvent être des autoroutes, des routes, des chemins ou encore des caneaux.",
            "tail": "Cliquez sur la carte pour ajouter une nouvelle ligne telle qu'une route ou un nouveau chemin."
        },
        "add_point": {
            "title": "Point",
            "description": "Les points peuvent être des restaurants, des monuments, ou encore des boites aux lettres.",
            "tail": "Cliquez sur la carte pour ajouter un point tel qu'un restaurant ou un monument."
        },
        "browse": {
            "title": "Navigation",
            "description": "Naviguer ou zoomer sur la carte."
        },
        "draw_area": {
            "tail": "Cliquez pour ajouter un point à la zone. Cliquez sur le dernier point pour fermer la zone."
        },
        "draw_line": {
            "tail": "Cliquez pour ajouter un point à la ligne. Cliquez sur une autre ligne pour les connecter, puis faîtes un double-clique pour terminer la ligne."
        }
    },
    "operations": {
        "add": {
            "annotation": {
                "point": "Ajouter un point.",
                "vertex": "Ajouter un noeud à une ligne."
            }
        },
        "start": {
            "annotation": {
                "line": "Commencer une nouvelle ligne.",
                "area": "Commencer un polygone."
            }
        },
        "continue": {
            "annotation": {
                "line": "Continuer une ligne.",
                "area": "Continuer un polygone."
            }
        },
        "cancel_draw": {
            "annotation": "Annuler un ajout."
        },
        "change_tags": {
            "annotation": "Modifier les tags."
        },
        "circularize": {
            "title": "Arrondir",
            "description": "Créer un cercle.",
            "key": "O",
            "annotation": {
                "line": "Créer un cercle linéaire.",
                "area": "Créer un cercle surfacique (disque)."
            }
        },
        "orthogonalize": {
            "title": "Orthogonaliser",
            "description": "Rendre une forme orthogonale.",
            "key": "Q",
            "annotation": {
                "line": "Orthogonaliser une ligne orthogonale.",
                "area": "Orthogonaliser un polygone orthogonale."
            }
        },
        "delete": {
            "title": "Supprimer",
            "description": "Supprime l'élément de la carte.",
            "annotation": {
                "point": "Supprime un point.",
                "vertex": "Supprime le noeud d'une ligne.",
                "line": "Supprime une ligne.",
                "area": "Supprime un polygone.",
                "relation": "Supprime une relation.",
                "multiple": "Supprime {n} objets."
            }
        },
        "connect": {
            "annotation": {
                "point": "Joindre une ligne à un point.",
                "vertex": "Joindre les noeuds à une ligne.",
                "line": "Joindre les chemins ensemble.",
                "area": "Joindre une ligne à un polygone."
            }
        },
        "disconnect": {
            "title": "Séparer",
            "description": "Sépare les lignes l'une de l'autre.",
            "key": "D",
            "annotation": "Sépare les lignes."
        },
        "merge": {
            "title": "Fusionner",
            "description": "Fusionne les lignes.",
            "key": "C",
            "annotation": "Fusionne les {n} ligne."
        },
        "move": {
            "title": "Déplacer",
            "description": "Déplace l'élément à un autre endroit.",
            "key": "M",
            "annotation": {
                "point": "Déplace un point.",
                "vertex": "Déplace le noeud d'une ligne.",
                "line": "Déplace une ligne.",
                "area": "Déplace un polygone.",
                "multiple": "Déplace un groupe d'objets."
            }
        },
        "rotate": {
            "title": "Rotation",
            "description": "Fait pivoter cet objet en fonction de son centroïde.",
            "key": "R",
            "annotation": {
                "line": "Pivoter la ligne.",
                "area": "Pivoter un polyone."
            }
        },
        "reverse": {
            "title": "Inverser",
            "description": "Inverse le sens d'une ligne.",
            "key": "V",
            "annotation": "Inverse le sens d'une ligne."
        },
        "split": {
            "title": "Couper",
            "description": "Coupe une ligne en deux par rapport au point sélectionné.",
            "key": "X",
            "annotation": "Coupe une ligne."
        }
    },
    "nothing_to_undo": "Rien à annuler.",
    "nothing_to_redo": "Rien à refaire.",
    "just_edited": "Vous venez de participer à OpenStreetMap!",
    "browser_notice": "Les navigateurs supportés par cet éditeur sont : Firefox, Chrome, Safari, Opera et Internet Explorer (version 9 et supérieures). Pour éditer la carte, veuillez mettre à jour votre navigateur ou utiliser Potlatch 2.",
    "view_on_osm": "Consulter dans OSM",
    "zoom_in_edit": "Zoomer pour modifier la carte",
    "logout": "Déconnexion",
    "report_a_bug": "Signaler un bug",
    "commit": {
        "title": "Sauvegarder vos modifications",
        "description_placeholder": "Description succinte de vos contributions",
        "upload_explanation": "{user} : les modifications apportées seront visibles par l'ensemble des services utilisant les données d'OpenStreetMap.",
        "save": "Sauvegarder",
        "cancel": "Annuler",
        "warnings": "Attention",
        "modified": "Modifié",
        "deleted": "Supprimé",
        "created": "Créé"
    },
    "contributors": {
        "list": "Contributions réalisées par {users}",
        "truncated_list": "Contributions réalisées par {users} et {count} autres personnes"
    },
    "geocoder": {
        "title": "Trouver un emplacement",
        "placeholder": "Trouver un endroit",
        "no_results": "Impossible de localiser l'endroit nommé '{name}'"
    },
    "geolocate": {
        "title": "Me localiser"
    },
    "inspector": {
        "no_documentation_combination": "Aucune documentation n'est disponible pour cette combinaison de tag",
        "no_documentation_key": "Aucune documentation n'est disponible pour cette clé",
        "show_more": "Plus d'infornations",
        "new_tag": "Nouveau tag",
        "view_on_osm": "Visualiser sur OSM",
        "editing_feature": "Édition de {feature}",
        "additional": "Tags complémentaires",
        "choose": "Que souhaitez vous ajouter?",
        "results": "{n} résultats pour {search}",
        "reference": "Consulter sur le Wiki d'OpenStreetMap",
        "back_tooltip": "Changer le type de l'objet "
    },
    "background": {
        "title": "Fond de carte",
        "description": "Paramètres du fond de carte",
        "percent_brightness": "{opacity}% luminosité",
        "fix_misalignment": "Corriger le décalage",
        "reset": "réinitialiser"
    },
    "restore": {
        "description": "Vous avez des changements non sauvegardés d'une précédente édition. Souhaitez-vous restaurer ces changements?",
        "restore": "Restaurer",
        "reset": "Annuler"
    },
    "save": {
        "title": "Sauvegarder",
        "help": "Envoie des modifications au serveyr OpenStreetMap afin qu'elles soient visibles par les autres contributeurs.",
        "no_changes": "Aucune modification à sauvegarder",
        "error": "Une erreur est survenue lors de l'enregistrement des données",
        "uploading": "Envoie des modifications vers OpenStreetMap.",
        "unsaved_changes": "Vous avez des modifications non enregistrées"
    },
    "splash": {
        "welcome": "Bienvenue sur ID l'editeur en ligne d'OpenStreetMap",
        "text": "Cette version {version}, est une version de développement. Si vous souhaitez plus d'informations, veuillez consulter {website} ou pour signaler un bug   {github}."
    },
    "source_switch": {
        "live": "live",
        "dev": "dev"
    },
    "tag_reference": {
        "description": "Description",
        "on_wiki": "{tag} sur le wiki.osm.org",
        "used_with": "Utilisé avec {type}"
    },
    "validations": {
        "untagged_point": "Point sans aucun tag ne faisant partie ni d'une ligne, ni d'un polygone",
        "untagged_line": "Ligne sans aucun tag",
        "untagged_area": "Polygone sans aucun tag",
        "many_deletions": "You're deleting {n} objects. Are you sure you want to do this? This will delete them from the map that everyone else sees on openstreetmap.org.",
        "tag_suggests_area": "Ce tag {tag} suppose que cette ligne devrait être un polygone, or ce n'est pas le cas",
        "deprecated_tags": "Tags obsolètes : {tags}"
    },
    "zoom": {
        "in": "Zoomer",
        "out": "Dézoomer"
    },
    "imagery": {
        "provided_by": "Image provenant de {source}"
    },
    "gpx": {
        "local_layer": "Fichier GPX personnel",
        "drag_drop": "Glisser et déposer un fichier .gpx sur la page"
    },
    "presets": {
        "fields": {
            "address": {
                "label": "Adresse",
                "placeholders": {
                    "number": "123",
                    "street": "Rue",
                    "city": "Ville"
                }
            },
            "aeroway": {
                "label": "Type"
            },
            "amenity": {
                "label": "Type"
            },
            "bicycle_parking": {
                "label": "Type"
            },
            "building": {
                "label": "Bâtiment "
            },
            "building_area": {
                "label": "Bâtiment"
            },
            "building_yes": {
                "label": "Bâtiment"
            },
            "capacity": {
                "label": "Capacité"
            },
            "construction": {
                "label": "Type"
            },
            "crossing": {
                "label": "Type"
            },
            "cuisine": {
                "label": "Cuisine"
            },
            "denomination": {
                "label": "Denomination "
            },
            "elevation": {
                "label": "Elevation "
            },
            "entrance": {
                "label": "Type"
            },
            "fax": {
                "label": "Fax"
            },
            "highway": {
                "label": "Type"
            },
            "historic": {
                "label": "Type"
            },
            "internet_access": {
                "label": "Accès Internet",
                "options": {
                    "wlan": "Wifi"
                }
            },
            "landuse": {
                "label": "Type"
            },
            "layer": {
                "label": "Couche"
            },
            "leisure": {
                "label": "Type"
            },
            "levels": {
                "label": "Niveaux"
            },
            "man_made": {
                "label": "Type"
            },
            "maxspeed": {
                "label": "Limite de vitesse"
            },
            "note": {
                "label": "Note"
            },
            "office": {
                "label": "Type"
            },
            "oneway": {
                "label": "Sens unique"
            },
            "opening_hours": {
                "label": "Heures"
            },
            "operator": {
                "label": "Operateur "
            },
            "phone": {
                "label": "Telephone "
            },
            "place": {
                "label": "Type"
            },
            "railway": {
                "label": "Type"
            },
            "religion": {
                "label": "Religion",
                "options": {
                    "christian": "Christianisme",
                    "muslim": "Musulmane",
                    "buddhist": "Budhiste ",
                    "jewish": "Juive",
                    "hindu": "Indouiste ",
                    "taoist": "Taoiste "
                }
            },
            "service": {
                "label": "Type"
            },
            "shop": {
                "label": "Type"
            },
            "source": {
                "label": "Source"
            },
            "sport": {
                "label": "Sport"
            },
            "surface": {
                "label": "Surface"
            },
            "tourism": {
                "label": "Type"
            },
            "water": {
                "label": "Type"
            },
            "waterway": {
                "label": "Type"
            },
            "website": {
                "label": "Site Internet"
            },
            "wetland": {
                "label": "Type"
            },
            "wikipedia": {
                "label": "Wikipedia"
            },
            "wood": {
                "label": "Type"
            }
        },
        "presets": {
            "aeroway/aerodrome": {
                "name": "Aeroport "
            },
            "amenity/bank": {
                "name": "Banque"
            },
            "amenity/bar": {
                "name": "Bar"
            },
            "amenity/bicycle_parking": {
                "name": "Parc à velos "
            },
            "amenity/bicycle_rental": {
                "name": "Location de velos "
            },
            "amenity/cafe": {
                "name": "Cafe "
            },
            "amenity/cinema": {
                "name": "Cinema "
            },
            "amenity/fast_food": {
                "name": "Fast Food"
            },
            "amenity/fire_station": {
                "name": "Caserne de pompier"
            },
            "amenity/grave_yard": {
                "name": "Cimetière"
            },
            "amenity/hospital": {
                "name": "Hopital "
            },
            "amenity/library": {
                "name": "Bibliotheque "
            },
            "amenity/parking": {
                "name": "Parking "
            },
            "amenity/pharmacy": {
                "name": "Pharmacie"
            },
            "amenity/place_of_worship": {
                "name": "Lieu de culte"
            },
            "amenity/place_of_worship/christian": {
                "name": "Eglise "
            },
            "amenity/place_of_worship/jewish": {
                "name": "Cynagogue "
            },
            "amenity/place_of_worship/muslim": {
                "name": "Mosque "
            },
            "amenity/police": {
                "name": "Poste de police"
            },
            "amenity/post_box": {
                "name": "Boite aux lettres"
            },
            "amenity/pub": {
                "name": "Pub"
            },
            "amenity/restaurant": {
                "name": "Restaurant"
            },
            "amenity/school": {
                "name": "Ecole "
            },
            "amenity/toilets": {
                "name": "Toiletes "
            },
            "amenity/university": {
                "name": "Universite "
            },
            "building": {
                "name": "Batiment "
            },
            "entrance": {
                "name": "Entree "
            },
            "highway/bus_stop": {
                "name": "Arret de bus "
            },
            "highway/crossing": {
                "name": "Passage pieton "
            },
            "highway/primary": {
                "name": "Route principale"
            },
            "highway/residential": {
                "name": "Route residentielle "
            },
            "highway/secondary": {
                "name": "Route secondaire"
            },
            "highway/steps": {
                "name": "Escaliers"
            },
            "highway/tertiary": {
                "name": "Route tertiaire"
            },
            "highway/traffic_signals": {
                "name": "Feux tricolores"
            },
            "highway/turning_circle": {
                "name": "Rond point"
            },
            "historic": {
                "name": "Site historique"
            },
            "historic/monument": {
                "name": "Monument"
            },
            "landuse/cemetery": {
                "name": "Cimetiere "
            },
            "landuse/commercial": {
                "name": "Commerciale"
            },
            "landuse/construction": {
                "name": "Construction"
            },
            "landuse/farm": {
                "name": "Ferme"
            },
            "landuse/forest": {
                "name": "Forêt"
            },
            "landuse/grass": {
                "name": "Herbe"
            },
            "landuse/industrial": {
                "name": "Industrielle"
            },
            "landuse/residential": {
                "name": "Residentielle "
            },
            "leisure/golf_course": {
                "name": "Parcours de golf"
            },
            "leisure/park": {
                "name": "Parc"
            },
            "leisure/pitch/tennis": {
                "name": "Court de tennis"
            },
            "man_made/lighthouse": {
                "name": "Phare"
            },
            "natural/bay": {
                "name": "Baie"
            },
            "natural/beach": {
                "name": "Plage"
            },
            "natural/tree": {
                "name": "Arbre"
            },
            "natural/water/lake": {
                "name": "Lac"
            },
            "place/island": {
                "name": "Ile "
            },
            "place/village": {
                "name": "Village"
            },
            "shop": {
                "name": "Magasin"
            },
            "shop/butcher": {
                "name": "Boucher "
            },
            "shop/supermarket": {
                "name": "Supermarche "
            },
            "tourism": {
                "name": "Tourisme"
            },
            "tourism/museum": {
                "name": "Musee "
            }
        }
    }
};
locale.de = {
    "modes": {
        "add_area": {
            "title": "Fläche",
            "description": "Füge Parks, Gebäude, Seen oder andere Flächen zur Karte hinzu.",
            "tail": "Klicke in die Karte, um das Zeichnen einer Fläche wie einen Park, einen See oder Gebäude zu starten."
        },
        "add_line": {
            "title": "Linie",
            "description": "Linien können Autobahnen, Straßen, Fußwege oder sogar Kanäle sein.",
            "tail": "Klicke in die Karte, um das Zeichnen einer Straße eines Pfades oder einer Route zu starten."
        },
        "add_point": {
            "title": "Punkt",
            "description": "Restaurants, Denkmäler und Briefkästen sind Punkte",
            "tail": "Klicke in die Karte, um einen Punkt hinzuzufügen."
        },
        "browse": {
            "title": "Navigation",
            "description": "Verschieben und Vergrößern/Verkleinern des Kartenausschnitts."
        },
        "draw_area": {
            "tail": "Klicke, um Punkte zur Fläche hinzuzufügen. Klicke auf den ersten Punkt, um die Fläche abzuschließen."
        },
        "draw_line": {
            "tail": "Klicke, um mehr Punkte zur Linie hizuzufügen. Klicke auf eine andere Linie, um die Linien zu verbinden und klicke doppelt, um die Linie zu beenden."
        }
    },
    "operations": {
        "add": {
            "annotation": {
                "point": "Punkt hinzugefügt.",
                "vertex": "Stützpunkt einem Weg hinzugefügt."
            }
        },
        "start": {
            "annotation": {
                "line": "Linie begonnen.",
                "area": "Fläche begonnen."
            }
        },
        "continue": {
            "annotation": {
                "line": "Linie fortgesetzt.",
                "area": "Fläche fortgesetzt."
            }
        },
        "cancel_draw": {
            "annotation": "Zeichnen abgebrochen."
        },
        "change_tags": {
            "annotation": "Tags verändert."
        },
        "circularize": {
            "title": "Abrunden",
            "description": "Runde dies ab.",
            "key": "O",
            "annotation": {
                "line": "Runde eine Linie ab.",
                "area": "Runde eine Fläche ab."
            }
        },
        "orthogonalize": {
            "title": "Rechtwinkligkeit herstellen",
            "description": "Diese Ecken rechtwinklig ausrichten.",
            "key": "Q",
            "annotation": {
                "line": "Die Ecken einer Linie rechtwinklig ausgerichtet.",
                "area": "Die Ecken einer Fläche rechtwinklig ausgerichtet."
            }
        },
        "delete": {
            "title": "Löschen",
            "description": "Lösche dies aus der Karte.",
            "annotation": {
                "point": "Punkt gelöscht.",
                "vertex": "Stützpunkt aus einem Weg gelöscht.",
                "line": "Linie gelöscht.",
                "area": "Fläche gelöscht.",
                "relation": "Verbindung gelöscht.",
                "multiple": "{n} Objekte gelöscht."
            }
        },
        "connect": {
            "annotation": {
                "point": "Weg mit einem Punkt verbunden.",
                "vertex": "Weg mit einem anderem Weg verbunden.",
                "line": "Weg mit einer Linie verbunden.",
                "area": "Weg mit einer Fläche verbunden."
            }
        },
        "disconnect": {
            "title": "Trennen",
            "description": "Trenne diese Wege voneinander.",
            "key": "D",
            "annotation": "Wege getrennt."
        },
        "merge": {
            "title": "Vereinigen",
            "description": "Vereinige diese Linien.",
            "key": "C",
            "annotation": "{n} Linien vereinigt."
        },
        "move": {
            "title": "Verschieben",
            "description": "Verschiebe dieses Objekt an einen anderen Ort.",
            "key": "M",
            "annotation": {
                "point": "Punkt verschoben.",
                "vertex": "Stützpunkt in einen Weg veschoben.",
                "line": "Linie verschoben.",
                "area": "Fläche verschoben.",
                "multiple": "Mehrere Objekte verschoben."
            }
        },
        "rotate": {
            "title": "Drehen",
            "description": "Dieses Objekt um seinen Mittelpunkt drehen.",
            "key": "R",
            "annotation": {
                "line": "Linie gedreht.",
                "area": "Fläche gedreht."
            }
        },
        "reverse": {
            "title": "Umkehren",
            "description": "Ändere die Richtung dieser Linie.",
            "key": "V",
            "annotation": "Linienrichtung umgekehrt."
        },
        "split": {
            "title": "Teilen",
            "description": "Teile dies in zwei Wege an diesem Punkt.",
            "key": "X",
            "annotation": "Weg geteilt."
        }
    },
    "nothing_to_undo": "Nichts zum Rückgängigmachen.",
    "nothing_to_redo": "Nichts zum Wiederherstellen.",
    "just_edited": "Sie haben gerade OpenStreetMap editiert!",
    "browser_notice": "Dieser Editor wird von Firefox, Chrome, Safari, Opera, und Internet Explorer (Version 9 und höher) unterstützt. Bitte aktualisieren Sie Ihren Browser oder nutzen Sie Potlatch 2, um die Karte zu modifizieren.",
    "view_on_osm": "Auf OpenStreetMap anschauen",
    "zoom_in_edit": "Hineinzoomen, um die Karte zu bearbeiten",
    "logout": "Abmelden",
    "report_a_bug": "Programmfehler melden",
    "commit": {
        "title": "Änderungen speichern",
        "description_placeholder": "Eine kurze Beschreibung deiner Beiträge",
        "upload_explanation": "Änderungen, die du als {user} hochlädst werden sichtbar auf allen Karte, die OpenStreetMap nutzen.",
        "save": "Speichern",
        "cancel": "Abbrechen",
        "warnings": "Warnungen",
        "modified": "Verändert",
        "deleted": "Gelöscht",
        "created": "Erstellt"
    },
    "contributors": {
        "list": "Diese Kartenansicht enthält Beiträge von:",
        "truncated_list": "Diese Kartenansicht enthält Beiträge von: {users} und {count} anderen"
    },
    "geocoder": {
        "title": "Suche einen Ort",
        "placeholder": "suche einen Ort",
        "no_results": "Der Ort '{name}' konnte nicht gefunden werden"
    },
    "geolocate": {
        "title": "Zeige meine Position"
    },
    "inspector": {
        "no_documentation_combination": "Für dieses Attribut ist keine Dokumentation verfügbar.",
        "no_documentation_key": "Für dises Schlüsselwort ist keine Dokumentation verfügbar",
        "show_more": "Zeige mehr",
        "new_tag": "Neues Attribut",
        "view_on_osm": "auf OpenStreetMap ansehen",
        "editing_feature": "In Bearbeitung {feature}",
        "additional": "Weitere Merkmale",
        "choose": "Eigenschafts-Typ auswählen",
        "results": "{n} Resultate für {search}",
        "reference": "In der OpenSteetMap Wiki anschauen →",
        "back_tooltip": "Eigenschafts-Typ ändern"
    },
    "background": {
        "title": "Hintergrund",
        "description": "Hintergrundeinstellungen",
        "percent_brightness": "{opacity}% Helligkeit",
        "fix_misalignment": "Fehlerhafte Ausrichtung reparieren",
        "reset": "Zurücksetzen"
    },
    "restore": {
        "description": "Es gibt ungespeicherte Änderungen aus einer vorherigen Sitzung. Möchtest du diese Änderungen wiederherstellen?",
        "restore": "Wiederherstellen",
        "reset": "Zurücksetzen"
    },
    "save": {
        "title": "Speichern",
        "help": "Speichere Änderungen auf OpenStreetMap, um diese für andere Nutzer sichtbar zu machen.",
        "no_changes": "Keine zu speichernden Änderungen.",
        "error": "Beim Speichern ist ein Fehler aufgetreten",
        "uploading": "Änderungen werden zu OpenStreetMap hochgeladen.",
        "unsaved_changes": "Ungespeicherte Änderungen vorhanden"
    },
    "splash": {
        "welcome": "Willkommen beim iD OpenStreetMap-Editor",
        "text": "Dies ist eine Entwicklungsversion {version}. Für weitere Informationen besuche {website} und melde Fehler unter {github}."
    },
    "source_switch": {
        "live": "live",
        "dev": "dev"
    },
    "tag_reference": {
        "description": "Beschreibung",
        "on_wiki": "{tag} auf wiki.osm.org",
        "used_with": "benutzt mit {type}"
    },
    "validations": {
        "untagged_point": "Punkt ohne Attribute, der kein Teil einer Linie oder Fläche ist",
        "untagged_line": "Linie ohne Attribute",
        "untagged_area": "Fläche ohne Attribute",
        "many_deletions": "You're deleting {n} objects. Are you sure you want to do this? This will delete them from the map that everyone else sees on openstreetmap.org.",
        "tag_suggests_area": "Das Attribut {tag} suggeriert eine Fläche, ist aber keine Fläche",
        "deprecated_tags": "Veraltete Attribute: {tags}"
    },
    "zoom": {
        "in": "Hineinzoomen",
        "out": "Herauszoomen"
    },
    "imagery": {
        "provided_by": "Bilddaten von {source}"
    },
    "presets": {
        "fields": {
            "access": {
                "label": "Zugang"
            },
            "address": {
                "label": "Adresse",
                "placeholders": {
                    "housename": "Hausname",
                    "number": "123",
                    "street": "Straße",
                    "city": "Stadt"
                }
            },
            "aeroway": {
                "label": "Typ"
            },
            "atm": {
                "label": "Geldautomat"
            },
            "building": {
                "label": "Gebäude"
            },
            "capacity": {
                "label": "Kapazität"
            },
            "fax": {
                "label": "Fax"
            },
            "internet_access": {
                "label": "Internetzugang",
                "options": {
                    "wlan": "Wifi"
                }
            },
            "levels": {
                "label": "Etagen"
            },
            "maxspeed": {
                "label": "Höchstgeschwindigkeit"
            },
            "note": {
                "label": "Notiz"
            },
            "oneway": {
                "label": "Einbahnstraße"
            },
            "phone": {
                "label": "Telefon"
            },
            "religion": {
                "label": "Religion"
            },
            "source": {
                "label": "Quelle"
            },
            "sport": {
                "label": "Sport"
            },
            "surface": {
                "label": "Oberfläche"
            },
            "website": {
                "label": "Webseite"
            },
            "wikipedia": {
                "label": "Wikipedia"
            }
        },
        "presets": {
            "aeroway/aerodrome": {
                "name": "Flughafen"
            },
            "aeroway/helipad": {
                "name": "Hubschrauberlandeplatz"
            },
            "amenity/bank": {
                "name": "Bank"
            },
            "amenity/bar": {
                "name": "Bar"
            },
            "amenity/bench": {
                "name": "Bank"
            },
            "amenity/bicycle_parking": {
                "name": "Fahrradparkplatz"
            },
            "amenity/bicycle_rental": {
                "name": "Fahrradverleih"
            },
            "amenity/cinema": {
                "name": "Kino"
            },
            "amenity/fuel": {
                "name": "Tankstelle"
            },
            "amenity/grave_yard": {
                "name": "Friedhof"
            },
            "amenity/hospital": {
                "name": "Krankenhaus"
            },
            "amenity/library": {
                "name": "Bibliothek"
            },
            "amenity/parking": {
                "name": "Parkplatz"
            },
            "amenity/pharmacy": {
                "name": "Apotheke"
            },
            "amenity/place_of_worship/christian": {
                "name": "Kirche"
            },
            "amenity/place_of_worship/muslim": {
                "name": "Moschee"
            },
            "amenity/police": {
                "name": "Polizei"
            },
            "amenity/post_box": {
                "name": "Briefkasten"
            },
            "amenity/pub": {
                "name": "Pub"
            },
            "amenity/restaurant": {
                "name": "Restaurant"
            },
            "amenity/school": {
                "name": "Schule"
            },
            "amenity/telephone": {
                "name": "Telefon"
            },
            "amenity/toilets": {
                "name": "Toilette"
            },
            "amenity/townhall": {
                "name": "Rathaus"
            },
            "amenity/university": {
                "name": "Universität"
            },
            "entrance": {
                "name": "Eingang"
            },
            "highway": {
                "name": "Straße/Weg"
            },
            "highway/bus_stop": {
                "name": "Bushaltestelle"
            },
            "highway/crossing": {
                "name": "Fußgängerüberweg"
            },
            "highway/cycleway": {
                "name": "Radweg"
            },
            "highway/footway": {
                "name": "Fußweg"
            },
            "highway/path": {
                "name": "Pfad"
            },
            "highway/steps": {
                "name": "Treppen"
            },
            "highway/track": {
                "name": "Feld-/Waldweg"
            },
            "highway/traffic_signals": {
                "name": "Ampeln"
            },
            "highway/turning_circle": {
                "name": "Wendestelle"
            },
            "historic": {
                "name": "Historische Stätte"
            },
            "historic/monument": {
                "name": "Monument"
            },
            "landuse/allotments": {
                "name": "Kleigartenanlage"
            },
            "landuse/forest": {
                "name": "Wald"
            },
            "landuse/grass": {
                "name": "Gras"
            },
            "landuse/industrial": {
                "name": "Industrie"
            },
            "landuse/meadow": {
                "name": "Weide"
            },
            "landuse/residential": {
                "name": "Wohngebiet"
            },
            "leisure/golf_course": {
                "name": "Golfplatz"
            },
            "leisure/park": {
                "name": "Park"
            },
            "leisure/pitch/american_football": {
                "name": "American Football Feld"
            },
            "leisure/pitch/basketball": {
                "name": "Basketballfeld"
            },
            "leisure/pitch/soccer": {
                "name": "Fußballplatz"
            },
            "leisure/pitch/tennis": {
                "name": "Tennisplatz"
            },
            "leisure/playground": {
                "name": "Spieplatz"
            },
            "natural/beach": {
                "name": "Strand"
            },
            "natural/cliff": {
                "name": "Klippe"
            },
            "natural/coastline": {
                "name": "Küstenlinie"
            },
            "natural/glacier": {
                "name": "Gletscher"
            },
            "natural/scrub": {
                "name": "Gestrübb"
            },
            "natural/spring": {
                "name": "Quelle"
            },
            "natural/tree": {
                "name": "Baum"
            },
            "natural/water": {
                "name": "Wasser"
            },
            "natural/water/lake": {
                "name": "See"
            },
            "natural/water/pond": {
                "name": "Teich"
            },
            "natural/wood": {
                "name": "Wald"
            },
            "office": {
                "name": "Büro"
            },
            "place/island": {
                "name": "Insel"
            },
            "place/village": {
                "name": "Dorf"
            },
            "railway": {
                "name": "Eisenbahn"
            },
            "railway/subway": {
                "name": "U-Bahn"
            },
            "shop/butcher": {
                "name": "Fleischer"
            },
            "shop/supermarket": {
                "name": "Supermarkt"
            },
            "tourism": {
                "name": "Tourismus"
            },
            "tourism/artwork": {
                "name": "Kunst"
            },
            "tourism/attraction": {
                "name": "Touristenattracktion"
            },
            "tourism/camp_site": {
                "name": "Campingplatz"
            },
            "tourism/hotel": {
                "name": "Hotel"
            },
            "tourism/information": {
                "name": "Information"
            },
            "tourism/museum": {
                "name": "Museum"
            },
            "tourism/picnic_site": {
                "name": "Picknickplatz"
            },
            "tourism/theme_park": {
                "name": "Themenpark"
            },
            "tourism/zoo": {
                "name": "Zoo"
            },
            "waterway/canal": {
                "name": "Kanal"
            },
            "waterway/dam": {
                "name": "Damm"
            },
            "waterway/river": {
                "name": "Fluss"
            },
            "waterway/stream": {
                "name": "Bach"
            },
            "waterway/weir": {
                "name": "Wehr"
            }
        }
    }
};
locale.it = {
    "modes": {
        "add_area": {
            "title": "Area",
            "description": "Aggiungi parchi, edifici, laghi, o altre aree alla mappa.",
            "tail": "Clicca sulla mappa per iniziare a disegnare un'area, come un parco, un lago, o un edificio."
        },
        "add_line": {
            "title": "Linea",
            "description": "Aggiungi strade, vie, percorsi pedonali, canali od altre linee alla mappa.",
            "tail": "Clicca sulla mappa per iniziare a disegnare una strada, un percorso, o un itinerario."
        },
        "add_point": {
            "title": "Punto",
            "description": "Ristoranti, monumenti, e cassette postali sono punti.",
            "tail": "Clicca sulla mappa per inserire un punto."
        },
        "browse": {
            "title": "Naviga",
            "description": "Muovi ed ingrandisci la mappa."
        },
        "draw_area": {
            "tail": "Clicca per aggiungere punti all'area. Clicca sul primo punto per completarla."
        },
        "draw_line": {
            "tail": "Clicca per aggiungere più punti alla linea. Clicca su altre linee per connetterle, e clicca due volte per terminare la linea."
        }
    },
    "operations": {
        "add": {
            "annotation": {
                "point": "Aggiunto un punto.",
                "vertex": "Aggiunto un punto ad una linea."
            }
        },
        "start": {
            "annotation": {
                "line": "Iniziata una linea.",
                "area": "Iniziata un'area."
            }
        },
        "continue": {
            "annotation": {
                "line": "Continuata una linea.",
                "area": "Continuata un'area."
            }
        },
        "cancel_draw": {
            "annotation": "Cancellato il disegno."
        },
        "change_tags": {
            "annotation": "Cambiati i tag."
        },
        "circularize": {
            "title": "Rendi rotondo",
            "description": "Fallo diventare rotondo.",
            "key": "O",
            "annotation": {
                "line": "Linea resa rotonda.",
                "area": "Area resa rotonda."
            }
        },
        "orthogonalize": {
            "title": "Ortogonalizza",
            "description": "Ortogonalizza questi angoli.",
            "key": "Q",
            "annotation": {
                "line": "Gli angoli della linea sono stati resi ortogonali.",
                "area": "Gli angoli dell'area sono stati resi ortogonali."
            }
        },
        "delete": {
            "title": "Cancella",
            "description": "Cancella questo dalla mappa.",
            "annotation": {
                "point": "Cancellato un punto.",
                "vertex": "Cancellato un punto da una linea.",
                "line": "Cancellata una linea.",
                "area": "Cancellata un'area.",
                "relation": "Cancellata una relazione.",
                "multiple": "Cancellati {n} oggetti."
            }
        },
        "connect": {
            "annotation": {
                "point": "Connessa una linea ad un punto.",
                "vertex": "Connessa una linea ad un'altra.",
                "line": "Connessa una strada ad una linea.",
                "area": "Connessa una linea ad un'area."
            }
        },
        "disconnect": {
            "title": "Disconnetti",
            "description": "Disconnetti queste linee tra loro.",
            "key": "D",
            "annotation": "Linee disconnesse."
        },
        "merge": {
            "title": "Unisci",
            "description": "Unisci queste linee.",
            "key": "C",
            "annotation": "Unite {n} linee."
        },
        "move": {
            "title": "Muovi",
            "description": "Muovi questo in una posizione differente.",
            "key": "M",
            "annotation": {
                "point": "Mosso un punto.",
                "vertex": "Mosso un nodo su una linea.",
                "line": "Mossa una linea.",
                "area": "Mossa un'area.",
                "multiple": "Spostati diversi oggetti."
            }
        },
        "rotate": {
            "title": "Ruota",
            "description": "Ruota questo oggetto intorno al suo centro.",
            "key": "R",
            "annotation": {
                "line": "Ruotata una linea.",
                "area": "Ruotata un'area."
            }
        },
        "reverse": {
            "title": "Cambia direzione",
            "description": "Fai andare questa linea nella direzione opposta.",
            "key": "V",
            "annotation": "Cambiata direzione ad una linea."
        },
        "split": {
            "title": "Dividi",
            "description": "Dividi in questo punto le due linee.",
            "key": "X",
            "annotation": "Divisa una linea."
        }
    },
    "nothing_to_undo": "Niente da ripristinare.",
    "nothing_to_redo": "Niente da rifare.",
    "just_edited": "Hai appena modificato OpenStreetMap!",
    "browser_notice": "Questo editor è supportato in Firefox, Chrome, Safari, Opera, e Internet Explorer 9 e superiori. Aggiorna il tuo browser o usa Potlatch 2 per modificare la mappa.",
    "view_on_osm": "Guarda su OSM",
    "zoom_in_edit": "ingrandisci per modificare la mappa",
    "logout": "logout",
    "report_a_bug": "segnala un bug",
    "commit": {
        "title": "Salva le modifiche",
        "description_placeholder": "Una breve descrizione delle tue modifiche",
        "upload_explanation": "I cambiamenti che carichi come {user} saranno visibili su tutte le mappe che usano i dati di OpenStreetMap.",
        "save": "Salva",
        "cancel": "Annulla",
        "warnings": "Avvertimenti",
        "modified": "Modificati",
        "deleted": "Cancellati",
        "created": "Creati"
    },
    "contributors": {
        "list": "Stai vedendo i contributi di {users}",
        "truncated_list": "Stai vedendo i contributi di {users} ed altri {count}"
    },
    "geocoder": {
        "title": "Trova un luogo",
        "placeholder": "Trova un luogo",
        "no_results": "Non trovo un luogo chiamato '{name}'"
    },
    "geolocate": {
        "title": "Mostra la mia posizione"
    },
    "inspector": {
        "no_documentation_combination": "Non c'è documentazione per questa combinazione di tag",
        "no_documentation_key": "Non c'è documentazione per questa chiave",
        "show_more": "Mostra di più",
        "new_tag": "Nuovo Tag",
        "view_on_osm": "Mostra su OSM",
        "additional": "Tag aggiuntivi",
        "choose": "Seleziona il tipo di caratteristica",
        "results": "{n} risultati per {search}",
        "reference": "Vedi sulla Wiki di OpenStreetMap →",
        "back_tooltip": "Cambia il tipo di caratteristica"
    },
    "background": {
        "title": "Sfondo",
        "description": "Impostazioni dello sfondo",
        "percent_brightness": "{opacity}% luminosità",
        "fix_misalignment": "Allinea",
        "reset": "reset"
    },
    "restore": {
        "description": "Hai modifiche non salvate da una sessione precedente. Vuoi ripristinare questi cambiamenti?",
        "restore": "Ripristina",
        "reset": "Reset"
    },
    "save": {
        "title": "Salva",
        "help": "Salva i cambiamenti su OpenStreetMap, rendendoli visibili ad altri utenti.",
        "no_changes": "Nessuna modifica da salvare.",
        "error": "E' accaduto un errore mentre veniva tentato il salvataggio",
        "uploading": "Caricamento delle modifiche su OpenStreetMap.",
        "unsaved_changes": "Hai modifiche non salvate"
    },
    "splash": {
        "welcome": "Benvenuti nell'editor OpenStreetMap iD",
        "text": "Questa è la versione di sviluppo {version}. Per maggiori informazioni vedi {website} e segnala i bug su {github}."
    },
    "source_switch": {
        "live": "live",
        "dev": "dev"
    },
    "tag_reference": {
        "description": "Descrizione",
        "on_wiki": "{tag} su wiki.osm.org",
        "used_with": "usato con {type}"
    },
    "validations": {
        "untagged_point": "Punto senza tag che non è parte di una linea o di un'area",
        "untagged_line": "Linea senza tag",
        "untagged_area": "Area senza tag",
        "many_deletions": "You're deleting {n} objects. Are you sure you want to do this? This will delete them from the map that everyone else sees on openstreetmap.org.",
        "tag_suggests_area": "Il tag {tag} fa pensare che la linea sia un'area, ma non rappresenta un'area",
        "deprecated_tags": "Tag deprecati: {tags}"
    },
    "zoom": {
        "in": "Ingrandisci",
        "out": "Riduci"
    },
    "presets": {
        "fields": {
            "access": {
                "label": "Accesso"
            },
            "address": {
                "label": "Indirizzo",
                "placeholders": {
                    "housename": "Nome della casa",
                    "number": "123",
                    "street": "Strada",
                    "city": "Città"
                }
            },
            "aeroway": {
                "label": "Tipo"
            },
            "amenity": {
                "label": "Tipo"
            },
            "atm": {
                "label": "Bancomat"
            },
            "bicycle_parking": {
                "label": "Tipo"
            },
            "building": {
                "label": "Edificio"
            },
            "building_area": {
                "label": "Edificio"
            },
            "building_yes": {
                "label": "Edificio"
            },
            "capacity": {
                "label": "Capienza"
            },
            "collection_times": {
                "label": "Orari di raccolta"
            },
            "construction": {
                "label": "Tipo"
            },
            "crossing": {
                "label": "Tipo"
            },
            "cuisine": {
                "label": "Cucina"
            },
            "denomination": {
                "label": "Confessione"
            },
            "denotation": {
                "label": "Denotazione"
            },
            "elevation": {
                "label": "Altitudine"
            },
            "emergency": {
                "label": "Emergenza"
            },
            "entrance": {
                "label": "Tipo"
            },
            "fax": {
                "label": "Fax"
            },
            "fee": {
                "label": "Tariffa"
            },
            "highway": {
                "label": "Tipo"
            },
            "historic": {
                "label": "Tipo"
            },
            "internet_access": {
                "label": "Accesso ad Internet",
                "options": {
                    "wlan": "Wifi",
                    "wired": "Via cavo",
                    "terminal": "Terminale"
                }
            },
            "landuse": {
                "label": "Tipo"
            },
            "layer": {
                "label": "Livello"
            },
            "leisure": {
                "label": "Tipo"
            },
            "levels": {
                "label": "Piani"
            },
            "man_made": {
                "label": "Tipo"
            },
            "maxspeed": {
                "label": "Limite di velocità"
            },
            "natural": {
                "label": "Naturale"
            },
            "network": {
                "label": "Rete"
            },
            "note": {
                "label": "Nota"
            },
            "office": {
                "label": "Tipo"
            },
            "oneway": {
                "label": "Senso unico"
            },
            "opening_hours": {
                "label": "Ore"
            },
            "operator": {
                "label": "Operatore"
            },
            "phone": {
                "label": "Telefono"
            },
            "place": {
                "label": "Tipo"
            },
            "railway": {
                "label": "Tipo"
            },
            "ref": {
                "label": "Riferimento"
            },
            "religion": {
                "label": "Religione",
                "options": {
                    "christian": "Cristiana",
                    "muslim": "Musulmana",
                    "buddhist": "Buddista",
                    "jewish": "Ebraica",
                    "hindu": "Indù",
                    "shinto": "Shintoista",
                    "taoist": "Taoista"
                }
            },
            "service": {
                "label": "Tipo"
            },
            "shelter": {
                "label": "Riparo"
            },
            "shop": {
                "label": "Tipo"
            },
            "source": {
                "label": "Fonte"
            },
            "sport": {
                "label": "Sport"
            },
            "surface": {
                "label": "Superficie"
            },
            "tourism": {
                "label": "Tipo"
            },
            "water": {
                "label": "Tipo"
            },
            "waterway": {
                "label": "Tipo"
            },
            "website": {
                "label": "Sito web"
            },
            "wetland": {
                "label": "Tipo"
            },
            "wikipedia": {
                "label": "Wikipedia"
            },
            "wood": {
                "label": "Tipo"
            }
        },
        "presets": {
            "aeroway": {
                "name": "Pista aeroportuale"
            },
            "aeroway/aerodrome": {
                "name": "Aeroporto"
            },
            "aeroway/helipad": {
                "name": "Elisuperficie"
            },
            "amenity": {
                "name": "Servizi"
            },
            "amenity/bank": {
                "name": "Banca"
            },
            "amenity/bar": {
                "name": "Bar"
            },
            "amenity/bench": {
                "name": "Panchina"
            },
            "amenity/bicycle_parking": {
                "name": "Parcheggio biciclette"
            },
            "amenity/bicycle_rental": {
                "name": "Noleggio biciclette"
            },
            "amenity/cafe": {
                "name": "Caffè"
            },
            "amenity/cinema": {
                "name": "Cinema"
            },
            "amenity/fast_food": {
                "name": "Fast Food"
            },
            "amenity/fire_station": {
                "name": "Caserma dei pompieri"
            },
            "amenity/fuel": {
                "name": "Stazione di servizio"
            },
            "amenity/grave_yard": {
                "name": "Cimitero"
            },
            "amenity/hospital": {
                "name": "Ospedale"
            },
            "amenity/library": {
                "name": "Biblioteca"
            },
            "amenity/parking": {
                "name": "Parcheggio"
            },
            "amenity/pharmacy": {
                "name": "Farmacia"
            },
            "amenity/place_of_worship": {
                "name": "Luogo di culto"
            },
            "amenity/place_of_worship/christian": {
                "name": "Chiesa"
            },
            "amenity/place_of_worship/jewish": {
                "name": "Sinagoga"
            },
            "amenity/place_of_worship/muslim": {
                "name": "Moschea"
            },
            "amenity/police": {
                "name": "Forze di polizia"
            },
            "amenity/post_box": {
                "name": "Buca delle lettere"
            },
            "amenity/post_office": {
                "name": "Ufficio Postale"
            },
            "amenity/pub": {
                "name": "Pub"
            },
            "amenity/restaurant": {
                "name": "Ristorante"
            },
            "amenity/school": {
                "name": "Scuola"
            },
            "amenity/swimming_pool": {
                "name": "Piscina"
            },
            "amenity/telephone": {
                "name": "Telefono"
            },
            "amenity/toilets": {
                "name": "Bagni"
            },
            "amenity/townhall": {
                "name": "Municipio"
            },
            "amenity/university": {
                "name": "Università"
            },
            "building": {
                "name": "Edificio"
            },
            "entrance": {
                "name": "Entrata"
            },
            "highway": {
                "name": "Strada"
            },
            "highway/bus_stop": {
                "name": "Fermata dell'autobus"
            },
            "highway/crossing": {
                "name": "Attraversamento"
            },
            "highway/cycleway": {
                "name": "Percorso ciclabile"
            },
            "highway/footway": {
                "name": "Percorso pedonale"
            },
            "highway/motorway": {
                "name": "Autostrada"
            },
            "highway/path": {
                "name": "Sentiero"
            },
            "highway/primary": {
                "name": "Strada di importanza nazionale"
            },
            "highway/residential": {
                "name": "Strada residenziale"
            },
            "highway/secondary": {
                "name": "Strada di importanza regionale"
            },
            "highway/service": {
                "name": "Strada di servizio"
            },
            "highway/steps": {
                "name": "Scale"
            },
            "highway/tertiary": {
                "name": "Strada di importanza locale"
            },
            "highway/track": {
                "name": "Strada ad uso agricolo / forestale"
            },
            "highway/traffic_signals": {
                "name": "Semaforo"
            },
            "highway/trunk": {
                "name": "Superstrada"
            },
            "highway/turning_circle": {
                "name": "Slargo per inversione"
            },
            "highway/unclassified": {
                "name": "Viabilità ordinaria"
            },
            "historic": {
                "name": "Sito storico"
            },
            "historic/monument": {
                "name": "Monumento"
            },
            "landuse": {
                "name": "Uso del suolo"
            },
            "landuse/allotments": {
                "name": "Orti in concessione"
            },
            "landuse/basin": {
                "name": "Bacino"
            },
            "landuse/cemetery": {
                "name": "Cimitero"
            },
            "landuse/commercial": {
                "name": "Commerciale"
            },
            "landuse/construction": {
                "name": "Costruzione"
            },
            "landuse/farm": {
                "name": "Agricolo"
            },
            "landuse/farmyard": {
                "name": "Fattoria"
            },
            "landuse/forest": {
                "name": "Foresta"
            },
            "landuse/grass": {
                "name": "Erba"
            },
            "landuse/industrial": {
                "name": "Industriale"
            },
            "landuse/meadow": {
                "name": "Coltivazione erbacea"
            },
            "landuse/orchard": {
                "name": "Frutteto"
            },
            "landuse/quarry": {
                "name": "Cava"
            },
            "landuse/residential": {
                "name": "Residenziale"
            },
            "landuse/vineyard": {
                "name": "Vigneto"
            },
            "leisure": {
                "name": "Svago"
            },
            "leisure/garden": {
                "name": "Giardino"
            },
            "leisure/golf_course": {
                "name": "Campo da Golf"
            },
            "leisure/park": {
                "name": "Parco"
            },
            "leisure/pitch": {
                "name": "Campo da gioco"
            },
            "leisure/pitch/american_football": {
                "name": "Campo da Football Americano"
            },
            "leisure/pitch/baseball": {
                "name": "Diamante da Baseball"
            },
            "leisure/pitch/basketball": {
                "name": "Campo da basket"
            },
            "leisure/pitch/soccer": {
                "name": "Campo di calcio"
            },
            "leisure/pitch/tennis": {
                "name": "Campo da tennis"
            },
            "leisure/playground": {
                "name": "Campetto"
            },
            "leisure/swimming_pool": {
                "name": "Piscina"
            },
            "man_made": {
                "name": "Costruzioni civili"
            },
            "man_made/lighthouse": {
                "name": "Faro"
            },
            "man_made/pier": {
                "name": "Molo"
            },
            "man_made/survey_point": {
                "name": "Punto geodetico"
            },
            "man_made/water_tower": {
                "name": "Torre Idrica"
            },
            "natural": {
                "name": "Naturale"
            },
            "natural/bay": {
                "name": "Baia"
            },
            "natural/beach": {
                "name": "Spiaggia"
            },
            "natural/cliff": {
                "name": "Scogliera"
            },
            "natural/coastline": {
                "name": "Linea di costa"
            },
            "natural/glacier": {
                "name": "Ghiacciaio"
            },
            "natural/grassland": {
                "name": "Prateria"
            },
            "natural/heath": {
                "name": "Brughiera"
            },
            "natural/peak": {
                "name": "Picco"
            },
            "natural/scrub": {
                "name": "Macchia mediterranea"
            },
            "natural/spring": {
                "name": "Sorgente"
            },
            "natural/tree": {
                "name": "Albero"
            },
            "natural/water": {
                "name": "Specchio d'acqua"
            },
            "natural/water/lake": {
                "name": "Lago"
            },
            "natural/water/pond": {
                "name": "Stagno"
            },
            "natural/water/reservoir": {
                "name": "Bacino idrico"
            },
            "natural/wetland": {
                "name": "Zona umida"
            },
            "natural/wood": {
                "name": "Foresta"
            },
            "office": {
                "name": "Uffici"
            },
            "place": {
                "name": "Luogo"
            },
            "place/hamlet": {
                "name": "Paese"
            },
            "place/island": {
                "name": "Isola"
            },
            "place/locality": {
                "name": "Località"
            },
            "place/village": {
                "name": "Villaggio"
            },
            "power/sub_station": {
                "name": "Sottostazione"
            },
            "railway": {
                "name": "Ferrovia"
            },
            "railway/level_crossing": {
                "name": "Passaggio a livello"
            },
            "railway/rail": {
                "name": "Binario"
            },
            "railway/subway": {
                "name": "Metropolitana"
            },
            "railway/subway_entrance": {
                "name": "Entrata di metropolitana"
            },
            "shop": {
                "name": "Negozio"
            },
            "shop/butcher": {
                "name": "Macellaio"
            },
            "shop/supermarket": {
                "name": "Supermercato"
            },
            "tourism": {
                "name": "Turismo"
            },
            "tourism/alpine_hut": {
                "name": "Rifugio"
            },
            "tourism/artwork": {
                "name": "Opera d'arte"
            },
            "tourism/attraction": {
                "name": "Attrazione turistica"
            },
            "tourism/camp_site": {
                "name": "Campeggio"
            },
            "tourism/caravan_site": {
                "name": "Sosta per camper"
            },
            "tourism/chalet": {
                "name": "Chalet"
            },
            "tourism/guest_house": {
                "name": "Affittacamere"
            },
            "tourism/hostel": {
                "name": "Ostello"
            },
            "tourism/hotel": {
                "name": "Albergo"
            },
            "tourism/information": {
                "name": "Informazioni"
            },
            "tourism/motel": {
                "name": "Motel"
            },
            "tourism/museum": {
                "name": "Museo"
            },
            "tourism/picnic_site": {
                "name": "Area picnic"
            },
            "tourism/theme_park": {
                "name": "Parco a tema"
            },
            "tourism/viewpoint": {
                "name": "Punto panoramico"
            },
            "tourism/zoo": {
                "name": "Zoo"
            },
            "waterway": {
                "name": "Corso d'acqua"
            },
            "waterway/canal": {
                "name": "Canale"
            },
            "waterway/dam": {
                "name": "Diga"
            },
            "waterway/ditch": {
                "name": "Fossato"
            },
            "waterway/drain": {
                "name": "Canale di scolo"
            },
            "waterway/river": {
                "name": "Fiume"
            },
            "waterway/riverbank": {
                "name": "Argine"
            },
            "waterway/stream": {
                "name": "Torrente"
            },
            "waterway/weir": {
                "name": "Sbarramento"
            }
        }
    }
};
locale.ja = {
    "modes": {
        "add_area": {
            "title": "エリア",
            "description": "公園や建物、湖沼等をマップに追加",
            "tail": "クリックした地点から公園や湖沼、建物など、エリアの描画を行います"
        },
        "add_line": {
            "title": "ライン",
            "description": "道路や歩道、用水路などのラインを描画",
            "tail": "クリックした地点から道路や歩道、流水経路など、ラインの描画を開始します"
        },
        "add_point": {
            "title": "ポイント",
            "description": "レストランや記念碑、郵便ボックス等、ポイント情報を追加",
            "tail": "クリックした地点にポイントを追加します"
        },
        "browse": {
            "title": "ブラウズ",
            "description": "マップの拡大縮小"
        },
        "draw_area": {
            "tail": "クリックするとエリア上にポイントを追加できます。ラインの起点となっているポイントをクリックするとエリアが作成されます"
        },
        "draw_line": {
            "tail": "クリックするとライン上にポイントを追加できます。ラインを描画中に他のラインをクリックすることで、2つのラインを接続することが可能です。描画を終了するにはダブルクリックしてください"
        }
    },
    "operations": {
        "add": {
            "annotation": {
                "point": "ポイントの追加",
                "vertex": "ウェイへのノード追加"
            }
        },
        "start": {
            "annotation": {
                "line": "ラインの描画開始",
                "area": "エリアの描画開始"
            }
        },
        "continue": {
            "annotation": {
                "line": "ライン描画の継続",
                "area": "エリア描画の継続"
            }
        },
        "cancel_draw": {
            "annotation": "描画のキャンセル"
        },
        "change_tags": {
            "annotation": "タグの変更"
        },
        "circularize": {
            "title": "円状に並べる",
            "description": "この地物を円状に配置",
            "key": "O",
            "annotation": {
                "line": "ラインを円状に整形",
                "area": "エリアを円状に整形"
            }
        },
        "orthogonalize": {
            "title": "角の直交化",
            "description": "角を90度に整形",
            "key": "Q",
            "annotation": {
                "line": "ラインの角を90度に整形",
                "area": "エリアの角を90度に整形"
            }
        },
        "delete": {
            "title": "削除",
            "description": "この地物をマップから削除",
            "annotation": {
                "point": "ポイントを削除",
                "vertex": "ウェイ上のノードを削除",
                "line": "ライン削除",
                "area": "エリア削除",
                "relation": "リレーション削除",
                "multiple": "{n} 個のオブジェクトを削除"
            }
        },
        "connect": {
            "annotation": {
                "point": "ウェイをポイントに接続",
                "vertex": "ウェイを他のウェイト接続",
                "line": "ウェイとラインを接続",
                "area": "ウェイとエリアを接続"
            }
        },
        "disconnect": {
            "title": "接続解除",
            "description": "ウェイの接続を解除して切り離す",
            "key": "D",
            "annotation": "ウェイの接続を解除"
        },
        "merge": {
            "title": "結合",
            "description": "複数のラインを結合",
            "key": "C",
            "annotation": "{n} 本のラインを結合"
        },
        "move": {
            "title": "移動",
            "description": "この地物を別の位置へ移動",
            "key": "M",
            "annotation": {
                "point": "ポイントを移動",
                "vertex": "ウェイ上のノードを移動",
                "line": "ラインの移動",
                "area": "エリアの移動",
                "multiple": "Moved multiple objects."
            }
        },
        "rotate": {
            "title": "Rotate",
            "description": "Rotate this object around its centre point.",
            "key": "R",
            "annotation": {
                "line": "Rotated a line.",
                "area": "Rotated an area."
            }
        },
        "reverse": {
            "title": "方向反転",
            "description": "ラインの向きを反転",
            "key": "V",
            "annotation": "ラインの方向反転"
        },
        "split": {
            "title": "分割",
            "description": "このポイントを境としてウェイを分割",
            "key": "X",
            "annotation": "ウェイの分割"
        }
    },
    "nothing_to_undo": "やり直す変更点がありません",
    "nothing_to_redo": "やり直した変更点がありません",
    "just_edited": "OpenStreetMap編集完了！",
    "browser_notice": "このエディタは Firefox, Chrome, Safari, Opera, および Internet Explorer 9 以上をサポートしています。ブラウザのバージョンを更新するか、Potlatch 2を使用して編集してください",
    "view_on_osm": "OSMで確認",
    "zoom_in_edit": "編集するにはさらに地図を拡大してください",
    "logout": "ログアウト",
    "report_a_bug": "バグ報告",
    "commit": {
        "title": "編集結果を保存",
        "upload_explanation": "編集した内容を {user} アカウントでアップロードし、OpenStreetMapを利用しているすべてのユーザが閲覧できるようにします",
        "save": "Save",
        "cancel": "キャンセル",
        "warnings": "注意",
        "modified": "変更した地物",
        "deleted": "削除した地物",
        "created": "作成した地物"
    },
    "contributors": {
        "list": "{users} による編集履歴を確認",
        "truncated_list": "{users} とその他 {count} 人による編集履歴を表示"
    },
    "geocoder": {
        "title": "特定地点を検索",
        "placeholder": "対象地点の名称",
        "no_results": "'{name}' という名称の地点が見つかりません"
    },
    "geolocate": {
        "title": "編集画面を現在地へ移動"
    },
    "inspector": {
        "no_documentation_combination": "このタグの組み合わせに関する説明文はありません",
        "no_documentation_key": "このキーに対する説明文はありません",
        "new_tag": "新規タグ",
        "view_on_osm": "詳細情報確認"
    },
    "background": {
        "title": "背景画像",
        "description": "背景画像設定",
        "percent_brightness": "{opacity}% 輝度",
        "fix_misalignment": "背景画像をずらす",
        "reset": "設定リセット"
    },
    "restore": {
        "description": "前回作業した編集内容がアップロードされていません。編集内容を復元しますか？",
        "restore": "復元",
        "reset": "破棄"
    },
    "save": {
        "help": "編集内容をOpenStreetMapへ保存し、他ユーザへ公開",
        "error": "データ保存中にエラーが発生しました",
        "uploading": "編集内容をOpenStreetMapへアップロードしています",
        "unsaved_changes": "編集内容が保存されていません"
    },
    "splash": {
        "welcome": "iD 起動中",
        "text": "開発版 {version} を起動します。詳細は {website} を参照してください。バグ報告は {github} で受付中です"
    },
    "source_switch": {
        "live": "本番サーバ",
        "dev": "開発サーバ"
    },
    "tag_reference": {
        "description": "説明"
    },
    "validations": {
        "untagged_point": "ポイントにタグが付与されておらず、ラインやエリアの一部でもありません",
        "untagged_line": "ラインにタグが付与されていません",
        "untagged_area": "エリアにタグが付与されていません",
        "tag_suggests_area": "ラインに {tag} タグが付与されています。エリアで描かれるべきです",
        "deprecated_tags": "タグの重複: {tags}"
    },
    "zoom": {
        "in": "ズームイン",
        "out": "ズームアウト"
    }
};
locale.lv = {
    "modes": {
        "add_area": {
            "title": "Apgabals",
            "description": "Pievieno parkus, ēkas, ezerus un citus apgabalus.",
            "tail": "Klikšķiniet uz kartes, lai sāktu zīmēt apgabalu, piemēram, parku, ezeru, vai ēku."
        },
        "add_line": {
            "title": "Līnija",
            "description": "Pievieno ceļus, ielas, takas kanālus un citas līnijas.",
            "tail": "Klikšķiniet uz kartes, lai sāktu zīmēt līniju, piemēram, ceļu vai taku."
        },
        "add_point": {
            "title": "Punkts",
            "description": "Pievieno restorānus, pieminekļus, veikalus un citus punktus.",
            "tail": "Klikšķiniet uz kartes, lai pievienotu interešu punktu."
        },
        "browse": {
            "title": "Pārlūkot",
            "description": "Pārlūko karti."
        },
        "draw_area": {
            "tail": "Klikšķiniet, lai pievienotu mezglus apgabalam. Lai beigtu zīmēt apgabalu, klikšķiniet uz sākuma mezgla."
        },
        "draw_line": {
            "tail": "Klikšķiniet, lai pievienotu mezglus līnijai. Lai savienotu ar citām linijām, klikšķiniet uz tām. Dubultklikšķis nobeidz līniju."
        }
    },
    "operations": {
        "add": {
            "annotation": {
                "point": "Punkts pievienots.",
                "vertex": "Mezgls pievienots līnijai."
            }
        },
        "start": {
            "annotation": {
                "line": "Līnija iesākta.",
                "area": "Apgabals iesākts."
            }
        },
        "continue": {
            "annotation": {
                "line": "Līnija turpināta.",
                "area": "Apgabals turpināts."
            }
        },
        "cancel_draw": {
            "annotation": "Zīmēšana atcelta."
        },
        "change_tags": {
            "annotation": "Apzīmējumi mainīti."
        },
        "circularize": {
            "title": "Pārveidot par apļveida",
            "description": "Pārveidot šo objektu par apļveida.",
            "key": "O",
            "annotation": {
                "line": "Līnija pārveidota par apļveida.",
                "area": "Apgabals pārveidots par apļveida."
            }
        },
        "orthogonalize": {
            "title": "Ortogonalizēt",
            "description": "Pārveidot, lai visi leņķi būtu taisnleņķi.",
            "key": "Q",
            "annotation": {
                "line": "Līnijas leņķi pārvedoti par taisnleņķiem.",
                "area": "Apgabala leņķi pārvedoti par taisnleņķiem."
            }
        },
        "delete": {
            "title": "Dzēst",
            "description": "Izdzēst no kartes.",
            "annotation": {
                "point": "Punkts dzēsts.",
                "vertex": "Mezgls dzests.",
                "line": "Līnija dzēsta.",
                "area": "Apgabals dzēsts.",
                "relation": "Relācija dzēsta.",
                "multiple": "{n} objekti dzēsti."
            }
        },
        "connect": {
            "annotation": {
                "point": "Līnija savienota ar punktu.",
                "vertex": "Līnija savienota ar citu.",
                "line": "Līnija savienota ar līniju.",
                "area": "Līnija savienota ar apgabalu."
            }
        },
        "disconnect": {
            "title": "Atvienot",
            "description": "Atvieno līnijas.",
            "key": "D",
            "annotation": "Līnijas atvienotas."
        },
        "merge": {
            "title": "Sapludināt",
            "description": "Sapludināt līnijas.",
            "key": "C",
            "annotation": "{n} līnijas sapludinātas."
        },
        "move": {
            "title": "Pārvietot",
            "description": "Pārvieto objektu.",
            "key": "M",
            "annotation": {
                "point": "Punkts pārvietots.",
                "vertex": "Mezgls pārvietots.",
                "line": "Līnija pārvietota.",
                "area": "Apgabals pārvietots.",
                "multiple": "Vairāki objekti pārvietoti."
            }
        },
        "rotate": {
            "title": "Pagriezt",
            "description": "Pagriezt šo objektu ap tā centru.",
            "key": "R",
            "annotation": {
                "line": "Līnija pagriezta.",
                "area": "Apgabals pagriezts."
            }
        },
        "reverse": {
            "title": "Mainīt virzienu",
            "description": "Mainīt līnijas virzienu.",
            "key": "V",
            "annotation": "Līnijas virziens mainīts."
        },
        "split": {
            "title": "Sadalīt",
            "description": "Sadalīt līniju pie šī punkta.",
            "key": "X",
            "annotation": "Līnija sadalīta."
        }
    },
    "nothing_to_undo": "Nav nekā, ko atcelt",
    "nothing_to_redo": "Nav nekā, ko atsaukt",
    "just_edited": "Jūs nupat rediģējāt OpenStreetMap",
    "browser_notice": "Šis redaktors tiek atbalstīts ar Firefox, Chrome, Safari, Opera, un Internet Explorer 9 un jaunāku. Lūdzu, atjauniniet savu pārlūkprogrammu vai izmantojiet Potlatch 2 kartes rediģēšanai",
    "view_on_osm": "Aplūkot OSM kartē",
    "zoom_in_edit": "pietuviniet, lai labotu karti",
    "logout": "atslēgties",
    "report_a_bug": "ziņot par kļūdu",
    "commit": {
        "title": "Saglabāt izmaiņas",
        "description_placeholder": "Īss apraksts par jūsu ieguldījumu",
        "upload_explanation": "Izmaiņas, kuras jūs augšupielādējat kā {user}, būs pieejamas visās kartēs, kuras izmanto OpenStreetMap datus.",
        "save": "Saglabāt",
        "cancel": "Atcelt",
        "warnings": "Brīdinājumi",
        "modified": "Mainīts",
        "deleted": "Dzēsts",
        "created": "Izveidots"
    },
    "contributors": {
        "list": "{users} papildinājumi redzami",
        "truncated_list": "{users} un {count} citu papildinājumi redzami"
    },
    "geocoder": {
        "title": "Atrast vietu",
        "placeholder": "meklēt vietu",
        "no_results": "Nevar atrast vietu '{name}'"
    },
    "geolocate": {
        "title": "Parādīt manu atrašanās vietu"
    },
    "inspector": {
        "no_documentation_combination": "Šai apzīmējumu kombinācijai nav piejama dokumentācija",
        "no_documentation_key": "Šai vērtībai nav piejama dokumentācija",
        "new_tag": "Jauns apzīmējums",
        "view_on_osm": "Apskatīt OSM",
        "additional": "Papildus apzīmējumi",
        "choose": "Izvēlieties objekta tipu",
        "results": "Atrasti {n} rezultāti meklējot {search}",
        "reference": "Skatīt OpenStreetMap wiki →",
        "back_tooltip": "Mainīt objekta tipu"
    },
    "background": {
        "title": "Fons",
        "description": "Fona iestatījumi",
        "percent_brightness": "{opacity}% caurspīdīgums",
        "fix_misalignment": "Labot fona nobīdi",
        "reset": "Atiestatīt"
    },
    "restore": {
        "description": "Jums ir nesaglabātas izmaiņas no iepriekšējās labošanas sesijas. Vai vēlaties ielādēt šīs izmaiņas?",
        "restore": "Ielādēt",
        "reset": "Atmest"
    },
    "save": {
        "title": "Saglabāt",
        "help": "Saglabā izmaiņas, padarot tās redzamas citiem.",
        "no_changes": "Nav izmaiņu, ko saglabāt.",
        "error": "Kļūda. Nevarēja saglabāt izmaiņas",
        "uploading": "Augšupielādē izmaiņas",
        "unsaved_changes": "Jums ir nesaglabātas izmaiņas"
    },
    "splash": {
        "welcome": "Laipni lūgti iD OpenStreetMap redaktorā",
        "text": "Šī ir izstrādes versija {version}. Papildus informācijai skatīt {website} un ziņot par kļūdām {github}."
    },
    "source_switch": {
        "live": "live",
        "dev": "dev"
    },
    "tag_reference": {
        "description": "Apraksts",
        "on_wiki": "{tag} wiki.osm.org",
        "used_with": "izmantots kopā ar {type}"
    },
    "validations": {
        "untagged_point": "Neapzīmēts punkts",
        "untagged_line": "Neapzīmēta līnija",
        "untagged_area": "Neapzīmēts apgabals",
        "many_deletions": "Jūs dzēšat {n} objektus. Vai tiešām vēlaties to darīt? Tie tiks izdzēsti no kartes, ko visi var aplūkt openstreetmap.org.",
        "tag_suggests_area": "Apzīmējums {tag} parasti tiek lietots apgabaliem, bet objekts nav apgabals",
        "deprecated_tags": "Novecojuši apzīmējumi: {tags}"
    },
    "zoom": {
        "in": "Pietuvināt",
        "out": "Attālināt"
    },
    "presets": {
        "fields": {
            "access": {
                "label": "Piekļuve"
            },
            "address": {
                "label": "Adrese",
                "placeholders": {
                    "number": "123",
                    "street": "Iela",
                    "city": "Pilsēta"
                }
            },
            "aeroway": {
                "label": "Tips"
            },
            "amenity": {
                "label": "Tips"
            },
            "atm": {
                "label": "Bankomāts"
            },
            "bicycle_parking": {
                "label": "Tips"
            },
            "building": {
                "label": "Ēka"
            },
            "building_area": {
                "label": "Ēka"
            },
            "building_yes": {
                "label": "Ēka"
            },
            "capacity": {
                "label": "Ietilpība"
            },
            "construction": {
                "label": "Tips"
            },
            "crossing": {
                "label": "Tips"
            },
            "fee": {
                "label": "Maksa"
            },
            "highway": {
                "label": "Tips"
            },
            "historic": {
                "label": "Tips"
            },
            "internet_access": {
                "label": "Interneta piekļuve",
                "options": {
                    "wlan": "Bezvadu internets",
                    "wired": "Kabeļinternets"
                }
            },
            "landuse": {
                "label": "Tips"
            },
            "layer": {
                "label": "Līmenis"
            },
            "leisure": {
                "label": "Tips"
            },
            "levels": {
                "label": "Stāvu skaits"
            },
            "man_made": {
                "label": "Tips"
            },
            "maxspeed": {
                "label": "Ātruma ierobežojums"
            },
            "oneway": {
                "label": "Vienvirziena"
            },
            "opening_hours": {
                "label": "Darba laiks"
            },
            "place": {
                "label": "Tips"
            },
            "railway": {
                "label": "Tips"
            },
            "religion": {
                "label": "Reliģija",
                "options": {
                    "christian": "Kristietiešu",
                    "muslim": "Musulmaņu",
                    "buddhist": "Budistu",
                    "hindu": "Hinduistu",
                    "shinto": "Sintoistu",
                    "taoist": "Taoistu"
                }
            },
            "service": {
                "label": "Tips"
            },
            "shelter": {
                "label": "Pajumte"
            },
            "shop": {
                "label": "Tips"
            },
            "source": {
                "label": "Avots"
            },
            "sport": {
                "label": "Sports"
            },
            "surface": {
                "label": "Segums"
            },
            "tourism": {
                "label": "Tips"
            },
            "water": {
                "label": "Tips"
            },
            "waterway": {
                "label": "Tips"
            },
            "wetland": {
                "label": "Tips"
            },
            "wood": {
                "label": "Tips"
            }
        }
    }
};
locale.pl = {
    "modes": {
        "add_area": {
            "title": "Obszar",
            "description": "Obaszary mogą być na przykład parkami, budynkami, jeziorami.",
            "tail": "Kliknij na mapę aby zacząć rysować obszar, na przykład park, jezioro lub budynek."
        },
        "add_line": {
            "title": "Linia",
            "description": "Linie mogą być na przykład jezdniami, ścieżkami dla pieszych lub nawet kanałami.",
            "tail": "Kliknij na mapę aby zacząć rysować linię, na przykład drogę, ścieżkę lub trasę."
        },
        "add_point": {
            "title": "Punkt",
            "description": "Punkty mogą być na przykład restauracjami, pomnikami i skrzynkami pocztowymi.",
            "tail": "Kliknij na mapę aby dodać punkt, na przykład restaurację, pomnik lub skrzynkę pocztową."
        },
        "browse": {
            "title": "Przeglądaj",
            "description": "Przesuwaj i zmieniaj skalę mapy."
        },
        "draw_area": {
            "tail": "Kliknij aby dodać punkty do obszaru. Kliknij na pierwszy punkt aby skończyć rysowanie obszaru."
        },
        "draw_line": {
            "tail": "Kliknij aby dodać punkty do linii. Kliknij na inne linie aby je połączyć, a dwa razy kliknij na linię aby skończyć ją rysować."
        }
    },
    "operations": {
        "add": {
            "annotation": {
                "point": "Dodano punkt.",
                "vertex": "Dodano węzeł do drogi."
            }
        },
        "start": {
            "annotation": {
                "line": "Zaczęto linię.",
                "area": "Zaczęto obszar."
            }
        },
        "continue": {
            "annotation": {
                "line": "Kontynuacja linii.",
                "area": "Kontynuacja obszaru."
            }
        },
        "cancel_draw": {
            "annotation": "Przestano rysować."
        },
        "change_tags": {
            "annotation": "Zmieniono tagi."
        },
        "circularize": {
            "title": "Zaokrąglij",
            "description": "Wyrównaj na okręgu.",
            "key": "O",
            "annotation": {
                "line": "Zaokrąglij linię.",
                "area": "Zaokrąglij obszar."
            }
        },
        "orthogonalize": {
            "title": "Ortogonalizuj",
            "description": "Spraw, aby te kąty były proste.",
            "key": "Q",
            "annotation": {
                "line": "Zortogonalizowano kąty linii.",
                "area": "Zortogonalizowano kąty obszaru."
            }
        },
        "delete": {
            "title": "Usuń",
            "description": "Usuń to z mapy.",
            "annotation": {
                "point": "Usunięto punkt.",
                "vertex": "Usunięto węzeł z drogi.",
                "line": "Usunięto linię.",
                "area": "Usunięto obszar.",
                "relation": "Usunięto relację.",
                "multiple": "Usunięto {n} obietów/obiekty."
            }
        },
        "connect": {
            "annotation": {
                "point": "Połączono drogę z punktem.",
                "vertex": "Połączono dwie drogi.",
                "line": "Połączono drogę z linią.",
                "area": "Połączono drogę z obszarem."
            }
        },
        "disconnect": {
            "title": "Rozłącz",
            "description": "Rozłącz te dwie drogi.",
            "key": "D",
            "annotation": "Rozłączono drogi."
        },
        "merge": {
            "title": "Scal",
            "description": "Scal te linie.",
            "key": "C",
            "annotation": "Scalono {n} linii."
        },
        "move": {
            "title": "Przesuń",
            "description": "Przesuń to w inne miejsce.",
            "key": "M",
            "annotation": {
                "point": "Przesunięto punkt.",
                "vertex": "Przesunięto węzeł drogi.",
                "line": "Przesunięto linię.",
                "area": "Przesunięto obszar."
            }
        },
        "reverse": {
            "title": "Odwróć",
            "description": "Spraw by ta linia biegła w przeciwnym kierunku.",
            "key": "V",
            "annotation": "Odwrócono linię."
        },
        "split": {
            "title": "Rozdziel",
            "description": "Rozdziel to na dwie drogi w tym punkcie.",
            "key": "X",
            "annotation": "Rozdzielono drogę."
        }
    },
    "nothing_to_undo": "Nie ma nic do cofnięcia.",
    "nothing_to_redo": "Nie ma nic do powtórzenia.",
    "just_edited": "Właśnie wprowadziłeś zmiany w OpenStreetMap!!",
    "browser_notice": "Ten edytor działa w Firefox, Chrome, Safari, Opera, and Internet Explorer 9 i wyższych. Zaktualizuj swoją przeglądarkę lub użyj Potlatch 2 aby edytować mapę.",
    "view_on_osm": "Pokaż w OSM",
    "zoom_in_edit": "zwiększ skalę aby edytować mapę",
    "logout": "wyloguj",
    "report_a_bug": "zgłoś błąd",
    "commit": {
        "title": "Zapisz zmiany",
        "description_placeholder": "Krótki opis twoich zmian",
        "upload_explanation": "Zmiany które wyślesz jako {user} będą widoczne na wszystkich mapach używających danych OpenStreetMap.",
        "save": "Zapisz",
        "cancel": "Anuluj",
        "warnings": "Ostrzeżenia",
        "modified": "Zmodyfikowano",
        "deleted": "Usunięto",
        "created": "Utworzono"
    },
    "contributors": {
        "list": "Przeglądanie wkładu użytkowników {users}",
        "truncated_list": "Przeglądanie wkładu użytkownikówy {users} {count} innych"
    },
    "geocoder": {
        "title": "Znajdź miejsce",
        "placeholder": "znajdź miejsce",
        "no_results": "Nie można znaleźć miejsca o nazwie '{name}'"
    },
    "geolocate": {
        "title": "Pokaż moją pozycję."
    },
    "inspector": {
        "no_documentation_combination": "Nie ma dokumentacji dla tej kombinacji tagu.",
        "no_documentation_key": "Nie ma dokumentacji dla tego klucza",
        "new_tag": "Nowy tag",
        "view_on_osm": "Zobacz w OSM"
    },
    "background": {
        "title": "Tło",
        "description": "Ustawienia tła",
        "percent_brightness": "jasność {opacity}%",
        "fix_misalignment": "Wyrównaj podkład",
        "reset": "resetuj"
    },
    "restore": {
        "description": "Masz niezapisane zmiany z poprzedniej sesji. Chcesz je przywrócić?",
        "restore": "Przywróć",
        "reset": "Resetuj"
    },
    "save": {
        "title": "Zapisz",
        "help": "Zapisz zmiany na OpenStreetMap, aby były one widoczne dla innych",
        "error": "Wystąpił błąd podczas próby zapisu.",
        "uploading": "Wysyłanie zmian do OpenStreetMap.",
        "unsaved_changes": "Masz niezapisane zmiany."
    },
    "splash": {
        "welcome": "Witaj w edytorze iD map OpenStreetMap",
        "text": "To jest wersja rozwojowa {version}. Informacji szukaj na {website} i zgłaszaj błędy na {github}."
    },
    "source_switch": {
        "live": "live",
        "dev": "dev"
    },
    "tag_reference": {
        "description": "Opis",
        "on_wiki": "{tag} na wiki.osm.org",
        "used_with": "używany z {type}"
    },
    "validations": {
        "untagged_point": "Nieopisany punkt, który nie jest częścią linii lub obszaru.",
        "untagged_line": "Nieopisana linia.",
        "untagged_area": "Nieopisany obszar.",
        "many_deletions": "You're deleting {n} objects. Are you sure you want to do this? This will delete them from the map that everyone else sees on openstreetmap.org.",
        "tag_suggests_area": "Tag {tag} sugeruje, że linia powinna być obszarem, ale nim nie jest.",
        "deprecated_tags": "Przestarzałe tagi: {tags}"
    },
    "zoom": {
        "in": "Powiększ",
        "out": "Zmniejsz"
    }
};
locale.pt = {
    "modes": {
        "add_area": {
            "title": "Área",
            "description": "Adicione parques, edifícios, lagos, ou outras áreas ao mapa.",
            "tail": "Clique no mapa para começar a desenhar uma área, como um parque, lago ou edifício."
        },
        "add_line": {
            "title": "Linha",
            "description": "Linhas podem ser auto-estradas, ruas, caminhos pedestres e inclusive canais.",
            "tail": "Clique no mapa para começar a desenhar uma estrada, caminho ou rota."
        },
        "add_point": {
            "title": "Ponto",
            "description": "Restaurantes, monumentos e caixas postais podem ser pontos.",
            "tail": "Clique no mapa para adicionar um ponto."
        },
        "browse": {
            "title": "Navegar",
            "description": "Faça zoom e mova o mapa"
        },
        "draw_area": {
            "tail": "Clique para adicionar pontos à sua área. Carregue no primeiro ponto para terminar a área."
        },
        "draw_line": {
            "tail": "Clique para adicionar mais pontos à linha. Clique em outras linhas para ligar, e duplo-clique para terminar a linha."
        }
    },
    "operations": {
        "add": {
            "annotation": {
                "point": "Adicione um Ponto.",
                "vertex": "Adicione um vértice a um caminho"
            }
        },
        "start": {
            "annotation": {
                "line": "Linha iniciada.",
                "area": "Área iniciada."
            }
        },
        "continue": {
            "annotation": {
                "line": "Linha continuada.",
                "area": "Área continuada."
            }
        },
        "cancel_draw": {
            "annotation": "Desenho cancelado."
        },
        "change_tags": {
            "annotation": "Tags alteradas."
        },
        "circularize": {
            "title": "Circularizar",
            "description": "Fazer isto circular.",
            "key": "O",
            "annotation": {
                "line": "Fazer uma linha circular.",
                "area": "Fazer uma área circular."
            }
        },
        "orthogonalize": {
            "title": "Esquadrar",
            "description": "Esquadrar estes cantos.",
            "key": "E",
            "annotation": {
                "line": "Cantos da linha esquadrados.",
                "area": "Cantos da área esquadrados."
            }
        },
        "delete": {
            "title": "Remover",
            "description": "Remover isto do mapa.",
            "annotation": {
                "point": "Ponto eliminado.",
                "vertex": "Vértice elimnado de la ruta.",
                "line": "Linha eliminada.",
                "area": "Área eliminada.",
                "relation": "Relacão eliminada.",
                "multiple": "{n} objetos eliminados."
            }
        },
        "connect": {
            "annotation": {
                "point": "Rota ligada a um ponto.",
                "vertex": "Rota ligada a outra.",
                "line": "Rota ligada a uma linha.",
                "area": "Rota ligada a uma área."
            }
        },
        "disconnect": {
            "title": "Desligar",
            "description": "Desligar rotas umas das outras.",
            "key": "D",
            "annotation": "Rotas desligadas."
        },
        "merge": {
            "title": "Combinar",
            "description": "Combinar linhas.",
            "key": "C",
            "annotation": "{n} linhas combinadas."
        },
        "move": {
            "title": "Mover",
            "description": "Mover para outra localização.",
            "key": "M",
            "annotation": {
                "point": "Ponto movido,",
                "vertex": "Vértice movido.",
                "line": "Linha movida.",
                "area": "Área movida,",
                "multiple": "Múltiplos objectos movidos."
            }
        },
        "rotate": {
            "title": "Rodar",
            "description": "Rodar este objecto sobre o seu ponto central.",
            "key": "R",
            "annotation": {
                "line": "Linha rodada.",
                "area": "Área rodade."
            }
        },
        "reverse": {
            "title": "Inverter",
            "description": "Inverter direcção da linha.",
            "key": "I",
            "annotation": "Direcção da linha revertida."
        },
        "split": {
            "title": "Dividir",
            "description": "Dividir em duas rotas este ponto.",
            "key": "D",
            "annotation": "Dividir rota."
        }
    },
    "nothing_to_undo": "Nada a desfazer.",
    "nothing_to_redo": "Nada a refazer.",
    "just_edited": "Acaba de editar o OpenStreetMap!",
    "browser_notice": "Este editor suporta Firefox, Chrome, Safari, Opera e Internet Explorer 9 ou superior. Por favor actualize o seu browser ou utilize Potlatch 2 para editar o mapa.",
    "view_on_osm": "Ver em OSM",
    "zoom_in_edit": "Aproxime-se para editar o mapa",
    "logout": "Encerrar sessão",
    "report_a_bug": "Reportar un erro",
    "commit": {
        "title": "Guardar Alterações",
        "description_placeholder": "Breve descrição das suas contribuições",
        "upload_explanation": "As alterações que envia como {user} serão visíveis em todos os mapas que utilizem dados do OpenStreetMap.",
        "save": "Guardar",
        "cancel": "Cancelar",
        "warnings": "Avisos",
        "modified": "Modificado",
        "deleted": "Removido",
        "created": "Criado"
    },
    "contributors": {
        "list": "A ver contribuições de {users}",
        "truncated_list": "A ver contribuições de {users} e mais {count} outros"
    },
    "geocoder": {
        "title": "Encontrar Um Local",
        "placeholder": "encontrar um local",
        "no_results": "Não foi possível encontrar o local chamado '{name}'"
    },
    "geolocate": {
        "title": "Mostrar a minha localização"
    },
    "inspector": {
        "no_documentation_combination": "Não há documentação disponível para esta combinação de tags",
        "no_documentation_key": "Não há documentação disponível para esta tecla",
        "show_more": "Mostrar Mais",
        "new_tag": "Nova tag",
        "view_on_osm": "Ver em OSM",
        "editing_feature": "Editando {feature}",
        "additional": "Tags adicionais",
        "choose": "O que está a adicionar?",
        "results": "{n} resultados para {search}",
        "reference": "Ver na Wiki do OpenStreetMap"
    },
    "background": {
        "title": "Fundo",
        "description": "Configuração de fundo",
        "percent_brightness": "{opacity}% brilho",
        "fix_misalignment": "Arranjar desalinhamento",
        "reset": "reiniciar"
    },
    "restore": {
        "heading": "Tem alterações por guardar",
        "description": "Tem alterações por guardar de uma prévia sessão de edição. Deseja restaurar estas alterações?",
        "restore": "Restaurar",
        "reset": "Descartar"
    },
    "save": {
        "title": "Guardar",
        "help": "Guardar alterações no OpenStreetMap, tornando-as visíveis a outros utilizadores.",
        "no_changes": "Não há alterações para guardar.",
        "error": "Um erro ocorreu ao tentar guardar",
        "uploading": "Enviando alterações para OpenStreetMap.",
        "unsaved_changes": "Tem alterações por guardar"
    },
    "splash": {
        "welcome": "Bemvindo ao editor OpenStreetMap iD",
        "text": "Esta é a versão de desenvolvimento {version}. Para mais informação visite {website} e reporte erros em {github}."
    },
    "source_switch": {
        "live": "ao vivo",
        "lose_changes": "Tem alterações por guardar. Mudando o servidor de mapas irá perdê-las. Tem a certeza que deseja mudar de servidores?",
        "dev": "dev"
    },
    "tag_reference": {
        "description": "Descrição",
        "on_wiki": "{tag} em wiki.osm.org",
        "used_with": "usado com {type}"
    },
    "validations": {
        "untagged_point": "Punto sin etiquetar que no es parte de una línea ni de un área.",
        "untagged_line": "Linha sem tag",
        "untagged_area": "Área sem tags",
        "many_deletions": "Está a eliminar {n} objectos. Tem a certeza que deseja continuar? Esta operação eliminará os objectos do mapa que outros vêem em openstreetmap.org.",
        "tag_suggests_area": "A tag {tag} sugere que esta linha devia ser uma área, mas não é uma área.",
        "deprecated_tags": "Tags obsoletas: {tags}"
    },
    "zoom": {
        "in": "Aproximar",
        "out": "Afastar"
    },
    "imagery": {
        "provided_by": "Imagens disponibilizadas por {source}"
    },
    "gpx": {
        "local_layer": "Ficheiro GPX local",
        "drag_drop": "Arraste um ficheiro .gpx para a página"
    },
    "help": {
        "title": "Ajuda"
    },
    "presets": {
        "fields": {
            "access": {
                "label": "Acesso"
            },
            "address": {
                "label": "Morada",
                "placeholders": {
                    "housename": "Nome de casa",
                    "number": "123",
                    "street": "Rua",
                    "city": "Cidade"
                }
            },
            "aeroway": {
                "label": "Tipo"
            },
            "amenity": {
                "label": "Tipo"
            },
            "atm": {
                "label": "MB"
            },
            "bicycle_parking": {
                "label": "Tipo"
            },
            "building": {
                "label": "Edifício"
            },
            "building_area": {
                "label": "Edifício"
            },
            "building_yes": {
                "label": "Edifício"
            },
            "capacity": {
                "label": "Capacidade"
            },
            "construction": {
                "label": "Tipo"
            },
            "crossing": {
                "label": "Tipo"
            },
            "cuisine": {
                "label": "Cozinha"
            },
            "denomination": {
                "label": "Denominação"
            },
            "denotation": {
                "label": "Denotação"
            },
            "elevation": {
                "label": "Elevação"
            },
            "emergency": {
                "label": "Emergência"
            },
            "entrance": {
                "label": "Tipo"
            },
            "fax": {
                "label": "Fax"
            },
            "fee": {
                "label": "Tarifa"
            },
            "highway": {
                "label": "Tipo"
            },
            "historic": {
                "label": "Tipo"
            },
            "internet_access": {
                "label": "Acesso à Internet",
                "options": {
                    "wlan": "Wifi"
                }
            },
            "maxspeed": {
                "label": "Limite de Velocidade"
            },
            "natural": {
                "label": "Natural"
            },
            "network": {
                "label": "Rede"
            },
            "note": {
                "label": "Nota"
            },
            "office": {
                "label": "Tipo"
            },
            "oneway": {
                "label": "Sentido Único"
            },
            "opening_hours": {
                "label": "Horas"
            },
            "operator": {
                "label": "Operador"
            },
            "phone": {
                "label": "Telefone"
            },
            "place": {
                "label": "Tipo"
            },
            "railway": {
                "label": "Tipo"
            },
            "religion": {
                "label": "Religião",
                "options": {
                    "christian": "Cristão",
                    "muslim": "Muçulmano",
                    "buddhist": "Budista",
                    "jewish": "Judeu"
                }
            },
            "shelter": {
                "label": "Abrigo"
            },
            "shop": {
                "label": "Tipo"
            },
            "source": {
                "label": "Fonte"
            },
            "sport": {
                "label": "Desporto"
            },
            "surface": {
                "label": "Superfície"
            },
            "tourism": {
                "label": "Tipo"
            },
            "water": {
                "label": "Tipo"
            },
            "waterway": {
                "label": "Tipo"
            },
            "website": {
                "label": "Website"
            },
            "wetland": {
                "label": "Tipo"
            },
            "wikipedia": {
                "label": "Wikipedia"
            },
            "wood": {
                "label": "Tipo"
            }
        },
        "presets": {
            "aeroway/aerodrome": {
                "name": "Aeroporto"
            },
            "amenity": {
                "name": "Amenidade"
            },
            "amenity/bank": {
                "name": "Banco"
            },
            "amenity/bar": {
                "name": "Bar"
            },
            "amenity/bench": {
                "name": "Banco"
            },
            "amenity/bicycle_parking": {
                "name": "Parque de Bicicletas"
            },
            "amenity/bicycle_rental": {
                "name": "Aluguer de Bicicletas"
            },
            "amenity/cafe": {
                "name": "Café"
            },
            "amenity/cinema": {
                "name": "Cinema"
            },
            "amenity/fire_station": {
                "name": "Quartel de Bombeiros"
            },
            "amenity/grave_yard": {
                "name": "Cemitério"
            },
            "amenity/hospital": {
                "name": "Hospital"
            },
            "amenity/library": {
                "name": "Biblioteca"
            },
            "amenity/parking": {
                "name": "Estacionamento"
            },
            "amenity/pharmacy": {
                "name": "Farmácia"
            },
            "amenity/place_of_worship": {
                "name": "Local de Oração"
            },
            "amenity/place_of_worship/christian": {
                "name": "Igreja"
            },
            "amenity/place_of_worship/jewish": {
                "name": "Sinagoga"
            },
            "amenity/place_of_worship/muslim": {
                "name": "Mesquita"
            },
            "amenity/police": {
                "name": "Polícia"
            },
            "amenity/post_box": {
                "name": "Caixa de Correio"
            },
            "amenity/post_office": {
                "name": "Estação de Correios"
            },
            "amenity/pub": {
                "name": "Bar"
            },
            "amenity/restaurant": {
                "name": "Restaurante"
            },
            "amenity/school": {
                "name": "Escola"
            },
            "amenity/telephone": {
                "name": "Telefone"
            },
            "amenity/toilets": {
                "name": "Casas de Banho"
            },
            "amenity/townhall": {
                "name": "Câmara Municipal"
            },
            "amenity/university": {
                "name": "Universidade"
            },
            "building": {
                "name": "Edifício"
            },
            "entrance": {
                "name": "Entrada"
            },
            "highway": {
                "name": "Autoestrada"
            },
            "highway/bus_stop": {
                "name": "Paragem de Autocarro"
            },
            "highway/crossing": {
                "name": "Passadeira"
            },
            "highway/cycleway": {
                "name": "Ciclovia"
            },
            "highway/primary": {
                "name": "Estrada Principal"
            },
            "highway/residential": {
                "name": "Estrada Residencial"
            },
            "highway/secondary": {
                "name": "Estrada Secundária"
            },
            "highway/service": {
                "name": "Estrada de Serviço"
            },
            "highway/steps": {
                "name": "Passos"
            },
            "highway/track": {
                "name": "Pista"
            },
            "landuse/cemetery": {
                "name": "Cemitério"
            },
            "landuse/commercial": {
                "name": "Comercial"
            },
            "landuse/construction": {
                "name": "Construção"
            },
            "landuse/farm": {
                "name": "Quinta"
            },
            "landuse/farmyard": {
                "name": "Quintal"
            },
            "landuse/forest": {
                "name": "Floresta"
            },
            "landuse/grass": {
                "name": "Relva"
            },
            "landuse/industrial": {
                "name": "Industrial"
            },
            "leisure/golf_course": {
                "name": "Campo de Golf"
            },
            "leisure/park": {
                "name": "Parque"
            },
            "leisure/pitch": {
                "name": "Campo de Desporto"
            },
            "leisure/pitch/tennis": {
                "name": "Campo de Ténis"
            },
            "man_made/water_tower": {
                "name": "Torre de Água"
            },
            "natural": {
                "name": "Natural"
            },
            "natural/bay": {
                "name": "Baía"
            },
            "natural/beach": {
                "name": "Praia"
            },
            "natural/cliff": {
                "name": "Penhasco"
            },
            "natural/coastline": {
                "name": "Linha Costeira"
            },
            "natural/water": {
                "name": "Água"
            },
            "natural/water/lake": {
                "name": "Lago"
            },
            "place/island": {
                "name": "Ilha"
            },
            "place/locality": {
                "name": "Localidade"
            },
            "place/village": {
                "name": "Aldeia"
            },
            "railway/subway": {
                "name": "Metro"
            },
            "railway/subway_entrance": {
                "name": "Entrada de Metro"
            },
            "shop": {
                "name": "Loja"
            },
            "shop/butcher": {
                "name": "Talho"
            },
            "shop/supermarket": {
                "name": "Supermercado"
            },
            "tourism": {
                "name": "Turismo"
            },
            "tourism/camp_site": {
                "name": "Parque de Campismo"
            },
            "tourism/hotel": {
                "name": "Hotal"
            },
            "tourism/museum": {
                "name": "Musei"
            },
            "waterway/canal": {
                "name": "Canal"
            },
            "waterway/river": {
                "name": "Rio"
            }
        }
    }
};
locale.ru = {
    "modes": {
        "add_area": {
            "title": "Контур",
            "description": "Добавить парки, здания, озёра или иные объекты на карту.",
            "tail": "Щёлкните на карту, чтобы начать рисование области — например, парка, озера или здания."
        },
        "add_line": {
            "title": "Линия",
            "description": "Линиями можно обозначить дороги, тропинки, заборы или, к примеру, ручьи.",
            "tail": "Щёлкните на карту, чтобы начать рисование дороги, тропинки или ручья."
        },
        "add_point": {
            "title": "Точка",
            "description": "Точки — это рестораны, памятники, почтовые ящики.",
            "tail": "Щёлкните на карту, чтобы поставить точку."
        },
        "browse": {
            "title": "Просмотр",
            "description": "Двигать и масштабировать карту."
        },
        "draw_area": {
            "tail": "Щёлкайте, чтобы добавить точки в контур. Щёлкните начальную точку для завершения."
        },
        "draw_line": {
            "tail": "Щёлкайте, чтобы добавить точки в линию. Щёлкните на другую линию, чтобы соединить их, двойной щелчок завершит линию."
        }
    },
    "operations": {
        "add": {
            "annotation": {
                "point": "Добавлена точка.",
                "vertex": "В линию добавлена точка."
            }
        },
        "start": {
            "annotation": {
                "line": "Начато рисование линии.",
                "area": "Начато рисование области."
            }
        },
        "continue": {
            "annotation": {
                "line": "Продлена линия.",
                "area": "Дополнен контур."
            }
        },
        "cancel_draw": {
            "annotation": "Рисование отменено."
        },
        "change_tags": {
            "annotation": "Изменены теги."
        },
        "circularize": {
            "title": "Округлить",
            "description": "Превратить объект в окружность.",
            "key": "O",
            "annotation": {
                "line": "Линия превращена в окружность.",
                "area": "Контур превращён в окружность."
            }
        },
        "orthogonalize": {
            "title": "Ортогонализировать",
            "description": "Выпрямить все углы.",
            "key": "Q",
            "annotation": {
                "line": "Выпрямлены углы в линии.",
                "area": "Выпрямлены углы контура."
            }
        },
        "delete": {
            "title": "Удалить",
            "description": "Убрать объект с карты.",
            "annotation": {
                "point": "Удалена точка.",
                "vertex": "Удалёна точка из линии.",
                "line": "Удалена линия.",
                "area": "Удалён контур.",
                "relation": "Удалено отношение.",
                "multiple": "Удалены {n} объектов."
            }
        },
        "connect": {
            "annotation": {
                "point": "Линия присоединена к точке.",
                "vertex": "Одна линия присоединена к другой.",
                "line": "Линия соединена с другой линией.",
                "area": "Линия присоединена к контуру."
            }
        },
        "disconnect": {
            "title": "Разъединить",
            "description": "Разъединить эти линии.",
            "key": "D",
            "annotation": "Разъединены линии."
        },
        "merge": {
            "title": "Объединить",
            "description": "Объединить две линии.",
            "key": "C",
            "annotation": "Объединены {n} линий."
        },
        "move": {
            "title": "Сместить",
            "description": "Сместить объект в другое место.",
            "key": "M",
            "annotation": {
                "point": "Смещена точка.",
                "vertex": "Смещена точка линии.",
                "line": "Смещена линия.",
                "area": "Смещён контур.",
                "multiple": "Передвинуты несколько объектов."
            }
        },
        "rotate": {
            "title": "Повернуть",
            "description": "Повернуть объект относительно центра.",
            "annotation": {
                "line": "Повернута линия.",
                "area": "Повёрнут контур."
            }
        },
        "reverse": {
            "title": "Развернуть",
            "description": "Сменить направление этой линии на противоположное.",
            "key": "V",
            "annotation": "Линия развёрнута."
        },
        "split": {
            "title": "Разрезать",
            "description": "Разбить линию на две в этой точке.",
            "key": "X",
            "annotation": "Разрезана линия."
        }
    },
    "nothing_to_undo": "Отменять нечего.",
    "nothing_to_redo": "Повторять нечего.",
    "just_edited": "Вы только что отредактировали карту OpenStreetMap!",
    "browser_notice": "Этот редактор работает в браузерах Firefox, Chrome, Safari, Opera и Internet Explorer версии 9 и выше. Пожалуйста, обновите свой браузер или воспользуйтесь редактором Potlatch 2.",
    "view_on_osm": "Посмотреть на OSM",
    "zoom_in_edit": "приблизьте для редактирования",
    "logout": "выйти",
    "report_a_bug": "сообщить об ошибке",
    "commit": {
        "title": "Сохранить изменения",
        "description_placeholder": "Краткое описание ваших правок",
        "upload_explanation": "Изменения, сделанные вами под именем {user}, появятся на всех картах, основанных на данных OpenStreetMap.",
        "save": "Сохранить",
        "cancel": "Отменить",
        "warnings": "Предупреждения",
        "modified": "Изменено",
        "deleted": "Удалено",
        "created": "Создано"
    },
    "contributors": {
        "list": "Здесь карту редактировали {users}",
        "truncated_list": "Здесь карту редактировали {users} и ещё {count} человек"
    },
    "geocoder": {
        "title": "Найти место",
        "placeholder": "найти место",
        "no_results": "Не могу найти место с названием «{name}»"
    },
    "geolocate": {
        "title": "К моим координатам"
    },
    "inspector": {
        "no_documentation_combination": "Для этой комбинации ключа и значения нет описания",
        "no_documentation_key": "Для этого ключа описания нет",
        "new_tag": "Новый тег",
        "view_on_osm": "Посмотреть в OSM",
        "additional": "Additional tags",
        "choose": "What are you adding?",
        "results": "{n} results for {search}",
        "reference": "Найти в вики OpenStreetMap →",
        "back_tooltip": "Изменить тип объекта"
    },
    "background": {
        "title": "Подложка",
        "description": "Настройка подложки",
        "percent_brightness": "яркость {opacity}%",
        "fix_misalignment": "Поправить смещение",
        "reset": "сброс"
    },
    "restore": {
        "description": "У вас обнаружились несохранённые правки с прошлого раза. Восстановить их?",
        "restore": "Восстановить",
        "reset": "Забыть"
    },
    "save": {
        "title": "Сохранить",
        "help": "Отправить сделанные изменения на сервер OpenStreetMap, сделав их доступными всему миру",
        "no_changes": "Сохранять нечего.",
        "error": "Во время сохранения произошла ошибка",
        "uploading": "Отправляем данные на сервер OpenStreetMap.",
        "unsaved_changes": "У вас есть несохранённые правки"
    },
    "splash": {
        "welcome": "Здравствуйте! Это iD, редактор карты OpenStreetMap",
        "text": "Вы пользуетесь неокончательной версией {version}. Подробнее на сайте {website}, об ошибках сообщайте в {github}."
    },
    "source_switch": {
        "live": "основной",
        "dev": "тест"
    },
    "tag_reference": {
        "description": "Описание",
        "on_wiki": "{tag} в вики OSM",
        "used_with": "ставится на {type}"
    },
    "validations": {
        "untagged_point": "Точка без тегов и не в составе линии или контура",
        "untagged_line": "Линия без тегов",
        "untagged_area": "Контур без тегов",
        "many_deletions": "Вы удаляете {n} объектов. Уверены в своём решении? В результате они пропадут с карты, которую весь мир может видеть на openstreetmap.org.",
        "tag_suggests_area": "Тег {tag} обычно ставится на замкнутые контуры, но это не контур",
        "deprecated_tags": "Теги устарели: {tags}"
    },
    "zoom": {
        "in": "Приблизить",
        "out": "Отдалить"
    }
};
locale.es = {
    "modes": {
        "add_area": {
            "title": "Área",
            "description": "Agregar parques, edificios, lagos u otras zonas en el mapa",
            "tail": "Haz clic en el mapa para empezar a dibujar un área. Parques, lagos o edificios"
        },
        "add_line": {
            "title": "Línea",
            "description": "Las líneas pueden ser autopistas, calles, pasos peatonales o canales.",
            "tail": "Haz clic para dibujar en el mapa, una calle, camino o ruta."
        },
        "add_point": {
            "title": "Punto",
            "description": "Un punto puede ser un restaurante, un monumento, un buzón... etc.",
            "tail": "Haz clic para agregar un punto en el mapa"
        },
        "browse": {
            "title": "Navegar",
            "description": "Acercar y mover el mapa"
        },
        "draw_area": {
            "tail": "Haz clic para agregar vértices en tu área. Haz clic de nuevo en el primer vértice para cerrar el área."
        },
        "draw_line": {
            "tail": "Hacer clic para agregar más vértices a la línea. Hacer clic en otras líneas para conectarlas, y doble clic para terminar."
        }
    },
    "operations": {
        "add": {
            "annotation": {
                "point": "Punto agregado",
                "vertex": "Vértice añadido a la ruta"
            }
        },
        "start": {
            "annotation": {
                "line": "Línea iniciada",
                "area": "Área iniciada"
            }
        },
        "continue": {
            "annotation": {
                "line": "Línea continuada.",
                "area": "Área continuada."
            }
        },
        "cancel_draw": {
            "annotation": "Dibujo cancelado."
        },
        "change_tags": {
            "annotation": "Etiquetas cambiadas."
        },
        "circularize": {
            "title": "Redondear",
            "description": "Redondear esto.",
            "key": "O",
            "annotation": {
                "line": "Redondear línea.",
                "area": "Redondear área."
            }
        },
        "orthogonalize": {
            "title": "Escuadrar",
            "description": "Escuadrar esquinas.",
            "key": "E",
            "annotation": {
                "line": "Esquinas de la línea escuadrados.",
                "area": "Esquinas del área escuadrados."
            }
        },
        "delete": {
            "title": "Eliminar",
            "description": "Eliminar del mapa.",
            "annotation": {
                "point": "Punto eliminado.",
                "vertex": "Vértice elimnado de la ruta.",
                "line": "Línea eliminada.",
                "area": "Área eliminada.",
                "relation": "Relación eliminada.",
                "multiple": "{n} objetos eliminados."
            }
        },
        "connect": {
            "annotation": {
                "point": "Punto conectado a la línea.",
                "vertex": "Ruta conectada a otra línea.",
                "line": "Línea conectada a la línea.",
                "area": "Línea conectada al área."
            }
        },
        "disconnect": {
            "title": "Desconectar",
            "description": "Desconectar líneas.",
            "key": "D",
            "annotation": "Líneas desconectadas."
        },
        "merge": {
            "title": "Combinar",
            "description": "Combinar líneas.",
            "key": "C",
            "annotation": "{n} líneas combinadas."
        },
        "move": {
            "title": "Mover",
            "description": "Mover a otra ubicación.",
            "key": "M",
            "annotation": {
                "point": "Punto movido",
                "vertex": "Vertice movido",
                "line": "Línea movida",
                "area": "Área movida"
            }
        },
        "reverse": {
            "title": "Invertir",
            "description": "Invertir sentido de la linea.",
            "key": "I",
            "annotation": "Sentido de la línea invertido."
        },
        "split": {
            "title": "Dividir",
            "description": "Dividir en dos en éste punto.",
            "key": "D",
            "annotation": "Dividir ruta."
        }
    },
    "nothing_to_undo": "Nada que deshacer",
    "nothing_to_redo": "Nada que rehacer",
    "just_edited": "Acabas de editar OpenStreetMap!",
    "browser_notice": "Este editor soporta Firefox, Chrome, Safari, Opera e Internet Explorer 9 o superior. Por favor actualiza tu navegador o utiliza Potlatch 2 para editar el mapa.",
    "view_on_osm": "Ver en OSM",
    "zoom_in_edit": "Acerca para editar el mapa",
    "logout": "Cerrar sesión",
    "report_a_bug": "Reportar un error",
    "commit": {
        "title": "Guardar Cambios",
        "description_placeholder": "Breve descripción de tus contribuciones",
        "upload_explanation": "Los cambios que subes como {user} serán visibles en todos los mapas que usen datos de OpenStreetMap.",
        "save": "Guardar",
        "cancel": "Cancelar",
        "warnings": "Avisos",
        "modified": "Modificado",
        "deleted": "Borrado",
        "created": "Creado"
    },
    "contributors": {
        "list": "Viendo las contribuciones de {users}",
        "truncated_list": "Viendo las contribuciones de {users} y {count} más"
    },
    "geocoder": {
        "title": "Buscar un lugar",
        "placeholder": "buscar un lugar",
        "no_results": "No se pudo encontrar el lugar llamado '{name}'"
    },
    "geolocate": {
        "title": "Mostrar mi Localización"
    },
    "inspector": {
        "no_documentation_combination": "No hay documentación disponible para esta combinación de etiquetas",
        "no_documentation_key": "No hay documentación disponible para esta tecla",
        "new_tag": "Nueva etiqueta",
        "view_on_osm": "Ver en OSM"
    },
    "background": {
        "title": "Fondo",
        "description": "Configuración de fondo",
        "percent_brightness": "{opacity}% brillo",
        "fix_misalignment": "Alinear",
        "reset": "reiniciar"
    },
    "restore": {
        "description": "Tienes cambios no guardados de una sesión de edición previa. ¿Quieres recuperar tus cambios?",
        "restore": "Restaurar",
        "reset": "Descartar"
    },
    "save": {
        "title": "Guardar",
        "help": "Guardar los cambios en OpenStreetMap haciéndolos visibles a otros usuarios.",
        "error": "Ha ocurrido un error tratando de guardar",
        "uploading": "Subiendo cambios a OpenStreetMap",
        "unsaved_changes": "Tienes cambios sin guardar"
    },
    "splash": {
        "welcome": "Bienvenido al editor de OpenStreetMap iD",
        "text": "Esto es una versión {version} de desarrollo. Para más información visita {website} y reporta cualquier error en {github}."
    },
    "source_switch": {
        "live": "en vivo",
        "dev": "dev"
    },
    "tag_reference": {
        "description": "Descripción",
        "on_wiki": "{tag} en wiki.osm.org",
        "used_with": "usado con {type}"
    },
    "validations": {
        "untagged_point": "Punto sin etiquetar que no es parte de una línea ni de un área.",
        "untagged_line": "Línea sin etiquetar",
        "untagged_area": "Área sin etiquetar",
        "many_deletions": "You're deleting {n} objects. Are you sure you want to do this? This will delete them from the map that everyone else sees on openstreetmap.org.",
        "tag_suggests_area": "La etiqueta {tag} sugiere que esta línea debería ser una área, pero no lo es.",
        "deprecated_tags": "Etiquetas obsoletas: {tags}"
    },
    "zoom": {
        "in": "Acercar",
        "out": "Alejar"
    }
};
locale.sv = {
    "modes": {
        "add_area": {
            "title": "Område",
            "description": "Lägg till parker, byggnader, sjöar, eller andra områden till kartan.",
            "tail": "Klicka på kartan för att börja rita ett område, typ en park, sjö eller byggnad."
        },
        "add_line": {
            "title": "Linje",
            "description": "Linjer kan vara vägar, gator, stigar, kanaler etc.",
            "tail": "Klicka på kartan för att rita en väg, stig eller vattendrag."
        },
        "add_point": {
            "title": "Punkt",
            "description": "Restauranter, minnesmärken och postkontor kan vara punkter.",
            "tail": "Klicka på kartan för att lägga till en punkt."
        },
        "browse": {
            "title": "Bläddra",
            "description": "Panera runt och zooma kartan."
        },
        "draw_area": {
            "tail": "Klicka här för att lägga till punkter till ditt område. Klicka på förste punkten igen for att avsluta området."
        },
        "draw_line": {
            "tail": "Klicka här för att lägga till fler punkter till linjen. Klicka på andra linjer for att knyta ihop dem och dubbelklicka för att slutföra linjen."
        }
    },
    "operations": {
        "add": {
            "annotation": {
                "point": "Lagt till en punkt.",
                "vertex": "Lagt till en nod till en linje."
            }
        },
        "start": {
            "annotation": {
                "line": "Startat en linje.",
                "area": "Startat ett område."
            }
        },
        "continue": {
            "annotation": {
                "line": "Fortsatt en linje.",
                "area": "Fortsatt ett område."
            }
        },
        "cancel_draw": {
            "annotation": "Avbröt ritning."
        },
        "change_tags": {
            "annotation": "Ändrat tagg."
        },
        "circularize": {
            "title": "Cirkularisera",
            "description": "Gör denna rund.",
            "key": "O",
            "annotation": {
                "line": "Gjorde en linje rund.",
                "area": "Gjorde ett område runt."
            }
        },
        "orthogonalize": {
            "title": "Ortogonalisering",
            "description": "Gör kvadrat-hörn.",
            "key": "Q",
            "annotation": {
                "line": "Gjort hörnen på en linje fyrkantiga.",
                "area": "Gjort hörnen på ett område fyrkantiga."
            }
        },
        "delete": {
            "title": "Ta bort",
            "description": "Tag bort detta från kartan.",
            "annotation": {
                "point": "Tagit bort en punkt.",
                "vertex": "Tagit bort en nod från en väg.",
                "line": "Tagit bort en linje.",
                "area": "Tagit bort ett område.",
                "relation": "Tagit bort en relation.",
                "multiple": "Tagit bort {n} objekt."
            }
        },
        "connect": {
            "annotation": {
                "point": "Forbandt en vej til et punkt.",
                "vertex": "Forbandt en vej til en anden vej.",
                "line": "Forbandt en vej til en linje.",
                "area": "Forbandt en vej til et område."
            }
        },
        "disconnect": {
            "title": "Bryt av",
            "description": "Bryt av dessa vägar från varandra.",
            "key": "D",
            "annotation": "Bryt av linjen."
        },
        "merge": {
            "title": "Sammanfoga",
            "description": "Sammanfoga dessa linjer.",
            "key": "C",
            "annotation": "Sammanfogade {n} linjer."
        },
        "move": {
            "title": "Flytta",
            "description": "Flytta detta till ett annan ställe.",
            "key": "M",
            "annotation": {
                "point": "Flyttade en punkt.",
                "vertex": "Flyttade en nod i en väg.",
                "line": "Flyttade en linje.",
                "area": "Flyttade ett område.",
                "multiple": "Flyttade flera objekt."
            }
        },
        "rotate": {
            "title": "Rotera",
            "description": "Rotera detta objekt runt dess centerpunkt.",
            "key": "R",
            "annotation": {
                "line": "Roterade en linje.",
                "area": "Roterade ett område."
            }
        },
        "reverse": {
            "title": "Byt riktning",
            "description": "Byt riktning på linjen.",
            "key": "V",
            "annotation": "Bytte riktning på en linje."
        },
        "split": {
            "title": "Dela upp",
            "description": "Dela upp vägen till två vägar vid den här punkten.",
            "key": "X",
            "annotation": "Delade upp."
        }
    },
    "nothing_to_undo": "Inget att ångra.",
    "nothing_to_redo": "Inget att upprepa.",
    "just_edited": "Du har nu redigerat OpenStreetMap!",
    "browser_notice": "Denna redigerare funkar i Firefox, Chrome, Safari, Opera och Internet Explorer 9 och högre. Uppgradera din webbläsare eller använd Potlatch 2 för att redigera på kartan.",
    "view_on_osm": "Visa på OSM",
    "zoom_in_edit": "Zooma in för att fixa på kartan",
    "logout": "logga ut",
    "report_a_bug": "rapportera ett fel",
    "commit": {
        "title": "Spara ändringar",
        "description_placeholder": "Kort beskrivning av dina ändringar",
        "upload_explanation": "Ändringar du uppladdar som {user} kommer att kunna ses på alla kartor som användar OpenStreetMap data.",
        "save": "Spara",
        "cancel": "Avbryt",
        "warnings": "Varningar",
        "modified": "Ändrat",
        "deleted": "Borttaget",
        "created": "Skapat"
    },
    "contributors": {
        "list": "Visa bidrag från {users}",
        "truncated_list": "Visa bidrag från {users} och {count} andra"
    },
    "geocoder": {
        "title": "Hitta ett ställe",
        "placeholder": "Hitta ett ställe",
        "no_results": "Kunde inte hitta '{name}'"
    },
    "geolocate": {
        "title": "Visa var jag är"
    },
    "inspector": {
        "no_documentation_combination": "Der er ingen dokumentation for denne tag kombination",
        "no_documentation_key": "Det finns inget dokumentation för denna nyckel.",
        "new_tag": "Ny tagg",
        "view_on_osm": "Visa på OSM",
        "additional": "Fler taggar",
        "choose": "Vad lägger du till?",
        "results": "{n} sökresult för {search}",
        "reference": "Visa OpenStreetMap Wiki →"
    },
    "background": {
        "title": "Bakgrund",
        "description": "Bakgrundsinställningar",
        "percent_brightness": "{opacity}% ljusstyrka",
        "fix_misalignment": "Fixa feljustering",
        "reset": "återställ"
    },
    "restore": {
        "description": "Du har ändringar från förra sessiones som inte har sparats. Vill du spara dessa ändringar?",
        "restore": "Återställ",
        "reset": "Återställ"
    },
    "save": {
        "title": "Spara",
        "help": "Spara ändringer till OpenStreetMap så att andra användare kan se dem.",
        "no_changes": "Inget att spara.",
        "error": "Något gick fel vid sparandet",
        "uploading": "Dina ändringer sparas nu till OpenStreetMap.",
        "unsaved_changes": "Du har icke-sparade ändringer."
    },
    "splash": {
        "welcome": "Välkommen till iD OpenStreetMap redigerare",
        "text": "Detta är utvecklingsversion {version}. Mer information besök {website} och rapportera fel på {github}."
    },
    "source_switch": {
        "live": "live",
        "dev": "dev"
    },
    "tag_reference": {
        "description": "Beskrivning",
        "on_wiki": "{tag} på wiki.osm.org",
        "used_with": "används med {type}"
    },
    "validations": {
        "untagged_point": "Otaggad punkt som inte är del av linje eller område",
        "untagged_line": "Otaggad linje",
        "untagged_area": "Otaggat område",
        "many_deletions": "Du håller på att ta bort {n} objekt. Är du helt säker? Detta tar bort dem för alla som använder openstreetmap.org.",
        "tag_suggests_area": "Denna tagg {tag} indikerar att denna linje borde vara ett område, men detta är inte ett område",
        "deprecated_tags": "Uönskade taggar: {tags}"
    },
    "zoom": {
        "in": "Zooma in",
        "out": "Zooma ut"
    }
};
locale.tr = {
    "modes": {
        "add_area": {
            "title": "Alan",
            "description": "Park, bina, göl ve benzeri alanları haritaya ekle.",
            "tail": "Park, göl ya da bina gibi alanları çizmek için haritaya tıklayın."
        },
        "add_line": {
            "title": "Çizgi",
            "description": "Yollar, sokaklar, patikalar ya da kanallar çizgi ile çizilebilir.",
            "tail": "Yol, patika yada rota çizmek için haritaya tıklayın."
        },
        "add_point": {
            "title": "Nokta",
            "description": "Restoranlar, anıtlar ya da posta kutuları nokta ile gösterilebilir.",
            "tail": "Nokta eklemek için haritaya tıklayın."
        },
        "browse": {
            "title": "Dolaş",
            "description": "Harita üzerinde dolan ve yaklaş."
        },
        "draw_area": {
            "tail": "Alanınıza nokta eklemek için tıklayınız. İlk noktaya tıklayarak alan çizimini bitirebilirsiniz."
        },
        "draw_line": {
            "tail": "Çizgiye daha fazla nokta eklemek için tıklayınız. Diğer çizgilerle bağlamak için üstlerine tıklyınız ve bitirmek için de son noktada çift tıklayınız."
        }
    },
    "operations": {
        "add": {
            "annotation": {
                "point": "Nokta eklendi.",
                "vertex": "Çizgiye bir nod eklendi."
            }
        },
        "start": {
            "annotation": {
                "line": "Çizgi çizimi başlatıldı.",
                "area": "Alan çizimi başlatıldı."
            }
        },
        "continue": {
            "annotation": {
                "line": "Çizgiye devam edildi.",
                "area": "Alana devam edildi."
            }
        },
        "cancel_draw": {
            "annotation": "Çizim iptal edildi."
        },
        "change_tags": {
            "annotation": "Etiketler değiştirildi."
        },
        "circularize": {
            "title": "Daireleştir",
            "description": "Yuvarlak hale getir",
            "key": "O",
            "annotation": {
                "line": "Çizgiyi daireleştirin.",
                "area": "Alanı daireleştirin."
            }
        },
        "orthogonalize": {
            "title": "Doğrultmak",
            "description": "Köşeleri doğrultun.",
            "key": "Q",
            "annotation": {
                "line": "Çizginin köşeleri doğrultuldu.",
                "area": "Alanın köşeleri doğrultuldu."
            }
        },
        "delete": {
            "title": "Sil",
            "description": "Haritan bunu sil.",
            "annotation": {
                "point": "Bir nokta silindi.",
                "vertex": "Yoldan bir nod silindi.",
                "line": "Bir çizgi silindi.",
                "area": "Bir alan silindi.",
                "relation": "Bir ilişki silindi.",
                "multiple": "{n} adet obje silindi."
            }
        },
        "connect": {
            "annotation": {
                "point": "Taraf bir noktaya bağlandı.",
                "vertex": "Bir taraf diğerine bağlandı.",
                "line": "Taraf bir çizgiye bağlandı.",
                "area": "Taraf bir alana bağlandı."
            }
        },
        "disconnect": {
            "title": "Birbirinden Ayır",
            "description": "Her iki tarafı da ayır.",
            "key": "D",
            "annotation": "Taraflar birbirinden ayrıldı."
        },
        "merge": {
            "title": "Birleştir",
            "description": "Bu çizgileri birleştir.",
            "key": "C",
            "annotation": "{n} adet çizgi birleştirildi."
        },
        "move": {
            "title": "Taşı",
            "description": "Bunu farklı bir konuma taşı.",
            "key": "M",
            "annotation": {
                "point": "Bir nokta taşındı.",
                "vertex": "Yoldan bir nokta taşındı.",
                "line": "Bir çizgi taşındı.",
                "area": "Bir alan taşındı."
            }
        },
        "reverse": {
            "title": "Ters çevir",
            "description": "Bu çizgiyi ters yönde çevir.",
            "key": "V",
            "annotation": "Çizgi ters çevrildi."
        },
        "split": {
            "title": "Ayır",
            "description": "Bu yolu bu noktadan ikiye ayır.",
            "key": "X",
            "annotation": "Yolu ayır."
        }
    },
    "nothing_to_undo": "Geri alınacak birşey yok.",
    "nothing_to_redo": "Tekrar yapılacak birşey yok.",
    "just_edited": "Şu an OpenStreetMap'de bir değişiklik yaptınız!",
    "browser_notice": "Bu editör sadece Firefox, Chrome, Safari, Opera ile Internet Explorer 9 ve üstü tarayıcılarda çalışmaktadır. Lütfen tarayınıcı güncelleyin ya da Potlatch 2'yi kullanarak haritada güncelleme yapınız.",
    "view_on_osm": "OSM üstünde Gör",
    "zoom_in_edit": "Güncelleme yapmak için haritada yakınlaşmalısınız",
    "logout": "Çıkış",
    "report_a_bug": "Hata rapor et",
    "commit": {
        "title": "Değişiklikleri kaydet",
        "description_placeholder": "Katkı sağlayanlar hakkında kısa açıklama",
        "upload_explanation": "{user} kullanıcısı olarak yaptığınız değişiklikler tüm OpenStreetMap kullanan haritalarda görünür olacaktır.",
        "save": "Kaydet",
        "cancel": "İptal",
        "warnings": "Uyarılar",
        "modified": "Değiştirildi",
        "deleted": "Silindi",
        "created": "Oluşturuldu"
    },
    "contributors": {
        "list": "{users} tarafından yapılan katkılar görünmektedir",
        "truncated_list": "{users} ve diğer {count} tarafından yapılan katkılar görünmektedir"
    },
    "geocoder": {
        "title": "Bir Yer Bul",
        "placeholder": "bir yer bul",
        "no_results": "'{name}' ismindeki yer bulunamadı"
    },
    "geolocate": {
        "title": "Konumumu göster"
    },
    "inspector": {
        "no_documentation_combination": "Bu etiket kombinasyonu için dökümantasyon bulunmamaktadır.",
        "no_documentation_key": "Bu anahtar için dökümantasyon bulunmamaktadır.",
        "new_tag": "Yeni Etiket",
        "view_on_osm": "OSM üzerinde gör",
        "additional": "Ekstra etiketler",
        "choose": "Neyi ekliyorsunuz?",
        "results": "{n} results for {search}"
    },
    "background": {
        "title": "Arkaplan",
        "description": "Arkaplan Ayarları",
        "percent_brightness": "{opacity}% parlaklık",
        "fix_misalignment": "Yanlış hizalamayı düzelt",
        "reset": "Sıfırla"
    },
    "restore": {
        "description": "Daha önceki oturumunuzdan kaydedilmemiş değişiklikler var. Bu değişiklikleri geri getirmek ister misiniz?",
        "restore": "Geri Getir",
        "reset": "Sıfırla"
    },
    "save": {
        "title": "Kaydet",
        "help": "Diğer kullanıcıların yaptığınız değişiklikleri görmesi için OpenStreetMap'e kaydediniz.",
        "error": "Kaydederken bir hata oluştu",
        "uploading": "Değişiklikleriniz OpenStreetMap'e gönderiliyor.",
        "unsaved_changes": "Kaydedilmemiş değişiklikleriniz var"
    },
    "splash": {
        "welcome": "OpenStreetMap Editörü iD'ye hoşgeldiniz",
        "text": "Bu {version} versiyonu geliştirme versiyonudur. Daha fazla bilgi için {website} sitesine bakabilirsiniz ve hataları {github} sitesine raporlayabilirsiniz."
    },
    "source_switch": {
        "live": "canlı",
        "dev": "geliştirme"
    },
    "tag_reference": {
        "description": "Açıklama",
        "on_wiki": "wiki.osm.org sitesindeki {tag} ",
        "used_with": "{type} ile birlikte"
    },
    "validations": {
        "untagged_point": "Herhangi bir çizgi ya da alana bağlantısı olmayan ve etiketlenmemiş bir nokta.",
        "untagged_line": "Etiketlenmemiş çizgi",
        "untagged_area": "Etiketlenmemiş alan",
        "many_deletions": "Şu an {n} adet objeyi siliyorsunuz. Bunu yapmak istediğinize emin misiniz? Bu işlem ile ilgili objelerin tamamı herkesin ziyaret ettiği openstreetmap.org üzerinden de silinmiş olacaktır.",
        "tag_suggests_area": "{tag} etiketi buranın alan olmasını tavsiye ediyor ama alan değil.",
        "deprecated_tags": "Kullanımdan kaldırılmış etiket : {tags}"
    },
    "zoom": {
        "in": "Yaklaş",
        "out": "Uzaklaş"
    }
};
locale.uk = {
    "modes": {
        "add_area": {
            "title": "Полігон",
            "description": "Додати парки, будівлі, озера та інше на мапу.",
            "tail": "Клацніть на мапу, щоб розпочати креслити — наприклад, парк, озеро чи будинок."
        },
        "add_line": {
            "title": "Лінія",
            "description": "Лініями позначаються дороги, вулиці, стежки, чи навіть, канали.",
            "tail": "Клацніть на мапу, щоб розпочати креслити дорогу, стежку чи канал."
        },
        "add_point": {
            "title": "Точка",
            "description": "Ресторани, пам’ятники, поштові скрині.",
            "tail": "Клацніть на мапу, щоб постаивти точку."
        },
        "browse": {
            "title": "Перегляд",
            "description": "Пересування та масштабування мапи."
        },
        "draw_area": {
            "tail": "Клацніть, щоб додати точку до полігону. Клацніть на початкову точку, щоб замкнути полігон."
        },
        "draw_line": {
            "tail": "Клацніть, щоб додати ще точку до лінії. Клацніть на іншу лінію, щоб з’єднатись з нею, подвійне клачання — завершення креслення лінії."
        }
    },
    "operations": {
        "add": {
            "annotation": {
                "point": "Додано точку.",
                "vertex": "Точку додано до лінії."
            }
        },
        "start": {
            "annotation": {
                "line": "Розпочато креслення лінії.",
                "area": "Розпочато креслення полігону."
            }
        },
        "continue": {
            "annotation": {
                "line": "Лінію подовженно.",
                "area": "Полігон змінено."
            }
        },
        "cancel_draw": {
            "annotation": "Креслення відмінене."
        },
        "change_tags": {
            "annotation": "Теґи змінені."
        },
        "circularize": {
            "title": "Закруглити",
            "description": "Перетворити на коло.",
            "key": "O",
            "annotation": {
                "line": "Лінія перетворена на коло.",
                "area": "Полігон перетворено на коло."
            }
        },
        "orthogonalize": {
            "title": "Ортогоналізувати",
            "description": "Зробити кути прямими.",
            "key": "Q",
            "annotation": {
                "line": "Випрямлено кути лінії.",
                "area": "Випрямлено кути полігону."
            }
        },
        "delete": {
            "title": "Вилучити",
            "description": "Вилучити об’єкт з мапи.",
            "annotation": {
                "point": "Вилучено точку.",
                "vertex": "Вилучено точку з лінії.",
                "line": "Вилучено лінію.",
                "area": "Вилучено полігон.",
                "relation": "Вилучено зв’язок.",
                "multiple": "Вилучено {n} обґктів."
            }
        },
        "connect": {
            "annotation": {
                "point": "Лінію приєднано до точки.",
                "vertex": "Лінію приєднано до іншої лінії.",
                "line": "Ліняя з’єднана з іншою лінією.",
                "area": "Лінія з’єднана з полігоном."
            }
        },
        "disconnect": {
            "title": "Роз’єднати",
            "description": "Роз’єднати лінії одна від одної.",
            "key": "D",
            "annotation": "Роз’єднано лінії."
        },
        "merge": {
            "title": "Поєднати",
            "description": "Поєднати лінії.",
            "key": "C",
            "annotation": "З’єднати {n} ліній."
        },
        "move": {
            "title": "Посунтуи",
            "description": "Посунути об’єкт на інше місце.",
            "key": "M",
            "annotation": {
                "point": "Точку посунуто.",
                "vertex": "Точку лінії посунуто.",
                "line": "Лінію посунуто.",
                "area": "Полігон посунуто.",
                "multiple": "Посунуто кілька об’єктів."
            }
        },
        "rotate": {
            "title": "Обернути",
            "description": "Обернути об’єкт навколо його центру.",
            "key": "R",
            "annotation": {
                "line": "Напрямок лінії змінено.",
                "area": "Полігон обернуто."
            }
        },
        "reverse": {
            "title": "Розвернути",
            "description": "Змінити напрямок лінії на протилежний.",
            "key": "V",
            "annotation": "Напрямок лінії змінено."
        },
        "split": {
            "title": "Розділити",
            "description": "Розділити лінію на дві в цій точці.",
            "key": "X",
            "annotation": "Розділити лінію."
        }
    },
    "nothing_to_undo": "Скасовувати нічого.",
    "nothing_to_redo": "Повертати нічого.",
    "just_edited": "Ви тільки що відредагували мапу OpenStreetMap!",
    "browser_notice": "Цей редактор працює в оглядачах Firefox, Chrome, Safari, Opera і Internet Explorer версії 9 і вище.  Будь ласка, оновіть свій оглядач або скористайтеся редактором Potlatch 2.",
    "view_on_osm": "Подивитись в ОСМ",
    "zoom_in_edit": "наблизтесь, щоб редагувати",
    "logout": "вийти",
    "report_a_bug": "повідомити про помилку",
    "commit": {
        "title": "Зберегти зміни",
        "description_placeholder": "Короткий опис ваших правок",
        "upload_explanation": "Зміни, зроблені вами під іменем {user}, з’являться на всіх мапах, що використовують дані OpenStreetMap.",
        "save": "Зберегти",
        "cancel": "Відмінити",
        "warnings": "Попередження",
        "modified": "Змінено",
        "deleted": "Вилучено",
        "created": "Створено"
    },
    "contributors": {
        "list": "Тут мапу редагували: {users}",
        "truncated_list": "Тут мапу редагували {users} та ще {count} інших"
    },
    "geocoder": {
        "title": "Знайти місце",
        "placeholder": "знайти місце",
        "no_results": "Неможливо знайти '{name}'"
    },
    "geolocate": {
        "title": "Моє місцезнаходження"
    },
    "inspector": {
        "no_documentation_combination": "Для цієї комбінації теґів немає документації",
        "no_documentation_key": "Для цього теґа немає документації",
        "show_more": "Ще",
        "new_tag": "Новий теґ",
        "view_on_osm": "Подивтись в ОСМ",
        "editing_feature": "Властивості {feature}",
        "additional": "Додаткові теґи",
        "choose": "Виберіть тип об’єкту",
        "results": "знайдено {n} об’єктів на запит {search}",
        "reference": "Подивитись на OpenStreetMap Wiki →",
        "back_tooltip": "Змінити тип об’єкта"
    },
    "background": {
        "title": "Фон",
        "description": "Налаштування фону",
        "percent_brightness": "прозорість {opacity}%",
        "fix_misalignment": "Виправити зсув",
        "reset": "скинути"
    },
    "restore": {
        "description": "У вас виявилися незбережені правки з минулого разу. Відновити їх?",
        "restore": "Відновити",
        "reset": "Відкинути"
    },
    "save": {
        "title": "Зберегти",
        "help": "Зберегти зміни надіславши їх на OpenStreetMap, та зробивши їх доступними всім іншим.",
        "no_changes": "Зміни для збереження відсутні.",
        "error": "Під час збереження виникла помилка",
        "uploading": "Надсилання змін до OpenStreetMap.",
        "unsaved_changes": "Ви маєте незбережені правки"
    },
    "splash": {
        "welcome": "Ласкаво просимо до редактора OpenStreetMap — iD",
        "text": "Це експериментальна версія {version}. Докладніше на {website}, сповіщайте про помилки на {github}."
    },
    "source_switch": {
        "live": "основна",
        "dev": "тест"
    },
    "tag_reference": {
        "description": "Опис",
        "on_wiki": "{tag} на wiki.osm.org",
        "used_with": "використовується з {type}"
    },
    "validations": {
        "untagged_point": "Точка без теґів, що не є частиною лінію чи полігону",
        "untagged_line": "Лінія без теґів",
        "untagged_area": "Полігон без  теґів",
        "tag_suggests_area": "Теґ {tag} зазвичай ставться на полігони, але об’єкт ним не є",
        "deprecated_tags": "Застарілі теґи: {tags}"
    },
    "zoom": {
        "in": "Наблизитись",
        "out": "Віддалитись"
    },
    "imagery": {
        "provided_by": "Фон наданий {source}"
    },
    "gpx": {
        "local_layer": "Локальний файл GPX",
        "drag_drop": "Перетягніть файл .gpx на сторінку"
    },
    "presets": {
        "fields": {
            "access": {
                "label": "Доступ"
            },
            "address": {
                "label": "Адреса",
                "placeholders": {
                    "housename": "Назвабудинку",
                    "number": "Номер",
                    "street": "Вулиця",
                    "city": "Місто"
                }
            },
            "aeroway": {
                "label": "Тип"
            },
            "amenity": {
                "label": "Тип"
            },
            "atm": {
                "label": "Банкомат"
            },
            "barrier": {
                "label": "Тип"
            },
            "bicycle_parking": {
                "label": "Тип"
            },
            "building": {
                "label": "Будинок"
            },
            "building_area": {
                "label": "Будинок"
            },
            "building_yes": {
                "label": "Будинок"
            },
            "capacity": {
                "label": "Міськість"
            },
            "collection_times": {
                "label": "Час виїмки пошти"
            },
            "construction": {
                "label": "Тип"
            },
            "country": {
                "label": "Країна"
            },
            "crossing": {
                "label": "Тип"
            },
            "cuisine": {
                "label": "Кухня"
            },
            "denomination": {
                "label": "Віросповідання"
            },
            "denotation": {
                "label": "Позначення"
            },
            "elevation": {
                "label": "Висота"
            },
            "emergency": {
                "label": "Аварійні служби"
            },
            "entrance": {
                "label": "Тип"
            },
            "fax": {
                "label": "Факс"
            },
            "fee": {
                "label": "Плата"
            },
            "highway": {
                "label": "Тип"
            },
            "historic": {
                "label": "Тип"
            },
            "internet_access": {
                "label": "Доступ до Інтеренету",
                "options": {
                    "wlan": "Wifi",
                    "wired": "Дротовий",
                    "terminal": "Термінал"
                }
            },
            "landuse": {
                "label": "Тип"
            },
            "layer": {
                "label": "Шар"
            },
            "leisure": {
                "label": "Тип"
            },
            "levels": {
                "label": "Поверхи"
            },
            "man_made": {
                "label": "Тип"
            },
            "maxspeed": {
                "label": "Обмеження швидкості"
            },
            "natural": {
                "label": "Природа"
            },
            "network": {
                "label": "Мережа"
            },
            "note": {
                "label": "Примітка"
            },
            "office": {
                "label": "Тип"
            },
            "oneway": {
                "label": "Односторонній рух"
            },
            "opening_hours": {
                "label": "Години"
            },
            "operator": {
                "label": "Оператор"
            },
            "phone": {
                "label": "Телефон"
            },
            "place": {
                "label": "Тип"
            },
            "power": {
                "label": "Тип"
            },
            "railway": {
                "label": "Тип"
            },
            "ref": {
                "label": "Посилання"
            },
            "religion": {
                "label": "Релігія",
                "options": {
                    "christian": "Християнство",
                    "muslim": "Мусульманство",
                    "buddhist": "Будизм",
                    "jewish": "Іудейство",
                    "hindu": "Хінду",
                    "shinto": "Сінто",
                    "taoist": "Даосизм"
                }
            },
            "service": {
                "label": "Тип"
            },
            "shelter": {
                "label": "Притулок"
            },
            "shop": {
                "label": "Тип"
            },
            "source": {
                "label": "Джерело"
            },
            "sport": {
                "label": "Спорт"
            },
            "structure": {
                "label": "Споруда",
                "options": {
                    "bridge": "Міст",
                    "tunnel": "Тунель",
                    "embankment": "Насип",
                    "cutting": "Виїмка"
                }
            },
            "surface": {
                "label": "Поверхня"
            },
            "tourism": {
                "label": "Тип"
            },
            "water": {
                "label": "Тип"
            },
            "waterway": {
                "label": "Тип"
            },
            "website": {
                "label": "Вебсайт"
            },
            "wetland": {
                "label": "Тип"
            },
            "wheelchair": {
                "label": "Для інвалідних візків"
            },
            "wikipedia": {
                "label": "Вікіпедія"
            },
            "wood": {
                "label": "Тип"
            }
        },
        "presets": {
            "aeroway": {
                "name": "Аеропорт"
            },
            "aeroway/aerodrome": {
                "name": "Аеропорт",
                "terms": "літак,аеропорт,аеродром"
            },
            "aeroway/helipad": {
                "name": "Вертолітний майданчик",
                "terms": "вертоліт,вертолітний майданчик,вертодром"
            },
            "amenity": {
                "name": "Зручності"
            },
            "amenity/bank": {
                "name": "Банк",
                "terms": "депозитний сейф,бухгалтерія,кредитна спілка,казна,фонди,накопичення,інвестиційна компанія,сховище,резерв,скарбниця,сейф,заощадження,біржа,запаси,запас,скарбниця,багатство,казначейство,трастова компанія,сховище"
            },
            "amenity/bar": {
                "name": "Бар"
            },
            "amenity/bench": {
                "name": "Лавка"
            },
            "amenity/bicycle_parking": {
                "name": "Вело-парковка"
            },
            "amenity/bicycle_rental": {
                "name": "Прокат велосипедів"
            },
            "amenity/cafe": {
                "name": "Кафе",
                "terms": "кава,чай,кав’ярня"
            },
            "amenity/cinema": {
                "name": "Кінотеатр"
            },
            "amenity/courthouse": {
                "name": "Суд"
            },
            "amenity/embassy": {
                "name": "Амбасада"
            },
            "amenity/fast_food": {
                "name": "Фаст-Фуд"
            },
            "amenity/fire_station": {
                "name": "Пожежна станція"
            },
            "amenity/fuel": {
                "name": "Заправка"
            },
            "amenity/grave_yard": {
                "name": "Цвинтар"
            },
            "amenity/hospital": {
                "name": "Лікарня"
            },
            "amenity/library": {
                "name": "Бібліотека"
            },
            "amenity/marketplace": {
                "name": "Ринок"
            },
            "amenity/parking": {
                "name": "Стоянка"
            },
            "amenity/pharmacy": {
                "name": "Аптека"
            },
            "amenity/place_of_worship": {
                "name": "Культове місце"
            },
            "amenity/place_of_worship/christian": {
                "name": "Церква"
            },
            "amenity/place_of_worship/jewish": {
                "name": "Синагога",
                "terms": "іудейство,синагога"
            },
            "amenity/place_of_worship/muslim": {
                "name": "Мечеть",
                "terms": "мусульманство,мечеть"
            },
            "amenity/police": {
                "name": "Міліція/Поліція"
            },
            "amenity/post_box": {
                "name": "Поштова скриня"
            },
            "amenity/post_office": {
                "name": "Пошта"
            },
            "amenity/pub": {
                "name": "Паб"
            },
            "amenity/restaurant": {
                "name": "Ресторан"
            },
            "amenity/school": {
                "name": "Школа"
            },
            "amenity/swimming_pool": {
                "name": "Басейн"
            },
            "amenity/telephone": {
                "name": "Телефон"
            },
            "amenity/theatre": {
                "name": "Театр",
                "terms": "театр,вистава,гра,музичний"
            },
            "amenity/toilets": {
                "name": "Туалет"
            },
            "amenity/townhall": {
                "name": "Міська державна адміністрація"
            },
            "amenity/university": {
                "name": "Університет"
            },
            "barrier": {
                "name": "Перепони"
            },
            "barrier/block": {
                "name": "Блок"
            },
            "barrier/bollard": {
                "name": "Стовпчик"
            },
            "barrier/cattle_grid": {
                "name": "Перешкода для худоби"
            },
            "barrier/city_wall": {
                "name": "Міська стіна"
            },
            "barrier/cycle_barrier": {
                "name": "Перешкода для велосипедистів"
            },
            "barrier/ditch": {
                "name": "Канава"
            },
            "barrier/entrance": {
                "name": "Вхід"
            },
            "barrier/fence": {
                "name": "Огорожа"
            },
            "barrier/gate": {
                "name": "Ворота"
            },
            "barrier/hedge": {
                "name": "Жива огорожа"
            },
            "barrier/kissing_gate": {
                "name": "Вузька хвіртка"
            },
            "barrier/lift_gate": {
                "name": "Шлагбаум"
            },
            "barrier/retaining_wall": {
                "name": "Підпірна стіна"
            },
            "barrier/stile": {
                "name": "Перелаз/Турнікет"
            },
            "barrier/toll_booth": {
                "name": "Пункт сплати за проїзд"
            },
            "barrier/wall": {
                "name": "Стіна"
            },
            "building": {
                "name": "Будинок"
            },
            "building/entrance": {
                "name": "Вхід"
            },
            "entrance": {
                "name": "Вхід"
            },
            "highway": {
                "name": "Дорога"
            },
            "highway/bridleway": {
                "name": "Сходи"
            },
            "highway/bus_stop": {
                "name": "Автобусна зупинка"
            },
            "highway/crossing": {
                "name": "Прехресття"
            },
            "highway/cycleway": {
                "name": "Вело-доріжка"
            },
            "highway/footway": {
                "name": "Тротуар"
            },
            "highway/motorway": {
                "name": "Автомагістраль"
            },
            "highway/path": {
                "name": "Тропа"
            },
            "highway/primary": {
                "name": "Головна дорога"
            },
            "highway/residential": {
                "name": "Дорога місцевого значення"
            },
            "highway/secondary": {
                "name": "Другорядна дорога"
            },
            "highway/service": {
                "name": "Третинна дорога"
            },
            "highway/steps": {
                "name": "Сходи"
            },
            "highway/tertiary": {
                "name": "Третинна дорога"
            },
            "highway/track": {
                "name": "Грунтовка"
            },
            "highway/traffic_signals": {
                "name": "Світлофор"
            },
            "highway/trunk": {
                "name": "Шосе"
            },
            "highway/turning_circle": {
                "name": "Місце для розвороту"
            },
            "highway/unclassified": {
                "name": "Не має класифікації"
            },
            "historic": {
                "name": "Історичні місця"
            },
            "historic/archaeological_site": {
                "name": "Археологічні пам’ятки"
            },
            "historic/boundary_stone": {
                "name": "Прикордонний камінь"
            },
            "historic/castle": {
                "name": "За́мок"
            },
            "historic/memorial": {
                "name": "Пам’ятник"
            },
            "historic/monument": {
                "name": "Пам’ятник"
            },
            "historic/ruins": {
                "name": "Руїни"
            },
            "historic/wayside_cross": {
                "name": "Придорожній хрест"
            },
            "historic/wayside_shrine": {
                "name": "Придорожня рака"
            },
            "landuse": {
                "name": "Землекористування"
            },
            "landuse/allotments": {
                "name": "Дачі/горо́ди"
            },
            "landuse/basin": {
                "name": "Водойма"
            },
            "landuse/cemetery": {
                "name": "Кладовище"
            },
            "landuse/commercial": {
                "name": "Діловий район"
            },
            "landuse/construction": {
                "name": "Будівництво"
            },
            "landuse/farm": {
                "name": "Ферма"
            },
            "landuse/farmyard": {
                "name": "Двір ферми"
            },
            "landuse/forest": {
                "name": "Лісовий масив"
            },
            "landuse/grass": {
                "name": "Трава"
            },
            "landuse/industrial": {
                "name": "Промзона"
            },
            "landuse/meadow": {
                "name": "Левада"
            },
            "landuse/orchard": {
                "name": "Сад"
            },
            "landuse/quarry": {
                "name": "Кар’єр"
            },
            "landuse/residential": {
                "name": "Житлова зона"
            },
            "landuse/vineyard": {
                "name": "Виноградник"
            },
            "leisure": {
                "name": "Дозвілля"
            },
            "leisure/garden": {
                "name": "Сад"
            },
            "leisure/golf_course": {
                "name": "Поле для гольфу"
            },
            "leisure/marina": {
                "name": "Пристань для яхт"
            },
            "leisure/park": {
                "name": "Парк"
            },
            "leisure/pitch": {
                "name": "Спортивний майданчик"
            },
            "leisure/pitch/american_football": {
                "name": "Поле для американського футболу"
            },
            "leisure/pitch/baseball": {
                "name": "Бейсбольний майданчик"
            },
            "leisure/pitch/basketball": {
                "name": "Баскетбольний майданчик"
            },
            "leisure/pitch/soccer": {
                "name": "Футбольне поле"
            },
            "leisure/pitch/tennis": {
                "name": "Тенісний майданчик"
            },
            "leisure/playground": {
                "name": "Ігровий майданчик"
            },
            "leisure/slipway": {
                "name": "Сліп"
            },
            "leisure/stadium": {
                "name": "Стадіон"
            },
            "leisure/swimming_pool": {
                "name": "Басейн"
            },
            "man_made": {
                "name": "Штучні споруди"
            },
            "man_made/lighthouse": {
                "name": "Маяк"
            },
            "man_made/pier": {
                "name": "Пірс"
            },
            "man_made/survey_point": {
                "name": "Геодезичний пункт"
            },
            "man_made/water_tower": {
                "name": "Водонапірна вежа"
            },
            "natural": {
                "name": "Природа"
            },
            "natural/bay": {
                "name": "Затока"
            },
            "natural/beach": {
                "name": "Пляж"
            },
            "natural/cliff": {
                "name": "Скеля/Яр"
            },
            "natural/coastline": {
                "name": "Берегова лінія",
                "terms": "прибійна смуга"
            },
            "natural/glacier": {
                "name": "Льодовик"
            },
            "natural/grassland": {
                "name": "Трави"
            },
            "natural/heath": {
                "name": "Пустир/Вереск"
            },
            "natural/peak": {
                "name": "Пік"
            },
            "natural/scrub": {
                "name": "Чагарник"
            },
            "natural/spring": {
                "name": "Джерело"
            },
            "natural/tree": {
                "name": "Дерево"
            },
            "natural/water": {
                "name": "Вода"
            },
            "natural/water/lake": {
                "name": "Озеро"
            },
            "natural/water/pond": {
                "name": "Ставок"
            },
            "natural/water/reservoir": {
                "name": "Резервуар"
            },
            "natural/wetland": {
                "name": "Заболочені землі"
            },
            "natural/wood": {
                "name": "Дерева"
            },
            "office": {
                "name": "Офіс"
            },
            "place": {
                "name": "Місцевість"
            },
            "place/hamlet": {
                "name": "Хутір"
            },
            "place/island": {
                "name": "Острів"
            },
            "place/locality": {
                "name": "Місцевість"
            },
            "place/village": {
                "name": "Село"
            },
            "power": {
                "name": "Енергетика"
            },
            "power/generator": {
                "name": "Електростанція"
            },
            "power/line": {
                "name": "Лінія електропередач"
            },
            "power/pole": {
                "name": "Опора"
            },
            "power/sub_station": {
                "name": "Підстанція"
            },
            "power/tower": {
                "name": "Опора ЛЕП"
            },
            "power/transformer": {
                "name": "Трансформатор"
            },
            "railway": {
                "name": "Залізниця"
            },
            "railway/abandoned": {
                "name": "Занедбані колії"
            },
            "railway/disused": {
                "name": "Путі, що не використовуються"
            },
            "railway/level_crossing": {
                "name": "Залізничний переїзд"
            },
            "railway/monorail": {
                "name": "Монорейка"
            },
            "railway/rail": {
                "name": "Рейки"
            },
            "railway/subway": {
                "name": "Метрополітен"
            },
            "railway/subway_entrance": {
                "name": "Вхід до метро"
            },
            "railway/tram": {
                "name": "Трамвай"
            },
            "shop": {
                "name": "Магазини/Майстерні"
            },
            "shop/bakery": {
                "name": "Булочна"
            },
            "shop/beverages": {
                "name": "Напої"
            },
            "shop/bicycle": {
                "name": "Веломагазин"
            },
            "shop/books": {
                "name": "Книгарня"
            },
            "shop/boutique": {
                "name": "Бутік"
            },
            "shop/butcher": {
                "name": "М’ясна лавка"
            },
            "shop/car": {
                "name": "Автосалон"
            },
            "shop/car_parts": {
                "name": "Автозапчастини"
            },
            "shop/car_repair": {
                "name": "Автомайстерня"
            },
            "shop/chemist": {
                "name": "Побутова хімія"
            },
            "shop/clothes": {
                "name": "Одяг"
            },
            "shop/computer": {
                "name": "Комп’ютери"
            },
            "shop/confectionery": {
                "name": "Кондитерська"
            },
            "shop/convenience": {
                "name": "міні-маркет"
            },
            "shop/deli": {
                "name": "Делікатеси/Вишукана їжа"
            },
            "shop/department_store": {
                "name": "Універмаг"
            },
            "shop/doityourself": {
                "name": "Зроби сам"
            },
            "shop/dry_cleaning": {
                "name": "Хімчистка"
            },
            "shop/electronics": {
                "name": "Електроніка"
            },
            "shop/fishmonger": {
                "name": "Риба"
            },
            "shop/florist": {
                "name": "Квіти"
            },
            "shop/furniture": {
                "name": "Меблі"
            },
            "shop/garden_centre": {
                "name": "Садово-парковий центр"
            },
            "shop/gift": {
                "name": "Подарунки"
            },
            "shop/greengrocer": {
                "name": "Овочевий"
            },
            "shop/hairdresser": {
                "name": "Перукарня"
            },
            "shop/hardware": {
                "name": "Господарські товари"
            },
            "shop/hifi": {
                "name": "Аудіо апаратура"
            },
            "shop/jewelry": {
                "name": "Ювелірні прикраси"
            },
            "shop/kiosk": {
                "name": "Кіоск"
            },
            "shop/laundry": {
                "name": "Пральня"
            },
            "shop/mall": {
                "name": "Торгівельний центр"
            },
            "shop/mobile_phone": {
                "name": "Мобільні телефони"
            },
            "shop/motorcycle": {
                "name": "Мотомагазин"
            },
            "shop/music": {
                "name": "Музичний магазин"
            },
            "shop/optician": {
                "name": "Оптика"
            },
            "shop/outdoor": {
                "name": "Товари для активного відпочинку"
            },
            "shop/pet": {
                "name": "Товари для тварин"
            },
            "shop/shoes": {
                "name": "Взуття"
            },
            "shop/sports": {
                "name": "Спорттовари"
            },
            "shop/stationery": {
                "name": "Канцтовари"
            },
            "shop/supermarket": {
                "name": "Супермаркет"
            },
            "shop/toys": {
                "name": "Іграшки"
            },
            "shop/travel_agency": {
                "name": "Туристична агенція"
            },
            "shop/tyres": {
                "name": "Колеса та шини"
            },
            "shop/vacant": {
                "name": "Здається в оренду"
            },
            "shop/variety_store": {
                "name": "Універсам"
            },
            "shop/video": {
                "name": "Відео"
            },
            "tourism": {
                "name": "Туризм"
            },
            "tourism/alpine_hut": {
                "name": "Гірський притулок"
            },
            "tourism/artwork": {
                "name": "Витвори мистецтв"
            },
            "tourism/attraction": {
                "name": "Визначне місце"
            },
            "tourism/camp_site": {
                "name": "Кемпінг"
            },
            "tourism/caravan_site": {
                "name": "Караван-парк"
            },
            "tourism/chalet": {
                "name": "Шале"
            },
            "tourism/guest_house": {
                "name": "Гостьовий будинок"
            },
            "tourism/hostel": {
                "name": "Хостел"
            },
            "tourism/hotel": {
                "name": "Готель"
            },
            "tourism/information": {
                "name": "Інформація"
            },
            "tourism/motel": {
                "name": "Мотель"
            },
            "tourism/museum": {
                "name": "Музей"
            },
            "tourism/picnic_site": {
                "name": "Місце для пікніка"
            },
            "tourism/theme_park": {
                "name": "Тематичний парк"
            },
            "tourism/viewpoint": {
                "name": "Оглядовий майданчик"
            },
            "tourism/zoo": {
                "name": "Зоопарк"
            },
            "waterway": {
                "name": "Водний шлях"
            },
            "waterway/canal": {
                "name": "Канал"
            },
            "waterway/dam": {
                "name": "Дамба"
            },
            "waterway/ditch": {
                "name": "Канава"
            },
            "waterway/drain": {
                "name": "Дренажний канал"
            },
            "waterway/river": {
                "name": "Ріка"
            },
            "waterway/riverbank": {
                "name": "Берег ріки"
            },
            "waterway/stream": {
                "name": "Струмок"
            },
            "waterway/weir": {
                "name": "Водозлив"
            }
        }
    }
};
locale.vi = {
    "modes": {
        "add_area": {
            "title": "Vùng",
            "description": "Thêm công viên, tòa nhà, hồ nước, hoặc vùng khác vào bản đồ.",
            "tail": "Nhấn vào bản đồ để bắt đầu vẽ vùng."
        },
        "add_line": {
            "title": "Đường",
            "description": "Thêm con đường, lối đi bộ, dòng nước, hoặc đường kẻ khác vào bản đồ.",
            "tail": "Nhấn vào bản đồ để bắt đầu vẽ đường kẻ."
        },
        "add_point": {
            "title": "Điểm",
            "description": "Thêm nhà hàng, đài kỷ niệm, hòm thư, hoặc địa điểm khác.",
            "tail": "Nhấn vào bản đồ để thêm địa điểm."
        },
        "browse": {
            "title": "Duyệt",
            "description": "Di chuyển và thu phóng bản đồ."
        },
        "draw_area": {
            "tail": "Nhấn để thêm nốt vào vùng. Nhấn nốt đầu tiên để hoàn thành vùng."
        },
        "draw_line": {
            "tail": "Nhấn để thêm nốt vào đường kẻ. Nhấn vào đường khác để nối đường lại. Nhấn đúp để hoàn thành đường."
        }
    },
    "operations": {
        "add": {
            "annotation": {
                "point": "Thêm địa điểm.",
                "vertex": "Thêm nốt vào lối."
            }
        },
        "start": {
            "annotation": {
                "line": "Bắt đầu vẽ đường kẻ.",
                "area": "Bắt đầu vẽ vùng."
            }
        },
        "continue": {
            "annotation": {
                "line": "Vẽ tiếp đường kẻ.",
                "area": "Vẽ tiếp vùng."
            }
        },
        "cancel_draw": {
            "annotation": "Hủy vẽ đối tượng."
        },
        "change_tags": {
            "annotation": "Thay đổi thẻ."
        },
        "circularize": {
            "title": "Làm Tròn",
            "description": "Làm tròn một đối tượng.",
            "key": "O",
            "annotation": {
                "line": "Làm tròn một đường kẻ.",
                "area": "Làm tròn một vùng."
            }
        },
        "orthogonalize": {
            "title": "Làm Vuông góc",
            "description": "Làm vuông góc một đối tượng.",
            "key": "Q",
            "annotation": {
                "line": "Làm vuông góc một đường kẻ.",
                "area": "Làm vuông góc một vùng."
            }
        },
        "delete": {
            "title": "Xóa",
            "description": "Xóa đối tượng này khỏi bản đồ.",
            "annotation": {
                "point": "Xóa địa điểm.",
                "vertex": "Xóa nốt khỏi lối.",
                "line": "Xóa đường kẻ.",
                "area": "Xóa vùng.",
                "relation": "Xóa quan hệ.",
                "multiple": "Xóa {n} đối tượng."
            }
        },
        "connect": {
            "annotation": {
                "point": "Nối liền lối với địa điểm.",
                "vertex": "Nối liền đường kẻ với đường khác.",
                "line": "Nối liền lối với đường kẻ.",
                "area": "Nối liền đường kẻ với vùng."
            }
        },
        "disconnect": {
            "title": "Tháo gỡ",
            "description": "Gỡ các lối này khỏi nhau.",
            "key": "G",
            "annotation": "Tháo gỡ lối."
        },
        "merge": {
            "title": "Hợp nhất",
            "description": "Hợp nhất các đường kẻ này.",
            "key": "H",
            "annotation": "Hợp nhất {n} đường kẻ."
        },
        "move": {
            "title": "Di chuyển",
            "description": "Di chuyển đối tượng này sang chỗ khác.",
            "key": "D",
            "annotation": {
                "point": "Di chuyển địa điểm.",
                "vertex": "Di chuyển nốt trong lối.",
                "line": "Di chuyển đường kẻ.",
                "area": "Di chuyển vùng.",
                "multiple": "Di chuyển hơn một đối tượng."
            }
        },
        "rotate": {
            "title": "Xoay",
            "description": "Xoay đối tượng này quanh trung tâm.",
            "key": "X",
            "annotation": {
                "line": "Xoay đường kẻ.",
                "area": "Xoay vùng."
            }
        },
        "reverse": {
            "title": "Đảo ngược",
            "description": "Đảo nguợc chiều đường kẻ này.",
            "key": "V",
            "annotation": "Đảo ngược đường kẻ."
        },
        "split": {
            "title": "Chia cắt",
            "description": "Cắt đôi lối này tại nốt được chọn.",
            "key": "C",
            "annotation": "Cắt đôi một lối."
        }
    },
    "nothing_to_undo": "Không có gì để hoàn tác.",
    "nothing_to_redo": "Không có gì để làm lại.",
    "just_edited": "Bạn vừa sửa đổi OpenStreetMap!",
    "browser_notice": "Chường trình vẽ bản đồ này chạy tốt trong Firefox, Chrome, Safari, Opera, và Internet Explorer 9 trở lên. Xin vui lòng nâng cấp trình duyệt của bạn hoặc sửa đổi bản đồ trong Potlatch 2.",
    "view_on_osm": "Xem tại OSM",
    "zoom_in_edit": "phóng to để sửa đổi bản đồ",
    "logout": "đăng xuất",
    "report_a_bug": "báo cáo lỗi",
    "commit": {
        "title": "Lưu các Thay đổi",
        "description_placeholder": "Tóm lược các đóng góp của bạn",
        "message_label": "Tóm lược sửa đổi",
        "upload_explanation": "Các thay đổi bạn thực hiện dưới tên {user} sẽ xuất hiện trên tất cả các bản đồ sử dụng dữ liệu OpenStreetMap.",
        "save": "Lưu",
        "cancel": "Hủy bỏ",
        "warnings": "Cảnh báo",
        "modified": "Đã Thay đổi",
        "deleted": "Đã Xóa",
        "created": "Đã Tạo"
    },
    "contributors": {
        "list": "Đang xem các đóng góp của {users}",
        "truncated_list": "Đang xem các đóng góp của {users} và {count} người khác"
    },
    "geocoder": {
        "title": "Tìm kiếm địa phương",
        "placeholder": "Tìm kiếm địa phương",
        "no_results": "Không tìm thấy địa phương với tên “{name}”"
    },
    "geolocate": {
        "title": "Nhảy tới Vị trí của Tôi"
    },
    "inspector": {
        "no_documentation_combination": "Không có tài liệu về tổ hợp thẻ này",
        "no_documentation_key": "Không có tài liệu về chìa khóa này",
        "show_more": "Xem thêm",
        "new_tag": "Thẻ mới",
        "view_on_osm": "Xem tại OSM",
        "editing_feature": "Đang sửa {feature}",
        "additional": "Các thẻ nâng cao",
        "choose": "Chọn loại đối tượng",
        "results": "{n} kết quả cho {search}",
        "reference": "Tra cứu OpenStreetMap Wiki →",
        "back_tooltip": "Thay đổi loại đối tượng"
    },
    "background": {
        "title": "Hình nền",
        "description": "Tùy chọn hình nền",
        "percent_brightness": "Sáng {opacity}%",
        "fix_misalignment": "Chỉnh lại hình nền bị chệch",
        "reset": "đặt lại"
    },
    "restore": {
        "heading": "Bạn có thay đổi chưa lưu",
        "description": "Bạn có thay đổi chưa lưu từ một phiên làm việc trước đây. Bạn có muốn khôi phục các thay đổi này không?",
        "restore": "Khôi phục",
        "reset": "Đặt lại"
    },
    "save": {
        "title": "Lưu",
        "help": "Lưu các thay đổi vào OpenStreetMap để cho mọi người xem.",
        "no_changes": "Không có thay đổi nào để lưu.",
        "error": "Đã xuất hiện lỗi khi lưu",
        "uploading": "Đang tải các thay đổi lên OpenStreetMap.",
        "unsaved_changes": "Bạn có Thay đổi Chưa lưu"
    },
    "splash": {
        "welcome": "Chào mừng bạn đến với iD, chương trình sửa đổi OpenStreetMap",
        "text": "Đây là phiên bản đang phát triển {version}. Xem thêm thông tin tại {website} và báo cáo lỗi tại {github}."
    },
    "source_switch": {
        "live": "thật",
        "lose_changes": "Bạn có các thay đổi chưa lưu. Các thay đổi này sẽ bị mất khi bạn đổi máy chủ bản đồ. Bạn có chắc chắn muốn đổi máy chủ?",
        "dev": "thử"
    },
    "tag_reference": {
        "description": "Miêu tả",
        "on_wiki": "{tag} tại wiki.osm.org",
        "used_with": "được sử dụng với {type}"
    },
    "validations": {
        "untagged_point": "Địa điểm không có thẻ mà không trực thuộc đường kẻ hoặc vùng",
        "untagged_line": "Đường kẻ không có thẻ",
        "untagged_area": "Vùng không có thẻ",
        "many_deletions": "Bạn có chắc chắn muốn xóa {n} đối tượng? Các đối tượng này sẽ bị xóa khỏi bản đồ công cộng tại openstreetmap.org.",
        "tag_suggests_area": "Thẻ {tag} có lẽ dành cho vùng nhưng được gắn vào đường kẻ",
        "deprecated_tags": "Thẻ bị phản đối: {tags}"
    },
    "zoom": {
        "in": "Phóng to",
        "out": "Thu nhỏ"
    },
    "imagery": {
        "provided_by": "Hình ảnh do {source} cung cấp"
    },
    "gpx": {
        "local_layer": "Tập tin GPX địa phương",
        "drag_drop": "Kéo thả một tập tin .gpx vào trang"
    },
    "help": {
        "title": "Trợ giúp"
    },
    "presets": {
        "fields": {
            "access": {
                "label": "Quyền Truy cập"
            },
            "address": {
                "label": "Địa chỉ",
                "placeholders": {
                    "housename": "Tên nhà",
                    "number": "123",
                    "street": "Tên đường",
                    "city": "Thành phố"
                }
            },
            "aeroway": {
                "label": "Loại"
            },
            "amenity": {
                "label": "Loại"
            },
            "atm": {
                "label": "Máy Rút tiền"
            },
            "barrier": {
                "label": "Kiểu"
            },
            "bicycle_parking": {
                "label": "Kiểu"
            },
            "building": {
                "label": "Tòa nhà"
            },
            "building_area": {
                "label": "Tòa nhà"
            },
            "building_yes": {
                "label": "Tòa nhà"
            },
            "capacity": {
                "label": "Số Chỗ Đậu Xe"
            },
            "collection_times": {
                "label": "Giờ Lấy thư"
            },
            "construction": {
                "label": "Kiểu"
            },
            "country": {
                "label": "Quốc gia"
            },
            "crossing": {
                "label": "Kiểu"
            },
            "cuisine": {
                "label": "Ẩm thực"
            },
            "denomination": {
                "label": "Giáo phái"
            },
            "denotation": {
                "label": "Tầm Quan trọng"
            },
            "elevation": {
                "label": "Cao độ"
            },
            "emergency": {
                "label": "Khẩn cấp"
            },
            "entrance": {
                "label": "Kiểu"
            },
            "fax": {
                "label": "Số Fax"
            },
            "fee": {
                "label": "Phí"
            },
            "highway": {
                "label": "Kiểu"
            },
            "historic": {
                "label": "Loại"
            },
            "internet_access": {
                "label": "Truy cập Internet",
                "options": {
                    "wlan": "Wi-Fi",
                    "wired": "Qua dây điện",
                    "terminal": "Máy tính công cộng"
                }
            },
            "landuse": {
                "label": "Mục đích"
            },
            "layer": {
                "label": "Lớp"
            },
            "leisure": {
                "label": "Loại"
            },
            "levels": {
                "label": "Số Tầng"
            },
            "man_made": {
                "label": "Loại"
            },
            "maxspeed": {
                "label": "Tốc độ Tối đa"
            },
            "name": {
                "label": "Tên"
            },
            "natural": {
                "label": "Thiên nhiên"
            },
            "network": {
                "label": "Hệ thống"
            },
            "note": {
                "label": "Chú thích"
            },
            "office": {
                "label": "Kiểu"
            },
            "oneway": {
                "label": "Một chiều"
            },
            "oneway_yes": {
                "label": "Một chiều"
            },
            "opening_hours": {
                "label": "Giờ Mở cửa"
            },
            "operator": {
                "label": "Cơ quan Chủ quản"
            },
            "phone": {
                "label": "Số Điện thoại"
            },
            "place": {
                "label": "Kiểu"
            },
            "power": {
                "label": "Kiểu"
            },
            "railway": {
                "label": "Kiểu"
            },
            "ref": {
                "label": "Số"
            },
            "religion": {
                "label": "Tôn giáo",
                "options": {
                    "christian": "Kitô giáo",
                    "muslim": "Hồi giáo",
                    "buddhist": "Phật giáo",
                    "jewish": "Do Thái giáo",
                    "hindu": "Ấn Độ giáo",
                    "shinto": "Thần đạo",
                    "taoist": "Đạo giáo"
                }
            },
            "service": {
                "label": "Kiểu"
            },
            "shelter": {
                "label": "Chỗ che"
            },
            "shop": {
                "label": "Kiểu"
            },
            "source": {
                "label": "Nguồn"
            },
            "sport": {
                "label": "Môn Thể thao"
            },
            "structure": {
                "label": "Cấu trúc",
                "options": {
                    "bridge": "Cầu",
                    "tunnel": "Đường hầm",
                    "embankment": "Đường đắp cao",
                    "cutting": "Đường xẻ"
                }
            },
            "surface": {
                "label": "Mặt"
            },
            "tourism": {
                "label": "Loại"
            },
            "water": {
                "label": "Loại"
            },
            "waterway": {
                "label": "Loại"
            },
            "website": {
                "label": "Trang Web"
            },
            "wetland": {
                "label": "Loại"
            },
            "wheelchair": {
                "label": "Đi Xe lăn Được"
            },
            "wikipedia": {
                "label": "Wikipedia"
            },
            "wood": {
                "label": "Loại"
            }
        },
        "presets": {
            "aeroway": {
                "name": "Hàng không"
            },
            "aeroway/aerodrome": {
                "name": "Sân bay",
                "terms": "máy bay,phi cơ,tàu bay,sân bay,phi trường"
            },
            "aeroway/helipad": {
                "name": "Sân bay Trực thăng",
                "terms": "máy bay trực thăng,máy bay lên thẳng,sân bay trực thăng,sân bay lên thẳng,phi trường trực thăng,sàn đỗ trực thăng,sàn đáp trực thăng"
            },
            "amenity": {
                "name": "Tiện nghi"
            },
            "amenity/bank": {
                "name": "Ngân hàng",
                "terms": "ngân hàng,nhà băng,ngân hàng công đoàn,nhà băng công đoàn,công đoàn tín dụng"
            },
            "amenity/bar": {
                "name": "Quán rượu"
            },
            "amenity/bench": {
                "name": "Ghế"
            },
            "amenity/bicycle_parking": {
                "name": "Chỗ Đậu Xe đạp"
            },
            "amenity/bicycle_rental": {
                "name": "Chỗ Mướn Xe đạp"
            },
            "amenity/cafe": {
                "name": "Quán Cà phê",
                "terms": "cà phê,quán cà phê,trà,quán trà"
            },
            "amenity/cinema": {
                "name": "Rạp phim",
                "terms": "rạp phim,rạp điện ảnh,xi nê, xi-nê,xinê,phim,điện ảnh"
            },
            "amenity/courthouse": {
                "name": "Tòa"
            },
            "amenity/embassy": {
                "name": "Tòa đại sứ"
            },
            "amenity/fast_food": {
                "name": "Nhà hàng Ăn nhanh"
            },
            "amenity/fire_station": {
                "name": "Trạm Cứu hỏa"
            },
            "amenity/fuel": {
                "name": "Cây xăng"
            },
            "amenity/grave_yard": {
                "name": "Nghĩa địa"
            },
            "amenity/hospital": {
                "name": "Bệnh viện",
                "terms": "bệnh viện,nhà thương,phòng khám khẩn cấp,phòng khẩn cấp"
            },
            "amenity/library": {
                "name": "Thư viện"
            },
            "amenity/marketplace": {
                "name": "Chợ phiên"
            },
            "amenity/parking": {
                "name": "Bãi Đậu xe"
            },
            "amenity/pharmacy": {
                "name": "Nhà thuốc"
            },
            "amenity/place_of_worship": {
                "name": "Nơi Thờ phụng",
                "terms": "nơi thờ phụng,nhà thờ,giáo xứ,thánh đường,hội đường"
            },
            "amenity/place_of_worship/christian": {
                "name": "Nhà thờ",
                "terms": "nhà thờ,Kitô giáo,Kitô giáo,Thiên Chúa giáo,đạo Thiên Chúa,giáo xứ,thánh đường"
            },
            "amenity/place_of_worship/jewish": {
                "name": "Nhà thờ Do Thái giáo",
                "terms": "Do Thái giáo,đạo Do Thái,hội đường"
            },
            "amenity/place_of_worship/muslim": {
                "name": "Nhà thờ Hồi giáo",
                "terms": "Hồi giáo,nhà thờ"
            },
            "amenity/police": {
                "name": "Đồn Cảnh sát",
                "terms": "cảnh sát,sở cảnh sát,đồn cảnh sát,trạm cảnh sát,sen đầm,sở sen đầm,đội sen đầm,hiến binh,sở hiến binh,đồn hiến binh,công an,sở công an,đồn công an,trạm công an"
            },
            "amenity/post_box": {
                "name": "Hòm thư",
                "terms": "hòm thư,hộp thư,thùng thư"
            },
            "amenity/post_office": {
                "name": "Bưu điện"
            },
            "amenity/pub": {
                "name": "Quán rượu Pub"
            },
            "amenity/restaurant": {
                "name": "Nhà hàng",
                "terms": "quán ăn,nhà hàng,tiệm ăn,nhà ăn,phòng ăn,quán ăn nhanh,nhà hàng ăn nhanh,quán ăn qua loa,căng tin,căng-tin,xe đẩy,quán rượu,quán bia,tiệm rượu,hiệu chả cá,quán chả nướng,quán phở,tiệm phở,quán cơm,quán bánh cuốn,tiệm bánh cuốn,quán bánh mì,tiệm bánh mì,quán bánh xèo,tiệm bánh xèo,quán chè,tiệm chè,quán gỏi cuốn,quán bún,quán hải sản,quán gà,quán cà ri,quán cà-ri,tiệm cà ri, tiệm cà-ri"
            },
            "amenity/school": {
                "name": "Nhà trường",
                "terms": "trường,trường học,nhà trường,học viện,trường tư,trường tư thực,trường công,trường công lập,tiểu học,trường tiểu học,trung học,trường trung học,trung học cơ sở,trường trung học cơ sở,THCS,TTHCS,trung học phổ thông,trường trung học phổ thông,THPT,TTHPT,trung học chuyên nghiệp,trường trung học chuyên nghiệp,THCN,TTHCN,cao đẳng,trường cao đẳng,CĐ,đại học,trường đại học,ĐH,trường dòng,khoa,học"
            },
            "amenity/swimming_pool": {
                "name": "Hồ Bơi"
            },
            "amenity/telephone": {
                "name": "Điện thoại"
            },
            "amenity/theatre": {
                "name": "Nhà hát",
                "terms": "nhà hát,rạp hát,sân khấu,kịch"
            },
            "amenity/toilets": {
                "name": "Phòng Vệ sinh"
            },
            "amenity/townhall": {
                "name": "Tòa thị chính Thị xã",
                "terms": "tòa thị chính,tòa thị chánh,toà thị chính,toà thị chánh,trụ sở thành phố,trụ sở thị xã,trụ sở làng"
            },
            "amenity/university": {
                "name": "Trường Đại học"
            },
            "barrier": {
                "name": "Chướng ngại"
            },
            "barrier/block": {
                "name": "Tấm Bê tông"
            },
            "barrier/bollard": {
                "name": "Cột Bê tông"
            },
            "barrier/cattle_grid": {
                "name": "Bẫy Trâu bò Trên đường"
            },
            "barrier/city_wall": {
                "name": "Tường thành"
            },
            "barrier/cycle_barrier": {
                "name": "Hàng rào Ngăn Xe đạp"
            },
            "barrier/ditch": {
                "name": "Mương"
            },
            "barrier/entrance": {
                "name": "Cửa vào"
            },
            "barrier/fence": {
                "name": "Hàng rào"
            },
            "barrier/gate": {
                "name": "Cổng"
            },
            "barrier/hedge": {
                "name": "Hàng rào Cây"
            },
            "barrier/kissing_gate": {
                "name": "Cửa Hàng rào Chắn Trâu bò"
            },
            "barrier/lift_gate": {
                "name": "Rào chắn Đóng mở"
            },
            "barrier/retaining_wall": {
                "name": "Tường Chắn Đất"
            },
            "barrier/stile": {
                "name": "Bậc trèo"
            },
            "barrier/toll_booth": {
                "name": "Nhà thu phí"
            },
            "barrier/wall": {
                "name": "Tường"
            },
            "building": {
                "name": "Tòa nhà"
            },
            "building/entrance": {
                "name": "Cửa vào"
            },
            "entrance": {
                "name": "Cửa vào"
            },
            "highway": {
                "name": "Đường Giao thông"
            },
            "highway/bridleway": {
                "name": "Đường mòn Ngựa",
                "terms": "đường mòn ngựa,đường cưỡi ngựa,đường đi ngựa"
            },
            "highway/bus_stop": {
                "name": "Trạm Xe buýt"
            },
            "highway/crossing": {
                "name": "Lối Băng qua Đường",
                "terms": "lối băng qua đường,lối qua đường,đường ngựa vằn"
            },
            "highway/cycleway": {
                "name": "Đường Xe đạp"
            },
            "highway/footway": {
                "name": "Đường Đi bộ",
                "terms": "đường đi bộ,hè,vỉa hè,đường mòn,phố,đường đi dạo"
            },
            "highway/motorway": {
                "name": "Đường Cao tốc"
            },
            "highway/motorway_link": {
                "name": "Nhánh Ra vào Đường Cao tốc",
                "terms": "đường nhánh,đoạn nhánh,đường nhánh rẽ,đoạn nhánh rẽ,đường nhánh chuyển đường,nhánh chuyển đường,lối ra vào,lối ra,lối vào,nhánh ra,nhánh vào,đường nối"
            },
            "highway/path": {
                "name": "Lối"
            },
            "highway/primary": {
                "name": "Đường Chính"
            },
            "highway/primary_link": {
                "name": "Nhánh Ra vào Đường Chính",
                "terms": "đường nhánh,đoạn nhánh,đường nhánh rẽ,đoạn nhánh rẽ,đường nhánh chuyển đường,nhánh chuyển đường,lối ra vào,lối ra,lối vào,nhánh ra,nhánh vào,đường nối"
            },
            "highway/residential": {
                "name": "Ngõ Dân cư"
            },
            "highway/road": {
                "name": "Đường Nói chung"
            },
            "highway/secondary": {
                "name": "Đường Lớn"
            },
            "highway/secondary_link": {
                "name": "Nhánh Ra vào Đường Lớn",
                "terms": "đường nhánh,đoạn nhánh,đường nhánh rẽ,đoạn nhánh rẽ,đường nhánh chuyển đường,nhánh chuyển đường,lối ra vào,lối ra,lối vào,nhánh ra,nhánh vào,đường nối"
            },
            "highway/service": {
                "name": "Ngách"
            },
            "highway/steps": {
                "name": "Cầu thang",
                "terms": "cầu thang"
            },
            "highway/tertiary": {
                "name": "Phố"
            },
            "highway/tertiary_link": {
                "name": "Nhánh Ra vào Phố",
                "terms": "đường nhánh,đoạn nhánh,đường nhánh rẽ,đoạn nhánh rẽ,đường nhánh chuyển đường,nhánh chuyển đường,lối ra vào,lối ra,lối vào,nhánh ra,nhánh vào,đường nối"
            },
            "highway/track": {
                "name": "Đường mòn"
            },
            "highway/traffic_signals": {
                "name": "Đèn Giao thông",
                "terms": "đèn giao thông,đèn tín hiệu giao thông,đèn tín hiệu,đèn điều khiển giao thông,đèn điều khiển,đèn xanh đèn đỏ,đèn xanh đỏ,đèn ngã tư,đèn ngã ba"
            },
            "highway/trunk": {
                "name": "Xa lộ"
            },
            "highway/trunk_link": {
                "name": "Nhánh Ra vào Xa lộ",
                "terms": "đường nhánh,đoạn nhánh,đường nhánh rẽ,đoạn nhánh rẽ,đường nhánh chuyển đường,nhánh chuyển đường,lối ra vào,lối ra,lối vào,nhánh ra,nhánh vào,đường nối"
            },
            "highway/turning_circle": {
                "name": "Cuối đường Vòng tròn"
            },
            "highway/unclassified": {
                "name": "Phố"
            },
            "historic": {
                "name": "Nơi Lịch sử"
            },
            "historic/archaeological_site": {
                "name": "Khu vực Khảo cổ"
            },
            "historic/boundary_stone": {
                "name": "Mốc Biên giới"
            },
            "historic/castle": {
                "name": "Lâu đài"
            },
            "historic/memorial": {
                "name": "Đài Tưởng niệm"
            },
            "historic/monument": {
                "name": "Đài tưởng niệm"
            },
            "historic/ruins": {
                "name": "Tàn tích"
            },
            "historic/wayside_cross": {
                "name": "Thánh Giá Dọc đường"
            },
            "historic/wayside_shrine": {
                "name": "Đền thánh Dọc đường"
            },
            "landuse": {
                "name": "Kiểu Sử dụng Đất"
            },
            "landuse/allotments": {
                "name": "Khu Vườn Gia đình"
            },
            "landuse/basin": {
                "name": "Lưu vực"
            },
            "landuse/cemetery": {
                "name": "Nghĩa địa"
            },
            "landuse/commercial": {
                "name": "Thương mại"
            },
            "landuse/construction": {
                "name": "Công trường Xây dựng"
            },
            "landuse/farm": {
                "name": "Trại"
            },
            "landuse/farmyard": {
                "name": "Sân Trại"
            },
            "landuse/forest": {
                "name": "Rừng Trồng cây"
            },
            "landuse/grass": {
                "name": "Cỏ"
            },
            "landuse/industrial": {
                "name": "Công nghiệp"
            },
            "landuse/meadow": {
                "name": "Đồng cỏ"
            },
            "landuse/orchard": {
                "name": "Vườn Cây"
            },
            "landuse/quarry": {
                "name": "Mỏ Đá"
            },
            "landuse/residential": {
                "name": "Dân cư"
            },
            "landuse/vineyard": {
                "name": "Vườn Nho"
            },
            "leisure": {
                "name": "Giải trí"
            },
            "leisure/garden": {
                "name": "Vườn"
            },
            "leisure/golf_course": {
                "name": "Sân Golf"
            },
            "leisure/marina": {
                "name": "Bến tàu"
            },
            "leisure/park": {
                "name": "Công viên",
                "terms": "công viên,vườn,vườn hoa,vườn cây,bãi cỏ,bãi cỏ xanh,thảm cỏ xanh,vành đai xanh,sân chơi,khu vui chơi,khu vui chơi trẻ em,khu chơi trẻ em,quảng trường,rừng"
            },
            "leisure/pitch": {
                "name": "Sân cỏ"
            },
            "leisure/pitch/american_football": {
                "name": "Sân cỏ Bóng bầu dục Mỹ"
            },
            "leisure/pitch/baseball": {
                "name": "Sân cỏ Bóng chày"
            },
            "leisure/pitch/basketball": {
                "name": "Sân Bóng rổ"
            },
            "leisure/pitch/soccer": {
                "name": "Sân cỏ Bóng đá"
            },
            "leisure/pitch/tennis": {
                "name": "Sân Quần vợt"
            },
            "leisure/playground": {
                "name": "Khu Vui chơi Trẻ em"
            },
            "leisure/slipway": {
                "name": "Đường Trượt tàu"
            },
            "leisure/stadium": {
                "name": "Sân vận động"
            },
            "leisure/swimming_pool": {
                "name": "Hồ Bơi"
            },
            "man_made": {
                "name": "Công trình"
            },
            "man_made/lighthouse": {
                "name": "Hải đăng"
            },
            "man_made/pier": {
                "name": "Cầu tàu"
            },
            "man_made/survey_point": {
                "name": "Điểm Khảo sát"
            },
            "man_made/water_tower": {
                "name": "Tháp nước"
            },
            "natural": {
                "name": "Thiên nhiên"
            },
            "natural/bay": {
                "name": "Vịnh"
            },
            "natural/beach": {
                "name": "Bãi biển"
            },
            "natural/cliff": {
                "name": "Vách đá"
            },
            "natural/coastline": {
                "name": "Bờ biển",
                "terms": "bờ biển,bờ sông,bờ"
            },
            "natural/glacier": {
                "name": "Sông băng"
            },
            "natural/grassland": {
                "name": "Đồng cỏ"
            },
            "natural/heath": {
                "name": "Bãi hoang"
            },
            "natural/peak": {
                "name": "Đỉnh núi",
                "terms": "đồi,núi,đỉnh núi,đỉnh,chỏm núi,chỏm,chóp núi,chóp,chỏm chóp"
            },
            "natural/scrub": {
                "name": "Đất Bụi rậm"
            },
            "natural/spring": {
                "name": "Suối"
            },
            "natural/tree": {
                "name": "Cây"
            },
            "natural/water": {
                "name": "Nước"
            },
            "natural/water/lake": {
                "name": "Hồ",
                "terms": "hồ,hồ nước"
            },
            "natural/water/pond": {
                "name": "Ao nước",
                "terms": "hồ nhỏ,ao,ao cá,hồ cá,hồ đánh cá"
            },
            "natural/water/reservoir": {
                "name": "Bể nước"
            },
            "natural/wetland": {
                "name": "Đầm lầy"
            },
            "natural/wood": {
                "name": "Rừng"
            },
            "office": {
                "name": "Văn phòng"
            },
            "place": {
                "name": "Địa phương"
            },
            "place/hamlet": {
                "name": "Xóm"
            },
            "place/island": {
                "name": "Đảo",
                "terms": "đảo,hòn đảo,quần đảo,đảo san hô,san hô,cồn cát,cồn,đá ngầm,chỗ nông,chỗ cạn"
            },
            "place/locality": {
                "name": "Địa phương"
            },
            "place/village": {
                "name": "Làng"
            },
            "power": {
                "name": "Điện năng"
            },
            "power/generator": {
                "name": "Nhà máy điện"
            },
            "power/line": {
                "name": "Đường Dây điện"
            },
            "power/pole": {
                "name": "Cột điện"
            },
            "power/sub_station": {
                "name": "Trạm Điện Phụ"
            },
            "power/tower": {
                "name": "Cột điện Cao thế"
            },
            "power/transformer": {
                "name": "Máy biến áp"
            },
            "railway": {
                "name": "Đường sắt"
            },
            "railway/abandoned": {
                "name": "Đường sắt Bỏ hoang"
            },
            "railway/disused": {
                "name": "Đường sắt Không hoạt động"
            },
            "railway/level_crossing": {
                "name": "Giao lộ Đường sắt",
                "terms": "giao lộ đường sắt,giao lộ đường ray,nút giao đường sắt"
            },
            "railway/monorail": {
                "name": "Đường sắt Một ray"
            },
            "railway/rail": {
                "name": "Đường sắt"
            },
            "railway/subway": {
                "name": "Đường Tàu điện ngầm"
            },
            "railway/subway_entrance": {
                "name": "Cửa vào Nhà ga Tàu điện ngầm"
            },
            "railway/tram": {
                "name": "Đường Tàu điện",
                "terms": "đường tàu điện,tàu điện,đường xe điện,xe điện"
            },
            "shop": {
                "name": "Tiệm"
            },
            "shop/alcohol": {
                "name": "Tiệm Rượu"
            },
            "shop/bakery": {
                "name": "Tiệm Bánh"
            },
            "shop/beauty": {
                "name": "Tiệm Mỹ phẩm"
            },
            "shop/beverages": {
                "name": "Tiệm Đồ uống"
            },
            "shop/bicycle": {
                "name": "Tiệm Xe đạp"
            },
            "shop/books": {
                "name": "Hiệu Sách"
            },
            "shop/boutique": {
                "name": "Tiệm Thời trang"
            },
            "shop/butcher": {
                "name": "Tiệm Thịt"
            },
            "shop/car": {
                "name": "Tiệm Xe hơi"
            },
            "shop/car_parts": {
                "name": "Tiệm Phụ tùng Xe hơi"
            },
            "shop/car_repair": {
                "name": "Tiệm Sửa Xe"
            },
            "shop/chemist": {
                "name": "Tiệm Dược phẩm"
            },
            "shop/clothes": {
                "name": "Tiệm Quần áo"
            },
            "shop/computer": {
                "name": "Tiệm Máy tính"
            },
            "shop/confectionery": {
                "name": "Tiệm Kẹo"
            },
            "shop/convenience": {
                "name": "Tiệm Tiện lợi"
            },
            "shop/deli": {
                "name": "Tiệm Deli"
            },
            "shop/department_store": {
                "name": "Tiệm Bách hóa"
            },
            "shop/doityourself": {
                "name": "Tiệm Vật liệu Xây dựng"
            },
            "shop/dry_cleaning": {
                "name": "Tiệm Giặt Hấp tẩy"
            },
            "shop/electronics": {
                "name": "Tiệm Thiết bị Điện tử"
            },
            "shop/fishmonger": {
                "name": "Tiệm Cá"
            },
            "shop/florist": {
                "name": "Tiệm Hoa"
            },
            "shop/furniture": {
                "name": "Tiệm Đồ đạc"
            },
            "shop/garden_centre": {
                "name": "Trung tâm Làm vườn"
            },
            "shop/gift": {
                "name": "Tiệm Quà tặng"
            },
            "shop/greengrocer": {
                "name": "Tiệm Rau quả"
            },
            "shop/hairdresser": {
                "name": "Tiệm Làm tóc"
            },
            "shop/hardware": {
                "name": "Tiệm Ngũ kim"
            },
            "shop/hifi": {
                "name": "Tiệm Thiết bị Âm thanh"
            },
            "shop/jewelry": {
                "name": "Tiệm Kim hoàn"
            },
            "shop/kiosk": {
                "name": "Gian hàng"
            },
            "shop/laundry": {
                "name": "Tiệm Máy giặt"
            },
            "shop/mall": {
                "name": "Trung tâm Thương mại"
            },
            "shop/mobile_phone": {
                "name": "Tiệm Điện thoại Di động"
            },
            "shop/motorcycle": {
                "name": "Tiệm Xe máy"
            },
            "shop/music": {
                "name": "Tiệm Âm nhạc"
            },
            "shop/newsagent": {
                "name": "Quầy báo"
            },
            "shop/optician": {
                "name": "Tiệm Kính mắt"
            },
            "shop/outdoor": {
                "name": "Tiệm Thể thao Ngoài trời"
            },
            "shop/pet": {
                "name": "Tiệm Vật nuôi"
            },
            "shop/shoes": {
                "name": "Tiệm Giày"
            },
            "shop/sports": {
                "name": "Tiệm Thể thao"
            },
            "shop/stationery": {
                "name": "Tiệm Văn phòng phẩm"
            },
            "shop/supermarket": {
                "name": "Siêu thị",
                "terms": "siêu thị,chợ,tiệm,cửa hàng,khu buôn bán,trung tâm buôn bán,chợ trời,chợ phiên,chợ xổm"
            },
            "shop/toys": {
                "name": "Tiệm Đồ chơ"
            },
            "shop/travel_agency": {
                "name": "Văn phòng Du lịch"
            },
            "shop/tyres": {
                "name": "Tiệm Lốp xe"
            },
            "shop/vacant": {
                "name": "Tiệm Đóng cửa"
            },
            "shop/variety_store": {
                "name": "Tiệm Tạp hóa"
            },
            "shop/video": {
                "name": "Tiệm Phim"
            },
            "tourism": {
                "name": "Du lịch"
            },
            "tourism/alpine_hut": {
                "name": "Túp lều trên Núi"
            },
            "tourism/artwork": {
                "name": "Nghệ phẩm"
            },
            "tourism/attraction": {
                "name": "Điểm Thu hút Du lịch"
            },
            "tourism/camp_site": {
                "name": "Nơi Cắm trại"
            },
            "tourism/caravan_site": {
                "name": "Bãi Đậu Nhà lưu động"
            },
            "tourism/chalet": {
                "name": "Nhà nghỉ Riêng biệt"
            },
            "tourism/guest_house": {
                "name": "Nhà khách",
                "terms": "nhà khách,nhà trọ"
            },
            "tourism/hostel": {
                "name": "Nhà trọ"
            },
            "tourism/hotel": {
                "name": "Khách sạn"
            },
            "tourism/information": {
                "name": "Thông tin"
            },
            "tourism/motel": {
                "name": "Khách sạn Dọc đường"
            },
            "tourism/museum": {
                "name": "Bảo tàng",
                "terms": "viện bảo tàng,bảo tàng,thư viện,văn thư lưu trữ,lưu trữ,kho"
            },
            "tourism/picnic_site": {
                "name": "Nơi Ăn Ngoài trời"
            },
            "tourism/theme_park": {
                "name": "Công viên Chủ đề"
            },
            "tourism/viewpoint": {
                "name": "Điểm Ngắm cảnh"
            },
            "tourism/zoo": {
                "name": "Vườn thú"
            },
            "waterway": {
                "name": "Đường sông"
            },
            "waterway/canal": {
                "name": "Kênh đào"
            },
            "waterway/dam": {
                "name": "Đập nước"
            },
            "waterway/ditch": {
                "name": "Mương"
            },
            "waterway/drain": {
                "name": "Cống"
            },
            "waterway/river": {
                "name": "Sông",
                "terms": "sông,con sông,dòng sông,nhánh sông,sông nhánh,sông con,suối,suối nước,dòng suối,châu thổ"
            },
            "waterway/riverbank": {
                "name": "Bờ sông"
            },
            "waterway/stream": {
                "name": "Dòng suối",
                "terms": "nhánh sông,sông nhánh,sông con,suối,suối nước,dòng suối"
            },
            "waterway/weir": {
                "name": "Đập Tràn"
            }
        }
    }
};
